var QC=Object.defineProperty,e_=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')}),Lm=(e,t)=>{for(var n in t)QC(e,n,{get:t[n],enumerable:!0})},t_={};Lm(t_,{Abs:()=>Ao,Acos:()=>Ro,Acosh:()=>Fo,AdadeltaOptimizer:()=>ay,AdagradOptimizer:()=>sy,AdamOptimizer:()=>iy,AdamaxOptimizer:()=>oy,Add:()=>Ha,AddN:()=>Ws,All:()=>Do,Any:()=>Mo,ArgMax:()=>Vs,ArgMin:()=>ju,Asin:()=>Oo,Asinh:()=>Lo,Atan:()=>zo,Atan2:()=>Bo,Atanh:()=>Po,AvgPool:()=>Us,AvgPool3D:()=>qu,AvgPool3DGrad:()=>Id,AvgPoolGrad:()=>kd,BackendWasm:()=>KT,BatchMatMul:()=>Gs,BatchToSpaceND:()=>Wo,Bincount:()=>Sd,BroadcastArgs:()=>Nd,BroadcastTo:()=>r0,Callback:()=>SI,CallbackList:()=>_k,Cast:()=>Hs,Ceil:()=>js,ClipByValue:()=>ja,Complex:()=>Td,ComplexAbs:()=>Ku,Concat:()=>Vo,Conv2D:()=>qs,Conv2DBackpropFilter:()=>Cd,Conv2DBackpropInput:()=>Ks,Conv3D:()=>Xu,Conv3DBackpropFilterV2:()=>_d,Conv3DBackpropInputV2:()=>Ed,Cos:()=>Xs,Cosh:()=>Zs,CropAndResize:()=>Go,Cumprod:()=>Uo,Cumsum:()=>Js,CustomCallback:()=>$k,DataStorage:()=>bd,DenseBincount:()=>$d,DepthToSpace:()=>Ho,DepthwiseConv2dNative:()=>Ys,DepthwiseConv2dNativeBackpropFilter:()=>Ad,DepthwiseConv2dNativeBackpropInput:()=>Rd,Diag:()=>Fd,Dilation2D:()=>Zu,Dilation2DBackpropFilter:()=>Ph,Dilation2DBackpropInput:()=>zh,ENV:()=>Wm,EarlyStopping:()=>NI,Einsum:()=>Dd,Elu:()=>ei,EluGrad:()=>Md,Environment:()=>t0,Equal:()=>qo,Erf:()=>jo,Exp:()=>ti,ExpandDims:()=>Ko,Expm1:()=>Xo,FFT:()=>Od,Fill:()=>Ju,FlipLeftRight:()=>Zo,Floor:()=>ni,FloorDiv:()=>ri,FromPixels:()=>Bh,FusedBatchNorm:()=>ai,FusedConv2D:()=>Is,FusedDepthwiseConv2D:()=>Ss,GPGPUContext:()=>Fh,GatherNd:()=>Yo,GatherV2:()=>Jo,GraphModel:()=>Hb,Greater:()=>Qo,GreaterEqual:()=>si,History:()=>Ek,IFFT:()=>Ld,Identity:()=>ii,Imag:()=>zd,InputSpec:()=>_t,IsFinite:()=>el,IsInf:()=>tl,IsNan:()=>oi,KernelBackend:()=>Hu,LRN:()=>Yu,LRNGrad:()=>Bd,LayerVariable:()=>vk,LayersModel:()=>sa,LeakyRelu:()=>li,Less:()=>nl,LessEqual:()=>rl,LinSpace:()=>Pd,Log:()=>ui,Log1p:()=>al,LogSoftmax:()=>s0,LogicalAnd:()=>sl,LogicalNot:()=>il,LogicalOr:()=>ol,LogicalXor:()=>a0,LowerBound:()=>j_,MathBackendWebGL:()=>nf,Max:()=>pi,MaxPool:()=>di,MaxPool3D:()=>Qu,MaxPool3DGrad:()=>Vd,MaxPoolGrad:()=>Wd,MaxPoolWithArgmax:()=>Ud,Maximum:()=>hi,Mean:()=>ci,Min:()=>fi,Minimum:()=>mi,MirrorPad:()=>gi,Mod:()=>ll,MomentumOptimizer:()=>ly,Multinomial:()=>Gd,Multiply:()=>yi,Neg:()=>ul,NonMaxSuppressionV3:()=>hl,NonMaxSuppressionV4:()=>dl,NonMaxSuppressionV5:()=>cl,NotEqual:()=>pl,OP_SCOPE_SUFFIX:()=>Hm,OneHot:()=>bi,OnesLike:()=>fl,Optimizer:()=>fa,OptimizerConstructors:()=>ak,Pack:()=>ml,PadV2:()=>xi,Pool:()=>q_,Pow:()=>wi,Prelu:()=>vi,Prod:()=>ki,RMSPropOptimizer:()=>uy,RNN:()=>Kr,RaggedGather:()=>Hd,RaggedRange:()=>jd,RaggedTensorToTensor:()=>qd,Range:()=>ep,Rank:()=>Lf,Real:()=>Kd,RealDiv:()=>Qs,Reciprocal:()=>Ii,Reduction:()=>un,Relu:()=>Si,Relu6:()=>Ci,Reshape:()=>gl,ResizeBilinear:()=>Ti,ResizeBilinearGrad:()=>Zd,ResizeNearestNeighbor:()=>Ni,ResizeNearestNeighborGrad:()=>Xd,Reverse:()=>_i,RotateWithOffset:()=>Rl,Round:()=>Ei,Rsqrt:()=>$i,SGDOptimizer:()=>Dc,ScatterNd:()=>yl,SearchSorted:()=>Jd,Select:()=>bl,Selu:()=>xl,Sequential:()=>ko,Sigmoid:()=>Ri,Sign:()=>kl,Sin:()=>Ai,Sinh:()=>vl,Slice:()=>wl,Softmax:()=>Mi,Softplus:()=>Il,SpaceToBatchND:()=>Sl,SparseFillEmptyRows:()=>tp,SparseReshape:()=>Tl,SparseSegmentMean:()=>np,SparseSegmentSum:()=>rp,SparseToDense:()=>Yd,SplitV:()=>Nl,Sqrt:()=>Fi,Square:()=>ap,SquaredDifference:()=>Oi,Step:()=>Ka,StridedSlice:()=>Cl,StringNGrams:()=>sp,StringSplit:()=>ip,StringToHashBucketFast:()=>op,Sub:()=>Li,Sum:()=>Di,SymbolicTensor:()=>kr,Tan:()=>zi,Tanh:()=>Pi,Tensor:()=>Pe,TensorBuffer:()=>Mt,Tile:()=>qa,TopK:()=>_l,Transform:()=>El,Transpose:()=>aa,Unique:()=>Qd,Unpack:()=>$l,UnsortedSegmentSum:()=>lp,UpperBound:()=>K_,Variable:()=>Ns,ZerosLike:()=>Al,_FusedMatMul:()=>ks,abs:()=>Ct,acos:()=>Zm,acosh:()=>Jm,add:()=>J,addN:()=>_0,all:()=>ac,any:()=>Ru,argMax:()=>_s,argMin:()=>Ym,asin:()=>Qm,asinh:()=>eg,atan:()=>tg,atan2:()=>ng,atanh:()=>rg,avgPool:()=>ha,avgPool3d:()=>sg,backend:()=>C0,backend_util:()=>T,basicLSTMCell:()=>R0,batchNorm:()=>Bi,batchNorm2d:()=>ig,batchNorm3d:()=>og,batchNorm4d:()=>lg,batchToSpaceND:()=>mp,bincount:()=>ug,booleanMaskAsync:()=>b1,broadcastArgs:()=>F0,broadcastTo:()=>ys,broadcast_util:()=>Fl,browser:()=>Cp,buffer:()=>ze,callbacks:()=>b4,cast:()=>se,ceil:()=>pg,clipByValue:()=>an,clone:()=>Pr,complex:()=>la,concat:()=>nt,concat1d:()=>hg,concat2d:()=>dg,concat3d:()=>cg,concat4d:()=>fg,constraints:()=>Sk,conv1d:()=>sc,conv2d:()=>cn,conv2dTranspose:()=>ic,conv3d:()=>gg,conv3dTranspose:()=>yg,copyRegisteredKernels:()=>Y_,cos:()=>gp,cosh:()=>oc,cosineWindow:()=>Ec,cumprod:()=>Mu,cumsum:()=>lc,customGrad:()=>Ur,data:()=>XI,denseBincount:()=>jh,deprecationWarn:()=>T0,depthToSpace:()=>bg,depthwiseConv2d:()=>Wi,deregisterOp:()=>v4,device_util:()=>dp,diag:()=>M0,dilation2d:()=>xg,disableDeprecationWarnings:()=>i$,dispose:()=>_e,disposeVariables:()=>o$,div:()=>me,divNoNan:()=>wg,dot:()=>vg,dropout:()=>Qg,einsum:()=>L0,elu:()=>Dl,enableDebugMode:()=>s$,enableProdMode:()=>a$,enclosingPowerOfTwo:()=>ey,engine:()=>pr,env:()=>j,equal:()=>Vn,erf:()=>kg,euclideanNorm:()=>Ng,exp:()=>fn,expandDims:()=>Jt,expm1:()=>Tg,eye:()=>uc,fft:()=>Np,fill:()=>Wn,findBackend:()=>f$,findBackendFactory:()=>m$,floor:()=>Ol,floorDiv:()=>rc,forceHalfFloat:()=>f2,fused:()=>bo,gather:()=>Ll,gatherND:()=>I1,gather_util:()=>dy,getBackend:()=>d$,getGradient:()=>Mf,getKernel:()=>Wh,getKernelsForBackend:()=>Vh,getThreadsCount:()=>lie,gpgpu_util:()=>jN,grad:()=>uR,grads:()=>pR,greater:()=>wn,greaterEqual:()=>da,ifft:()=>yo,imag:()=>yp,image:()=>wr,inTopKAsync:()=>S1,initializers:()=>Nk,input:()=>Gk,io:()=>Qt,irfft:()=>Sc,isFinite:()=>Cg,isInf:()=>_g,isNaN:()=>Eg,keep:()=>Ft,kernel_impls:()=>qr,layers:()=>Tk,leakyRelu:()=>bp,less:()=>pc,lessEqual:()=>Za,linalg:()=>ry,linspace:()=>V0,loadGraphModel:()=>NV,loadGraphModelSync:()=>TV,loadLayersModel:()=>gB,localResponseNormalization:()=>$g,log:()=>Un,log1p:()=>xp,logSigmoid:()=>Ag,logSoftmax:()=>dc,logSumExp:()=>cc,logicalAnd:()=>cr,logicalNot:()=>wp,logicalOr:()=>fc,logicalXor:()=>Rg,losses:()=>O1,lowerBound:()=>G0,matMul:()=>Le,math:()=>j1,max:()=>er,maxPool:()=>Wt,maxPool3d:()=>Fg,maxPoolWithArgmax:()=>H0,maximum:()=>jr,mean:()=>yt,memory:()=>Hh,meshgrid:()=>j0,metrics:()=>vI,min:()=>co,minimum:()=>zl,mirrorPad:()=>Dg,mod:()=>Mg,model:()=>xB,models:()=>kI,moments:()=>vp,movingAverage:()=>x1,mul:()=>z,multiRNNCell:()=>q0,multinomial:()=>K0,neg:()=>dt,nextFrame:()=>cy,norm:()=>Ml,notEqual:()=>Rs,oneHot:()=>fo,ones:()=>Bn,onesLike:()=>Gn,op:()=>L,outerProduct:()=>X0,pad:()=>Er,pad1d:()=>Z0,pad2d:()=>J0,pad3d:()=>Y0,pad4d:()=>Q0,pool:()=>Og,pow:()=>ua,prelu:()=>Ip,print:()=>Xm,prod:()=>Lg,profile:()=>l$,raggedGather:()=>e1,raggedRange:()=>t1,raggedTensorToTensor:()=>n1,rand:()=>r1,randomGamma:()=>o1,randomNormal:()=>gc,randomStandardNormal:()=>l1,randomUniform:()=>Pl,range:()=>Fs,ready:()=>h$,real:()=>mo,reciprocal:()=>Vg,registerBackend:()=>nc,registerCallbackConstructor:()=>vB,registerGradient:()=>i0,registerKernel:()=>up,registerOp:()=>w4,regularizers:()=>II,relu:()=>Ye,relu6:()=>yc,removeBackend:()=>c$,reshape:()=>P,reverse:()=>rr,reverse1d:()=>u1,reverse2d:()=>p1,reverse3d:()=>h1,reverse4d:()=>d1,rfft:()=>Tp,round:()=>bc,rsqrt:()=>xc,scalar:()=>ve,scatterND:()=>v1,scatter_util:()=>Zg,searchSorted:()=>mc,selu:()=>wc,separableConv2d:()=>Bl,sequential:()=>wB,serialization:()=>ne,setBackend:()=>p$,setPlatform:()=>g$,setThreadsCount:()=>oie,setWasmPath:()=>sie,setWasmPaths:()=>iie,setWebGLContext:()=>gN,setdiff1dAsync:()=>c1,sigmoid:()=>dr,sign:()=>Ug,signal:()=>M1,sin:()=>vc,sinh:()=>kc,slice:()=>Ue,slice1d:()=>Sp,slice2d:()=>Ic,slice3d:()=>Wl,slice4d:()=>go,slice_util:()=>Lt,softmax:()=>Ja,softplus:()=>Vi,spaceToBatchND:()=>kp,sparse:()=>L1,sparseToDense:()=>k1,spectral:()=>D1,split:()=>_n,sqrt:()=>en,square:()=>tt,squaredDifference:()=>Nc,squeeze:()=>Ya,stack:()=>Ot,step:()=>Ui,stridedSlice:()=>Gg,string:()=>z1,sub:()=>de,sum:()=>ge,sumOutType:()=>tc,tan:()=>Hg,tanh:()=>$s,tensor:()=>dn,tensor1d:()=>Je,tensor2d:()=>Br,tensor3d:()=>Tc,tensor4d:()=>Ma,tensor5d:()=>f1,tensor6d:()=>m1,tensor_util:()=>Ir,test_util:()=>a1,tidy:()=>W,tile:()=>Pn,time:()=>u$,topk:()=>jg,train:()=>ps,transpose:()=>Fe,truncatedNormal:()=>Cc,unique:()=>qg,unregisterGradient:()=>J_,unregisterKernel:()=>Z_,unsortedSegmentSum:()=>_c,unstack:()=>St,upcastType:()=>tr,upperBound:()=>g1,util:()=>w,valueAndGrad:()=>hR,valueAndGrads:()=>dR,variable:()=>Kg,variableGrads:()=>U0,version:()=>mie,version_converter:()=>_V,version_core:()=>NO,version_layers:()=>My,version_wasm:()=>uie,version_webgl:()=>sX,webgl:()=>iX,webgl_util:()=>mN,where:()=>sn,whereAsync:()=>Xg,zeros:()=>bt,zerosLike:()=>He});var n_=Object.create,zm=Object.defineProperty,r_=Object.getOwnPropertyDescriptor,a_=Object.getOwnPropertyNames,s_=Object.getPrototypeOf,i_=Object.prototype.hasOwnProperty,$t=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ee=(e,t)=>{for(var n in t)zm(e,n,{get:t[n],enumerable:!0})},o_=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of a_(t))!i_.call(e,a)&&a!==n&&zm(e,a,{get:()=>t[a],enumerable:!(r=r_(t,a))||r.enumerable});return e},Ua=(e,t,n)=>(n=e!=null?n_(s_(e)):{},o_(t||!e||!e.__esModule?zm(n,"default",{value:e,enumerable:!0}):n,e)),l_=$t((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(S,M,B){this.low=S|0,this.high=M|0,this.unsigned=!!B}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function a(S){return(S&&S.__isLong__)===!0}r.isLong=a;var s={},i={};function o(S,M){var B,U,G;return M?(S>>>=0,(G=0<=S&&S<256)&&(U=i[S],U)?U:(B=p(S,(S|0)<0?-1:0,!0),G&&(i[S]=B),B)):(S|=0,(G=-128<=S&&S<128)&&(U=s[S],U)?U:(B=p(S,S<0?-1:0,!1),G&&(s[S]=B),B))}r.fromInt=o;function l(S,M){if(isNaN(S))return M?v:x;if(M){if(S<0)return v;if(S>=g)return A}else{if(S<=-y)return F;if(S+1>=y)return E}return S<0?l(-S,M).neg():p(S%m|0,S/m|0,M)}r.fromNumber=l;function p(S,M,B){return new r(S,M,B)}r.fromBits=p;var u=Math.pow;function h(S,M,B){if(S.length===0)throw Error("empty string");if(S==="NaN"||S==="Infinity"||S==="+Infinity"||S==="-Infinity")return x;if(typeof M=="number"?(B=M,M=!1):M=!!M,B=B||10,B<2||36<B)throw RangeError("radix");var U;if((U=S.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return h(S.substring(1),M,B).neg();for(var G=l(u(B,8)),K=x,H=0;H<S.length;H+=8){var X=Math.min(8,S.length-H),ee=parseInt(S.substring(H,H+X),B);if(X<8){var Z=l(u(B,X));K=K.mul(Z).add(l(ee))}else K=K.mul(G),K=K.add(l(ee))}return K.unsigned=M,K}r.fromString=h;function d(S,M){return typeof S=="number"?l(S,M):typeof S=="string"?h(S,M):p(S.low,S.high,typeof M=="boolean"?M:S.unsigned)}r.fromValue=d;var c=1<<16,f=1<<24,m=c*c,g=m*m,y=g/2,b=o(f),x=o(0);r.ZERO=x;var v=o(0,!0);r.UZERO=v;var I=o(1);r.ONE=I;var N=o(1,!0);r.UONE=N;var C=o(-1);r.NEG_ONE=C;var E=p(-1,2147483647,!1);r.MAX_VALUE=E;var A=p(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var F=p(0,-2147483648,!1);r.MIN_VALUE=F;var R=r.prototype;R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},R.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(F)){var M=l(S),B=this.div(M),U=B.mul(M).sub(this);return B.toString(S)+U.toInt().toString(S)}else return"-"+this.neg().toString(S);for(var G=l(u(S,6),this.unsigned),K=this,H="";;){var X=K.div(G),ee=K.sub(X.mul(G)).toInt()>>>0,Z=ee.toString(S);if(K=X,K.isZero())return Z+H;for(;Z.length<6;)Z="0"+Z;H=""+Z+H}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq(F)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,M=31;M>0&&!(S&1<<M);M--);return this.high!=0?M+33:M+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function(S){return a(S)||(S=d(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},R.eq=R.equals,R.notEquals=function(S){return!this.eq(S)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function(S){return this.comp(S)<0},R.lt=R.lessThan,R.lessThanOrEqual=function(S){return this.comp(S)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function(S){return this.comp(S)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function(S){return this.comp(S)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function(S){if(a(S)||(S=d(S)),this.eq(S))return 0;var M=this.isNegative(),B=S.isNegative();return M&&!B?-1:!M&&B?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq(F)?F:this.not().add(I)},R.neg=R.negate,R.add=function(S){a(S)||(S=d(S));var M=this.high>>>16,B=this.high&65535,U=this.low>>>16,G=this.low&65535,K=S.high>>>16,H=S.high&65535,X=S.low>>>16,ee=S.low&65535,Z=0,re=0,te=0,ae=0;return ae+=G+ee,te+=ae>>>16,ae&=65535,te+=U+X,re+=te>>>16,te&=65535,re+=B+H,Z+=re>>>16,re&=65535,Z+=M+K,Z&=65535,p(te<<16|ae,Z<<16|re,this.unsigned)},R.subtract=function(S){return a(S)||(S=d(S)),this.add(S.neg())},R.sub=R.subtract,R.multiply=function(S){if(this.isZero())return x;if(a(S)||(S=d(S)),n){var M=n.mul(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}if(S.isZero())return x;if(this.eq(F))return S.isOdd()?F:x;if(S.eq(F))return this.isOdd()?F:x;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(b)&&S.lt(b))return l(this.toNumber()*S.toNumber(),this.unsigned);var B=this.high>>>16,U=this.high&65535,G=this.low>>>16,K=this.low&65535,H=S.high>>>16,X=S.high&65535,ee=S.low>>>16,Z=S.low&65535,re=0,te=0,ae=0,ie=0;return ie+=K*Z,ae+=ie>>>16,ie&=65535,ae+=G*Z,te+=ae>>>16,ae&=65535,ae+=K*ee,te+=ae>>>16,ae&=65535,te+=U*Z,re+=te>>>16,te&=65535,te+=G*ee,re+=te>>>16,te&=65535,te+=K*X,re+=te>>>16,te&=65535,re+=B*Z+U*ee+G*X+K*H,re&=65535,p(ae<<16|ie,re<<16|te,this.unsigned)},R.mul=R.multiply,R.divide=function(S){if(a(S)||(S=d(S)),S.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var B,U,G;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return v;if(S.gt(this.shru(1)))return N;G=v}else{if(this.eq(F)){if(S.eq(I)||S.eq(C))return F;if(S.eq(F))return I;var K=this.shr(1);return B=K.div(S).shl(1),B.eq(x)?S.isNegative()?I:C:(U=this.sub(S.mul(B)),G=B.add(U.div(S)),G)}else if(S.eq(F))return this.unsigned?v:x;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();G=x}for(U=this;U.gte(S);){B=Math.max(1,Math.floor(U.toNumber()/S.toNumber()));for(var H=Math.ceil(Math.log(B)/Math.LN2),X=H<=48?1:u(2,H-48),ee=l(B),Z=ee.mul(S);Z.isNegative()||Z.gt(U);)B-=X,ee=l(B,this.unsigned),Z=ee.mul(S);ee.isZero()&&(ee=I),G=G.add(ee),U=U.sub(Z)}return G},R.div=R.divide,R.modulo=function(S){if(a(S)||(S=d(S)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return p(~this.low,~this.high,this.unsigned)},R.and=function(S){return a(S)||(S=d(S)),p(this.low&S.low,this.high&S.high,this.unsigned)},R.or=function(S){return a(S)||(S=d(S)),p(this.low|S.low,this.high|S.high,this.unsigned)},R.xor=function(S){return a(S)||(S=d(S)),p(this.low^S.low,this.high^S.high,this.unsigned)},R.shiftLeft=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?p(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):p(0,this.low<<S-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?p(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):p(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function(S){if(a(S)&&(S=S.toInt()),S&=63,S===0)return this;var M=this.high;if(S<32){var B=this.low;return p(B>>>S|M<<32-S,M>>>S,this.unsigned)}else return S===32?p(M,0,this.unsigned):p(M>>>S-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?p(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:p(this.low,this.high,!0)},R.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var S=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},R.toBytesBE=function(){var S=this.high,M=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},r.fromBytes=function(S,M,B){return B?r.fromBytesLE(S,M):r.fromBytesBE(S,M)},r.fromBytesLE=function(S,M){return new r(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,M)},r.fromBytesBE=function(S,M){return new r(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],M)}}),u_=$t(()=>{}),p_=$t(()=>{}),h_=$t((e,t)=>{(function(n,r,a){function s(p){var u=this,h=l();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=h(" "),u.s1=h(" "),u.s2=h(" "),u.s0-=h(p),u.s0<0&&(u.s0+=1),u.s1-=h(p),u.s1<0&&(u.s1+=1),u.s2-=h(p),u.s2<0&&(u.s2+=1),h=null}function i(p,u){return u.c=p.c,u.s0=p.s0,u.s1=p.s1,u.s2=p.s2,u}function o(p,u){var h=new s(p),d=u&&u.state,c=h.next;return c.int32=function(){return h.next()*4294967296|0},c.double=function(){return c()+(c()*2097152|0)*11102230246251565e-32},c.quick=c,d&&(typeof d=="object"&&i(d,h),c.state=function(){return i(h,{})}),c}function l(){var p=4022871197,u=function(h){h=String(h);for(var d=0;d<h.length;d++){p+=h.charCodeAt(d);var c=.02519603282416938*p;p=c>>>0,c-=p,c*=p,p=c>>>0,c-=p,p+=c*4294967296}return(p>>>0)*23283064365386963e-26};return u}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),d_=$t((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.x=0,p.y=0,p.z=0,p.w=0,p.next=function(){var d=p.x^p.x<<11;return p.x=p.y,p.y=p.z,p.z=p.w,p.w^=p.w>>>19^d^d>>>8},l===(l|0)?p.x=l:u+=l;for(var h=0;h<u.length+64;h++)p.x^=u.charCodeAt(h)|0,p.next()}function i(l,p){return p.x=l.x,p.y=l.y,p.z=l.z,p.w=l.w,p}function o(l,p){var u=new s(l),h=p&&p.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),c_=$t((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.next=function(){var d=p.x^p.x>>>2;return p.x=p.y,p.y=p.z,p.z=p.w,p.w=p.v,(p.d=p.d+362437|0)+(p.v=p.v^p.v<<4^(d^d<<1))|0},p.x=0,p.y=0,p.z=0,p.w=0,p.v=0,l===(l|0)?p.x=l:u+=l;for(var h=0;h<u.length+64;h++)p.x^=u.charCodeAt(h)|0,h==u.length&&(p.d=p.x<<10^p.x>>>4),p.next()}function i(l,p){return p.x=l.x,p.y=l.y,p.z=l.z,p.w=l.w,p.v=l.v,p.d=l.d,p}function o(l,p){var u=new s(l),h=p&&p.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),f_=$t((e,t)=>{(function(n,r,a){function s(l){var p=this;p.next=function(){var h=p.x,d=p.i,c,f;return c=h[d],c^=c>>>7,f=c^c<<24,c=h[d+1&7],f^=c^c>>>10,c=h[d+3&7],f^=c^c>>>3,c=h[d+4&7],f^=c^c<<7,c=h[d+7&7],c=c^c<<13,f^=c^c<<9,h[d]=f,p.i=d+1&7,f};function u(h,d){var c,f=[];if(d===(d|0))f[0]=d;else for(d=""+d,c=0;c<d.length;++c)f[c&7]=f[c&7]<<15^d.charCodeAt(c)+f[c+1&7]<<13;for(;f.length<8;)f.push(0);for(c=0;c<8&&f[c]===0;++c);for(c==8?f[7]=-1:f[c],h.x=f,h.i=0,c=256;c>0;--c)h.next()}u(p,l)}function i(l,p){return p.x=l.x.slice(),p.i=l.i,p}function o(l,p){l==null&&(l=+new Date);var u=new s(l),h=p&&p.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.x&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),m_=$t((e,t)=>{(function(n,r,a){function s(l){var p=this;p.next=function(){var h=p.w,d=p.X,c=p.i,f,m;return p.w=h=h+1640531527|0,m=d[c+34&127],f=d[c=c+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=d[c]=m^f,p.i=c,m+(h^h>>>16)|0};function u(h,d){var c,f,m,g,y,b=[],x=128;for(d===(d|0)?(f=d,d=null):(d=d+"\0",f=0,x=Math.max(x,d.length)),m=0,g=-32;g<x;++g)d&&(f^=d.charCodeAt((g+32)%d.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,c=b[g&127]^=f+y,m=c==0?m+1:0);for(m>=128&&(b[(d&&d.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],c=b[m=m+1&127],f^=f<<13,c^=c<<17,f^=f>>>15,c^=c>>>12,b[m]=f^c;h.w=y,h.X=b,h.i=m}u(p,l)}function i(l,p){return p.i=l.i,p.w=l.w,p.X=l.X.slice(),p}function o(l,p){l==null&&(l=+new Date);var u=new s(l),h=p&&p.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(h.X&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),g_=$t((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.next=function(){var d=p.b,c=p.c,f=p.d,m=p.a;return d=d<<25^d>>>7^c,c=c-f|0,f=f<<24^f>>>8^m,m=m-d|0,p.b=d=d<<20^d>>>12^c,p.c=c=c-f|0,p.d=f<<16^c>>>16^m,p.a=m-d|0},p.a=0,p.b=0,p.c=-1640531527,p.d=1367130551,l===Math.floor(l)?(p.a=l/4294967296|0,p.b=l|0):u+=l;for(var h=0;h<u.length+20;h++)p.b^=u.charCodeAt(h)|0,p.next()}function i(l,p){return p.a=l.a,p.b=l.b,p.c=l.c,p.d=l.d,p}function o(l,p){var u=new s(l),h=p&&p.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},d.int32=u.next,d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),y_=$t(()=>{}),b_=$t((e,t)=>{(function(n,r,a){var s=256,i=6,o=52,l="random",p=a.pow(s,i),u=a.pow(2,o),h=u*2,d=s-1,c;function f(I,N,C){var E=[];N=N==!0?{entropy:!0}:N||{};var A=b(y(N.entropy?[I,v(r)]:I??x(),3),E),F=new m(E),R=function(){for(var S=F.g(i),M=p,B=0;S<u;)S=(S+B)*s,M*=s,B=F.g(1);for(;S>=h;)S/=2,M/=2,B>>>=1;return(S+B)/M};return R.int32=function(){return F.g(4)|0},R.quick=function(){return F.g(4)/4294967296},R.double=R,b(v(F.S),r),(N.pass||C||function(S,M,B,U){return U&&(U.S&&g(U,F),S.state=function(){return g(F,{})}),B?(a[l]=S,M):S})(R,A,"global"in N?N.global:this==a,N.state)}function m(I){var N,C=I.length,E=this,A=0,F=E.i=E.j=0,R=E.S=[];for(C||(I=[C++]);A<s;)R[A]=A++;for(A=0;A<s;A++)R[A]=R[F=d&F+I[A%C]+(N=R[A])],R[F]=N;(E.g=function(S){for(var M,B=0,U=E.i,G=E.j,K=E.S;S--;)M=K[U=d&U+1],B=B*s+K[d&(K[U]=K[G=d&G+M])+(K[G]=M)];return E.i=U,E.j=G,B})(s)}function g(I,N){return N.i=I.i,N.j=I.j,N.S=I.S.slice(),N}function y(I,N){var C=[],E=typeof I,A;if(N&&E=="object")for(A in I)try{C.push(y(I[A],N-1))}catch{}return C.length?C:E=="string"?I:I+"\0"}function b(I,N){for(var C=I+"",E,A=0;A<C.length;)N[d&A]=d&(E^=N[d&A]*19)+C.charCodeAt(A++);return v(N)}function x(){try{var I;return c&&(I=c.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),v(I)}catch{var N=n.navigator,C=N&&N.plugins;return[+new Date,n,C,n.screen,v(r)]}}function v(I){return String.fromCharCode.apply(0,I)}if(b(a.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{c=y_()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):a["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),yd=$t((e,t)=>{var n=h_(),r=d_(),a=c_(),s=f_(),i=m_(),o=g_(),l=b_();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),Uv=$t(()=>{}),Pm=$t(()=>{}),Gv=$t(()=>{}),x_=$t(()=>{}),w_=$t(()=>{}),v_=$t(()=>{}),k_=$t((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};function s(){return H.buffer!=pe&&Ge(H.buffer),Ie}function i(){return H.buffer!=pe&&Ge(H.buffer),Te}function o(){return H.buffer!=pe&&Ge(H.buffer),De}function l(){return H.buffer!=pe&&Ge(H.buffer),Be}function p(){return H.buffer!=pe&&Ge(H.buffer),et}var u=typeof a<"u"?a:{},h,d;u.ready=new Promise(function(D,q){h=D,d=q});var c;typeof process<"u"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),m=(D,q)=>{throw q},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=u.ENVIRONMENT_IS_PTHREAD||!1,v="";function I(D){return u.locateFile?u.locateFile(D,v):v+D}var N,C,E;function A(D){D instanceof Zr||U("exiting due to exception: "+D)}if(b){var F=Pm(),R=Gv();y?v=R.dirname(v)+"/":v=__dirname+"/",N=(q,le)=>(q=ya(q)?new URL(q):R.normalize(q),F.readFileSync(q,le?void 0:"utf8")),E=q=>{var le=N(q,!0);return le.buffer||(le=new Uint8Array(le)),le},C=(q,le,Ne)=>{q=ya(q)?new URL(q):R.normalize(q),F.readFile(q,function(Ae,Oe){Ae?Ne(Ae):le(Oe.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(q){if(!(q instanceof Zr))throw q}),process.on("unhandledRejection",function(q){throw q}),m=(q,le)=>{if(kt())throw process.exitCode=q,le;A(le),process.exit(q)},u.inspect=function(){return"[Emscripten Module object]"};let D;try{D=x_()}catch(q){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),q}global.Worker=D.Worker}else(g||y)&&(y?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),typeof r<"u"&&r&&(v=r),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",b||(N=D=>{var q=new XMLHttpRequest;return q.open("GET",D,!1),q.send(null),q.responseText},y&&(E=D=>{var q=new XMLHttpRequest;return q.open("GET",D,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),C=(D,q,le)=>{var Ne=new XMLHttpRequest;Ne.open("GET",D,!0),Ne.responseType="arraybuffer",Ne.onload=()=>{if(Ne.status==200||Ne.status==0&&Ne.response){q(Ne.response);return}le()},Ne.onerror=le,Ne.send(null)}));b&&typeof performance>"u"&&(global.performance=w_().performance);var S=console.log.bind(console),M=console.warn.bind(console);b&&(S=D=>F.writeSync(1,D+`
`),M=D=>F.writeSync(2,D+`
`));var B=u.print||S,U=u.printErr||M;Object.assign(u,f),f=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit);var G;u.wasmBinary&&(G=u.wasmBinary);var K=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Xr("no native wasm support detected");var H,X,ee=!1,Z;function re(D,q){D||Xr(q)}var te=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ae(D,q,le){for(var Ne=q+le,Ae=q;D[Ae]&&!(Ae>=Ne);)++Ae;if(Ae-q>16&&D.buffer&&te)return te.decode(D.buffer instanceof SharedArrayBuffer?D.slice(q,Ae):D.subarray(q,Ae));for(var Oe="";q<Ae;){var fe=D[q++];if(!(fe&128)){Oe+=String.fromCharCode(fe);continue}var ke=D[q++]&63;if((fe&224)==192){Oe+=String.fromCharCode((fe&31)<<6|ke);continue}var gt=D[q++]&63;if((fe&240)==224?fe=(fe&15)<<12|ke<<6|gt:fe=(fe&7)<<18|ke<<12|gt<<6|D[q++]&63,fe<65536)Oe+=String.fromCharCode(fe);else{var Xn=fe-65536;Oe+=String.fromCharCode(55296|Xn>>10,56320|Xn&1023)}}return Oe}function ie(D,q){return D?ae(i(),D,q):""}function we(D,q,le,Ne){if(!(Ne>0))return 0;for(var Ae=le,Oe=le+Ne-1,fe=0;fe<D.length;++fe){var ke=D.charCodeAt(fe);if(ke>=55296&&ke<=57343){var gt=D.charCodeAt(++fe);ke=65536+((ke&1023)<<10)|gt&1023}if(ke<=127){if(le>=Oe)break;q[le++]=ke}else if(ke<=2047){if(le+1>=Oe)break;q[le++]=192|ke>>6,q[le++]=128|ke&63}else if(ke<=65535){if(le+2>=Oe)break;q[le++]=224|ke>>12,q[le++]=128|ke>>6&63,q[le++]=128|ke&63}else{if(le+3>=Oe)break;q[le++]=240|ke>>18,q[le++]=128|ke>>12&63,q[le++]=128|ke>>6&63,q[le++]=128|ke&63}}return q[le]=0,le-Ae}function be(D,q,le){return we(D,i(),q,le)}var pe,Ie,Te,De,Be,et;x&&(pe=u.buffer);function Ge(D){pe=D,u.HEAP8=Ie=new Int8Array(D),u.HEAP16=new Int16Array(D),u.HEAP32=De=new Int32Array(D),u.HEAPU8=Te=new Uint8Array(D),u.HEAPU16=new Uint16Array(D),u.HEAPU32=Be=new Uint32Array(D),u.HEAPF32=new Float32Array(D),u.HEAPF64=et=new Float64Array(D)}var je=u.INITIAL_MEMORY||16777216;if(x)H=u.wasmMemory,pe=u.buffer;else if(u.wasmMemory)H=u.wasmMemory;else if(H=new WebAssembly.Memory({initial:je/65536,maximum:32768,shared:!0}),!(H.buffer instanceof SharedArrayBuffer))throw U("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&U("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");H&&(pe=H.buffer),je=pe.byteLength,Ge(pe);var $e,Ze=[],st=[],Fn=[];function kt(){return K}function In(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)sr(u.preRun.shift());it(Ze)}function qt(){!x&&it(st)}function Sn(){if(!x){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)Nn(u.postRun.shift());it(Fn)}}function sr(D){Ze.unshift(D)}function Dn(D){st.unshift(D)}function Nn(D){Fn.unshift(D)}var Kt=0,qn=null;function ga(D){Kt++,u.monitorRunDependencies&&u.monitorRunDependencies(Kt)}function ru(D){if(Kt--,u.monitorRunDependencies&&u.monitorRunDependencies(Kt),Kt==0&&qn){var q=qn;qn=null,q()}}function Xr(D){u.onAbort&&u.onAbort(D),D="Aborted("+D+")",U(D),ee=!0,Z=1,D+=". Build with -sASSERTIONS for more info.";var q=new WebAssembly.RuntimeError(D);throw d(q),q}var au="data:application/octet-stream;base64,";function Ar(D){return D.startsWith(au)}function ya(D){return D.startsWith("file://")}var Xt;Xt="tfjs-backend-wasm-threaded-simd.wasm",Ar(Xt)||(Xt=I(Xt));function Xp(D){try{if(D==Xt&&G)return new Uint8Array(G);if(E)return E(D);throw"both async and sync fetching of the wasm failed"}catch(q){Xr(q)}}function Zp(){if(!G&&(g||y)){if(typeof fetch=="function"&&!ya(Xt))return fetch(Xt,{credentials:"same-origin"}).then(function(D){if(!D.ok)throw"failed to load wasm binary file at '"+Xt+"'";return D.arrayBuffer()}).catch(function(){return Xp(Xt)});if(C)return new Promise(function(D,q){C(Xt,function(le){D(new Uint8Array(le))},q)})}return Promise.resolve().then(function(){return Xp(Xt)})}function Jp(){var D={env:Yx,wasi_snapshot_preview1:Yx};function q(fe,ke){var gt=fe.exports;if(u.asm=gt,Jr(u.asm._emscripten_tls_init),$e=u.asm.__indirect_function_table,Dn(u.asm.__wasm_call_ctors),X=ke,!x){var Xn=ce.unusedWorkers.length;ce.unusedWorkers.forEach(function(Yr){ce.loadWasmModuleToWorker(Yr,function(){--Xn||ru()})})}}x||ga();function le(fe){q(fe.instance,fe.module)}function Ne(fe){return Zp().then(function(ke){return WebAssembly.instantiate(ke,D)}).then(function(ke){return ke}).then(fe,function(ke){U("failed to asynchronously prepare wasm: "+ke),Xr(ke)})}function Ae(){return!G&&typeof WebAssembly.instantiateStreaming=="function"&&!Ar(Xt)&&!ya(Xt)&&!b&&typeof fetch=="function"?fetch(Xt,{credentials:"same-origin"}).then(function(fe){var ke=WebAssembly.instantiateStreaming(fe,D);return ke.then(le,function(gt){return U("wasm streaming compile failed: "+gt),U("falling back to ArrayBuffer instantiation"),Ne(le)})}):Ne(le)}if(u.instantiateWasm)try{var Oe=u.instantiateWasm(D,q);return Oe}catch(fe){U("Module.instantiateWasm callback failed with error: "+fe),d(fe)}return Ae().catch(d),{}}var Yp={};function Zr(D){this.name="ExitStatus",this.message="Program terminated with exit("+D+")",this.status=D}function Ji(D){var q=ce.pthreads[D];delete ce.pthreads[D],q.terminate(),cf(D),ce.runningWorkers.splice(ce.runningWorkers.indexOf(q),1),q.pthread_ptr=0}function Qp(D){var q=ce.pthreads[D];q.postMessage({cmd:"cancel"})}function ss(D){var q=ce.pthreads[D];re(q),ce.returnWorkerToPool(q)}function is(D){var q=ce.getNewWorker();if(!q)return 6;ce.runningWorkers.push(q),ce.pthreads[D.pthread_ptr]=q,q.pthread_ptr=D.pthread_ptr;var le={cmd:"run",start_routine:D.startRoutine,arg:D.arg,pthread_ptr:D.pthread_ptr};return q.runPthread=()=>{b&&q.ref(),q.postMessage(le,D.transferList),delete q.runPthread},q.loaded&&q.runPthread(),0}function eh(D){if(x)return Yi(1,1,D);Z=D,kt()||(ce.terminateAllThreads(),u.onExit&&u.onExit(D),ee=!0),m(D,new Zr(D))}function Q(D,q){if(Z=D,!q&&x)throw We(D),"unwind";eh(D)}var oe=Q;function Se(D){if(D instanceof Zr||D=="unwind")return Z;m(1,D)}var ce={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?ce.initWorker():ce.initMainThread()},initMainThread:function(){for(var D=8;D--;)ce.allocateUnusedWorker()},initWorker:function(){K=!1},setExitStatus:function(D){Z=D},terminateAllThreads:function(){for(var D of Object.values(ce.pthreads))ce.returnWorkerToPool(D);for(var D of ce.unusedWorkers)D.terminate();ce.unusedWorkers=[]},returnWorkerToPool:function(D){var q=D.pthread_ptr;delete ce.pthreads[q],ce.unusedWorkers.push(D),ce.runningWorkers.splice(ce.runningWorkers.indexOf(D),1),D.pthread_ptr=0,b&&D.unref(),cf(q)},receiveObjectTransfer:function(D){},threadInitTLS:function(){ce.tlsInitFunctions.forEach(D=>D())},loadWasmModuleToWorker:function(D,q){D.onmessage=Oe=>{var fe=Oe.data,ke=fe.cmd;if(D.pthread_ptr&&(ce.currentProxiedOperationCallerThread=D.pthread_ptr),fe.targetThread&&fe.targetThread!=ah()){var gt=ce.pthreads[fe.targetThread];gt?gt.postMessage(fe,fe.transferList):U('Internal error! Worker sent a message "'+ke+'" to target pthread '+fe.targetThread+", but that thread no longer exists!"),ce.currentProxiedOperationCallerThread=void 0;return}ke==="processProxyingQueue"?pf(fe.queue):ke==="spawnThread"?is(fe):ke==="cleanupThread"?ss(fe.thread):ke==="killThread"?Ji(fe.thread):ke==="cancelThread"?Qp(fe.thread):ke==="loaded"?(D.loaded=!0,b&&D.unref(),q&&q(D),D.runPthread&&D.runPthread()):ke==="print"?B("Thread "+fe.threadId+": "+fe.text):ke==="printErr"?U("Thread "+fe.threadId+": "+fe.text):ke==="alert"?alert("Thread "+fe.threadId+": "+fe.text):fe.target==="setimmediate"?D.postMessage(fe):ke==="callHandler"?u[fe.handler](...fe.args):ke&&U("worker sent an unknown command "+ke),ce.currentProxiedOperationCallerThread=void 0},D.onerror=Oe=>{var fe="worker sent an error!";throw U(fe+" "+Oe.filename+":"+Oe.lineno+": "+Oe.message),Oe},b&&(D.on("message",function(Oe){D.onmessage({data:Oe})}),D.on("error",function(Oe){D.onerror(Oe)}),D.on("detachedExit",function(){}));var le=[],Ne=["onExit","onAbort","print","printErr"];for(var Ae of Ne)u.hasOwnProperty(Ae)&&le.push(Ae);D.postMessage({cmd:"load",handlers:le,urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:H,wasmModule:X})},allocateUnusedWorker:function(){var D,q=I("tfjs-backend-wasm-threaded-simd.worker.js");D=new Worker(q),ce.unusedWorkers.push(D)},getNewWorker:function(){return ce.unusedWorkers.length==0&&(ce.allocateUnusedWorker(),ce.loadWasmModuleToWorker(ce.unusedWorkers[0])),ce.unusedWorkers.pop()}};u.PThread=ce;function it(D){for(;D.length>0;)D.shift()(u)}function ct(){var D=ah(),q=o()[D+52>>2],le=o()[D+56>>2],Ne=q-le;rw(q,Ne),sh(q)}u.establishStackSpace=ct;function We(D){if(x)return Yi(2,0,D);try{oe(D)}catch(q){Se(q)}}var Me=[];function Tt(D){var q=Me[D];return q||(D>=Me.length&&(Me.length=D+1),Me[D]=q=$e.get(D)),q}function Kn(D,q){var le=Tt(D)(q);kt()?ce.setExitStatus(le):nw(le)}u.invokeEntryPoint=Kn;function Jr(D){ce.tlsInitFunctions.push(D)}function th(D){Qx(D,!y,1,!g),ce.threadInitTLS()}function su(D){x?postMessage({cmd:"cleanupThread",thread:D}):ss(D)}function nh(D,q,le,Ne){return x?Yi(3,1,D,q,le,Ne):on(D,q,le,Ne)}function on(D,q,le,Ne){if(typeof SharedArrayBuffer>"u")return U("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ae=[],Oe=0;if(x&&(Ae.length===0||Oe))return nh(D,q,le,Ne);var fe={startRoutine:le,pthread_ptr:D,arg:Ne,transferList:Ae};return x?(fe.cmd="spawnThread",postMessage(fe,Ae),0):is(fe)}function ba(){return 65536}var rh=!0;function AC(){return rh}function pf(D){Atomics.store(o(),D>>2,1),ah()&&tw(D),Atomics.compareExchange(o(),D>>2,1,0)}u.executeNotifiedProxyingQueue=pf;function RC(D,q,le,Ne){if(D==q)setTimeout(()=>pf(Ne));else if(x)postMessage({targetThread:D,cmd:"processProxyingQueue",queue:Ne});else{var Ae=ce.pthreads[D];if(!Ae)return;Ae.postMessage({cmd:"processProxyingQueue",queue:Ne})}return 1}function FC(D,q,le){return-1}function DC(){Xr("")}function iu(D){iu.shown||(iu.shown={}),iu.shown[D]||(iu.shown[D]=1,b&&(D="warning: "+D),U(D))}function MC(){b||y||iu("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function OC(){return Date.now()}function qx(){return 2147483648}function LC(){return qx()}var hf;b?hf=()=>{var D=process.hrtime();return D[0]*1e3+D[1]/1e6}:hf=()=>performance.timeOrigin+performance.now();function zC(D,q,le){i().copyWithin(D,q,q+le)}function PC(){return b?v_().cpus().length:navigator.hardwareConcurrency}function BC(D){var q=ff(),le=D();return sh(q),le}function Yi(D,q){var le=arguments.length-2,Ne=arguments;return BC(()=>{for(var Ae=le,Oe=ih(Ae*8),fe=Oe>>3,ke=0;ke<le;ke++){var gt=Ne[2+ke];p()[fe+ke]=gt}return ew(D,Ae,Oe,q)})}var df=[];function WC(D,q,le){df.length=q;for(var Ne=le>>3,Ae=0;Ae<q;Ae++)df[Ae]=p()[Ne+Ae];var Oe=D<0,fe=Oe?Yp[-D-1]:ZC[D];return fe.apply(null,df)}function VC(D){try{return H.grow(D-pe.byteLength+65535>>>16),Ge(H.buffer),1}catch{}}function UC(D){var q=i().length;if(D=D>>>0,D<=q)return!1;var le=qx();if(D>le)return!1;let Ne=(gt,Xn)=>gt+(Xn-gt%Xn)%Xn;for(var Ae=1;Ae<=4;Ae*=2){var Oe=q*(1+.2/Ae);Oe=Math.min(Oe,D+100663296);var fe=Math.min(le,Ne(Math.max(D,Oe),65536)),ke=VC(fe);if(ke)return!0}return!1}function GC(){throw"unwind"}function Kx(D){return x?Yi(4,1,D):52}function Xx(D,q,le,Ne,Ae){return x?Yi(5,1,D,q,le,Ne,Ae):70}var HC=[null,[],[]];function jC(D,q){var le=HC[D];q===0||q===10?((D===1?B:U)(ae(le,0)),le.length=0):le.push(q)}function Zx(D,q,le,Ne){if(x)return Yi(6,1,D,q,le,Ne);for(var Ae=0,Oe=0;Oe<le;Oe++){var fe=l()[q>>2],ke=l()[q+4>>2];q+=8;for(var gt=0;gt<ke;gt++)jC(D,i()[fe+gt]);Ae+=ke}return l()[Ne>>2]=Ae,0}function Jx(D){var q=u["_"+D];return q}function qC(D,q){s().set(D,q)}function KC(D,q,le,Ne,Ae){var Oe={string:Zn=>{var Qi=0;if(Zn!=null&&Zn!==0){var iw=(Zn.length<<2)+1;Qi=ih(iw),be(Zn,Qi,iw)}return Qi},array:Zn=>{var Qi=ih(Zn.length);return qC(Zn,Qi),Qi}};function fe(Zn){return q==="string"?ie(Zn):q==="boolean"?Boolean(Zn):Zn}var ke=Jx(D),gt=[],Xn=0;if(Ne)for(var Yr=0;Yr<Ne.length;Yr++){var sw=Oe[le[Yr]];sw?(Xn===0&&(Xn=ff()),gt[Yr]=sw(Ne[Yr])):gt[Yr]=Ne[Yr]}var mf=ke.apply(null,gt);function YC(Zn){return Xn!==0&&sh(Xn),fe(Zn)}return mf=YC(mf),mf}function XC(D,q,le,Ne){le=le||[];var Ae=le.every(fe=>fe==="number"||fe==="boolean"),Oe=q!=="string";return Oe&&Ae&&!Ne?Jx(D):function(){return KC(D,q,le,arguments)}}ce.init();var ZC=[null,eh,We,nh,Kx,Xx,Zx],Yx={__emscripten_init_main_thread_js:th,__emscripten_thread_cleanup:su,__pthread_create_js:on,_emscripten_default_pthread_stack_size:ba,_emscripten_get_now_is_monotonic:AC,_emscripten_notify_task_queue:RC,_emscripten_set_offscreencanvas_size:FC,abort:DC,emscripten_check_blocking_allowed:MC,emscripten_date_now:OC,emscripten_get_heap_max:LC,emscripten_get_now:hf,emscripten_memcpy_big:zC,emscripten_num_logical_cores:PC,emscripten_receive_on_main_thread_js:WC,emscripten_resize_heap:UC,emscripten_unwind_to_js_event_loop:GC,exit:oe,fd_close:Kx,fd_seek:Xx,fd_write:Zx,memory:H||u.wasmMemory};Jp(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var ah=u._pthread_self=function(){return(ah=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var Qx=u.__emscripten_thread_init=function(){return(Qx=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var ew=u._emscripten_run_in_main_runtime_thread_js=function(){return(ew=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var tw=u.__emscripten_proxy_execute_task_queue=function(){return(tw=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},cf=u.__emscripten_thread_free_data=function(){return(cf=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},nw=u.__emscripten_thread_exit=function(){return(nw=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},rw=u._emscripten_stack_set_limits=function(){return(rw=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},ff=u.stackSave=function(){return(ff=u.stackSave=u.asm.stackSave).apply(null,arguments)},sh=u.stackRestore=function(){return(sh=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},ih=u.stackAlloc=function(){return(ih=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=kt,u.wasmMemory=H,u.cwrap=XC,u.ExitStatus=Zr,u.PThread=ce;var oh;qn=function D(){oh||aw(),oh||(qn=D)};function aw(D){if(Kt>0)return;if(x){h(u),qt(),startWorker(u);return}if(In(),Kt>0)return;function q(){oh||(oh=!0,u.calledRun=!0,!ee&&(qt(),h(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),Sn()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),q()},1)):q()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();aw();var lh;c&&(lh={uncaughtException:process.listeners("uncaughtException").filter(function(D){return!c.uncaughtException.indexOf(D)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(D){return!c.unhandledRejection.indexOf(D)>-1})});var uh;if(typeof WasmBackendModule<"u")uh=WasmBackendModule;else if(typeof a<"u")uh=a;else throw new Error("Could not find wasm module in post.js");if(lh){var JC=uh._dispose;uh._dispose=function(){JC(),lh.uncaughtException.forEach(function(D){process.removeListener("uncaughtException",D)}),lh.unhandledRejection.forEach(function(D){process.removeListener("unhandledRejection",D)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),I_=$t((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),S_=$t((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};var s=typeof a<"u"?a:{},i,o;s.ready=new Promise(function(Q,oe){i=Q,o=oe});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var p=Object.assign({},s),u=typeof window=="object",h=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",c="";function f(Q){return s.locateFile?s.locateFile(Q,c):c+Q}var m,g,y;if(d){var b=Pm(),x=Gv();h?c=x.dirname(c)+"/":c=__dirname+"/",m=(Q,oe)=>(Q=je(Q)?new URL(Q):x.normalize(Q),b.readFileSync(Q,oe?void 0:"utf8")),y=Q=>{var oe=m(Q,!0);return oe.buffer||(oe=new Uint8Array(oe)),oe},g=(Q,oe,Se)=>{Q=je(Q)?new URL(Q):x.normalize(Q),b.readFile(Q,function(ce,it){ce?Se(ce):oe(it.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Q){if(!(Q instanceof kt))throw Q}),process.on("unhandledRejection",function(Q){throw Q}),s.inspect=function(){return"[Emscripten Module object]"}}else(u||h)&&(h?c=self.location.href:typeof document<"u"&&document.currentScript&&(c=document.currentScript.src),r&&(c=r),c.indexOf("blob:")!==0?c=c.substr(0,c.replace(/[?#].*/,"").lastIndexOf("/")+1):c="",m=Q=>{var oe=new XMLHttpRequest;return oe.open("GET",Q,!1),oe.send(null),oe.responseText},h&&(y=Q=>{var oe=new XMLHttpRequest;return oe.open("GET",Q,!1),oe.responseType="arraybuffer",oe.send(null),new Uint8Array(oe.response)}),g=(Q,oe,Se)=>{var ce=new XMLHttpRequest;ce.open("GET",Q,!0),ce.responseType="arraybuffer",ce.onload=()=>{if(ce.status==200||ce.status==0&&ce.response){oe(ce.response);return}Se()},ce.onerror=Se,ce.send(null)});var v=s.print||console.log.bind(console),I=s.printErr||console.warn.bind(console);Object.assign(s,p),p=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var N;s.wasmBinary&&(N=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&Be("no native wasm support detected");var C,E=!1,A=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function F(Q,oe,Se){for(var ce=oe+Se,it=oe;Q[it]&&!(it>=ce);)++it;if(it-oe>16&&Q.buffer&&A)return A.decode(Q.subarray(oe,it));for(var ct="";oe<it;){var We=Q[oe++];if(!(We&128)){ct+=String.fromCharCode(We);continue}var Me=Q[oe++]&63;if((We&224)==192){ct+=String.fromCharCode((We&31)<<6|Me);continue}var Tt=Q[oe++]&63;if((We&240)==224?We=(We&15)<<12|Me<<6|Tt:We=(We&7)<<18|Me<<12|Tt<<6|Q[oe++]&63,We<65536)ct+=String.fromCharCode(We);else{var Kn=We-65536;ct+=String.fromCharCode(55296|Kn>>10,56320|Kn&1023)}}return ct}function R(Q,oe){return Q?F(G,Q,oe):""}function S(Q,oe,Se,ce){if(!(ce>0))return 0;for(var it=Se,ct=Se+ce-1,We=0;We<Q.length;++We){var Me=Q.charCodeAt(We);if(Me>=55296&&Me<=57343){var Tt=Q.charCodeAt(++We);Me=65536+((Me&1023)<<10)|Tt&1023}if(Me<=127){if(Se>=ct)break;oe[Se++]=Me}else if(Me<=2047){if(Se+1>=ct)break;oe[Se++]=192|Me>>6,oe[Se++]=128|Me&63}else if(Me<=65535){if(Se+2>=ct)break;oe[Se++]=224|Me>>12,oe[Se++]=128|Me>>6&63,oe[Se++]=128|Me&63}else{if(Se+3>=ct)break;oe[Se++]=240|Me>>18,oe[Se++]=128|Me>>12&63,oe[Se++]=128|Me>>6&63,oe[Se++]=128|Me&63}}return oe[Se]=0,Se-it}function M(Q,oe,Se){return S(Q,G,oe,Se)}var B,U,G,K;function H(Q){B=Q,s.HEAP8=U=new Int8Array(Q),s.HEAP16=new Int16Array(Q),s.HEAP32=new Int32Array(Q),s.HEAPU8=G=new Uint8Array(Q),s.HEAPU16=new Uint16Array(Q),s.HEAPU32=K=new Uint32Array(Q),s.HEAPF32=new Float32Array(Q),s.HEAPF64=new Float64Array(Q)}s.INITIAL_MEMORY;var X=[],ee=[],Z=[];function re(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)ie(s.preRun.shift());In(X)}function te(){In(ee)}function ae(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)be(s.postRun.shift());In(Z)}function ie(Q){X.unshift(Q)}function we(Q){ee.unshift(Q)}function be(Q){Z.unshift(Q)}var pe=0,Ie=null;function Te(Q){pe++,s.monitorRunDependencies&&s.monitorRunDependencies(pe)}function De(Q){if(pe--,s.monitorRunDependencies&&s.monitorRunDependencies(pe),pe==0&&Ie){var oe=Ie;Ie=null,oe()}}function Be(Q){s.onAbort&&s.onAbort(Q),Q="Aborted("+Q+")",I(Q),E=!0,Q+=". Build with -sASSERTIONS for more info.";var oe=new WebAssembly.RuntimeError(Q);throw o(oe),oe}var et="data:application/octet-stream;base64,";function Ge(Q){return Q.startsWith(et)}function je(Q){return Q.startsWith("file://")}var $e;$e="tfjs-backend-wasm.wasm",Ge($e)||($e=f($e));function Ze(Q){try{if(Q==$e&&N)return new Uint8Array(N);if(y)return y(Q);throw"both async and sync fetching of the wasm failed"}catch(oe){Be(oe)}}function st(){if(!N&&(u||h)){if(typeof fetch=="function"&&!je($e))return fetch($e,{credentials:"same-origin"}).then(function(Q){if(!Q.ok)throw"failed to load wasm binary file at '"+$e+"'";return Q.arrayBuffer()}).catch(function(){return Ze($e)});if(g)return new Promise(function(Q,oe){g($e,function(Se){Q(new Uint8Array(Se))},oe)})}return Promise.resolve().then(function(){return Ze($e)})}function Fn(){var Q={env:Zp,wasi_snapshot_preview1:Zp};function oe(We,Me){var Tt=We.exports;s.asm=Tt,C=s.asm.memory,H(C.buffer),s.asm.__indirect_function_table,we(s.asm.__wasm_call_ctors),De()}Te();function Se(We){oe(We.instance)}function ce(We){return st().then(function(Me){return WebAssembly.instantiate(Me,Q)}).then(function(Me){return Me}).then(We,function(Me){I("failed to asynchronously prepare wasm: "+Me),Be(Me)})}function it(){return!N&&typeof WebAssembly.instantiateStreaming=="function"&&!Ge($e)&&!je($e)&&!d&&typeof fetch=="function"?fetch($e,{credentials:"same-origin"}).then(function(We){var Me=WebAssembly.instantiateStreaming(We,Q);return Me.then(Se,function(Tt){return I("wasm streaming compile failed: "+Tt),I("falling back to ArrayBuffer instantiation"),ce(Se)})}):ce(Se)}if(s.instantiateWasm)try{var ct=s.instantiateWasm(Q,oe);return ct}catch(We){I("Module.instantiateWasm callback failed with error: "+We),o(We)}return it().catch(o),{}}function kt(Q){this.name="ExitStatus",this.message="Program terminated with exit("+Q+")",this.status=Q}function In(Q){for(;Q.length>0;)Q.shift()(s)}function qt(){Be("")}function Sn(){return 2147483648}function sr(){return Sn()}function Dn(Q,oe,Se){G.copyWithin(Q,oe,oe+Se)}function Nn(Q){try{return C.grow(Q-B.byteLength+65535>>>16),H(C.buffer),1}catch{}}function Kt(Q){var oe=G.length;Q=Q>>>0;var Se=Sn();if(Q>Se)return!1;let ce=(Tt,Kn)=>Tt+(Kn-Tt%Kn)%Kn;for(var it=1;it<=4;it*=2){var ct=oe*(1+.2/it);ct=Math.min(ct,Q+100663296);var We=Math.min(Se,ce(Math.max(Q,ct),65536)),Me=Nn(We);if(Me)return!0}return!1}function qn(Q){return 52}function ga(Q,oe,Se,ce,it){return 70}var ru=[null,[],[]];function Xr(Q,oe){var Se=ru[Q];oe===0||oe===10?((Q===1?v:I)(F(Se,0)),Se.length=0):Se.push(oe)}function au(Q,oe,Se,ce){for(var it=0,ct=0;ct<Se;ct++){var We=K[oe>>2],Me=K[oe+4>>2];oe+=8;for(var Tt=0;Tt<Me;Tt++)Xr(Q,G[We+Tt]);it+=Me}return K[ce>>2]=it,0}function Ar(Q){var oe=s["_"+Q];return oe}function ya(Q,oe){U.set(Q,oe)}function Xt(Q,oe,Se,ce,it){var ct={string:on=>{var ba=0;if(on!=null&&on!==0){var rh=(on.length<<2)+1;ba=Zr(rh),M(on,ba,rh)}return ba},array:on=>{var ba=Zr(on.length);return ya(on,ba),ba}};function We(on){return oe==="string"?R(on):oe==="boolean"?Boolean(on):on}var Me=Ar(Q),Tt=[],Kn=0;if(ce)for(var Jr=0;Jr<ce.length;Jr++){var th=ct[Se[Jr]];th?(Kn===0&&(Kn=Jp()),Tt[Jr]=th(ce[Jr])):Tt[Jr]=ce[Jr]}var su=Me.apply(null,Tt);function nh(on){return Kn!==0&&Yp(Kn),We(on)}return su=nh(su),su}function Xp(Q,oe,Se,ce){Se=Se||[];var it=Se.every(We=>We==="number"||We==="boolean"),ct=oe!=="string";return ct&&it&&!ce?Ar(Q):function(){return Xt(Q,oe,Se,arguments)}}var Zp={abort:qt,emscripten_get_heap_max:sr,emscripten_memcpy_big:Dn,emscripten_resize_heap:Kt,fd_close:qn,fd_seek:ga,fd_write:au};Fn(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Jp=s.stackSave=function(){return(Jp=s.stackSave=s.asm.stackSave).apply(null,arguments)},Yp=s.stackRestore=function(){return(Yp=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Zr=s.stackAlloc=function(){return(Zr=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Xp;var Ji;Ie=function Q(){Ji||Qp(),Ji||(Ie=Q)};function Qp(Q){if(pe>0||(re(),pe>0))return;function oe(){Ji||(Ji=!0,s.calledRun=!0,!E&&(te(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),ae()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),oe()},1)):oe()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();Qp();var ss;l&&(ss={uncaughtException:process.listeners("uncaughtException").filter(function(Q){return!l.uncaughtException.indexOf(Q)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Q){return!l.unhandledRejection.indexOf(Q)>-1})});var is;if(typeof a<"u")is=a;else if(typeof WasmBackendModuleThreadedSimd<"u")is=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(ss){var eh=is._dispose;is._dispose=function(){eh(),ss.uncaughtException.forEach(function(Q){process.removeListener("uncaughtException",Q)}),ss.unhandledRejection.forEach(function(Q){process.removeListener("unhandledRejection",Q)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),bd=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Hu=class{refCount(e){return Mn("refCount")}incRef(e){return Mn("incRef")}timerAvailable(){return!0}time(e){return Mn("time")}read(e){return Mn("read")}readSync(e){return Mn("readSync")}readToGPU(e,t){return Mn("readToGPU")}numDataIds(){return Mn("numDataIds")}disposeData(e,t){return Mn("disposeData")}write(e,t,n){return Mn("write")}move(e,t,n,r,a){return Mn("move")}createTensorFromGPUData(e,t,n){return Mn("createTensorFromGPUData")}memory(){return Mn("memory")}floatPrecision(){return Mn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Mn("dispose")}};function Mn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Hv(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Mh(e,t,n)}function N_(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Mh(e,n,r),Mh(t,n,r)}function Cu(e,t,n){return Math.max(e,Math.min(t,n))}function T_(e){return e%2===0?e:e+1}function Mh(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function C_(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function __(e,t){let n=Math.random();return t*n+(1-n)*e}function E_(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function $(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function bn(e,t,n=""){$(Ga(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Bs(e){$(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function lt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $_(e){return e.length===0}function Ga(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function po(e){return e%1===0}function A_(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function R_(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function F_(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Hv(t),t}function ku(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function D_(e,t=a=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e()){a();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function M_(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function mr(e,t){let n=t.length;return e=e==null?t.map((r,a)=>a):[].concat(e),$(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),$(e.every(r=>po(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function jv(e,t){let n=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:mr(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function qv(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Kv(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function Xv(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Zv(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function O_(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Oh(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function Jv(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Na(e){return typeof e=="string"||e instanceof String}function Yv(e){return typeof e=="boolean"}function Qv(e){return typeof e=="number"}function xd(e){return Array.isArray(e)?xd(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Qv(e)?"float32":Na(e)?"string":Yv(e)?"bool":"float32"}function Ra(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Lh(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function $o(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function e0(e,t,n,r=!1){let a=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)a[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,p)=>l*p)*(r?2:1);for(let l=0;l<s;l++)a[l]=e0(e+l*o,i,n,r)}return a}function io(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((a,s)=>a*s)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return e0(0,e,t,n)}function L_(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Bm(e,t){let n=wd(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function wd(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function z_(e,t){let n=e.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return io(e,new Float32Array(n));if(t==="int32")return io(e,new Int32Array(n));if(t==="bool")return io(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function jn(e){e.forEach(t=>{$(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function P_(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function B_(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function vd(e){return e&&e.then&&typeof e.then=="function"}var ow="tfjsflags",t0=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=W_,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(vd(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);ow in e&&e[ow].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=U_(n,r)})}};function W_(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(V_(t,r[0],r[1]),r.join("="))),t}function V_(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function U_(e,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function j(){return Wm}var Wm=null;function G_(e){Wm=e}var gf;function n0(){if(gf==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");gf=e}return gf}function H_(){let e=n0();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Vm(e,t){let n=H_();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Ao="Abs",Ro="Acos",Fo="Acosh",Ha="Add",Ws="AddN",Do="All",Mo="Any",Vs="ArgMax",ju="ArgMin",Oo="Asin",Lo="Asinh",zo="Atan",Po="Atanh",Bo="Atan2",Us="AvgPool",kd="AvgPoolGrad",qu="AvgPool3D",Id="AvgPool3DGrad",Gs="BatchMatMul",Wo="BatchToSpaceND",Sd="Bincount",r0="BroadcastTo",Nd="BroadcastArgs",Hs="Cast",js="Ceil",ja="ClipByValue",Td="Complex",Ku="ComplexAbs",Vo="Concat",qs="Conv2D",Cd="Conv2DBackpropFilter",Ks="Conv2DBackpropInput",Xu="Conv3D",_d="Conv3DBackpropFilterV2",Ed="Conv3DBackpropInputV2",Xs="Cos",Zs="Cosh",Uo="Cumprod",Js="Cumsum",Go="CropAndResize",$d="DenseBincount",Ho="DepthToSpace",Ys="DepthwiseConv2dNative",Ad="DepthwiseConv2dNativeBackpropFilter",Rd="DepthwiseConv2dNativeBackpropInput",Fd="Diag",Zu="Dilation2D",zh="Dilation2DBackpropInput",Ph="Dilation2DBackpropFilter",Qs="RealDiv",Dd="Einsum",ei="Elu",Md="EluGrad",jo="Erf",qo="Equal",ti="Exp",Ko="ExpandDims",Xo="Expm1",Od="FFT",Ju="Fill",Zo="FlipLeftRight",ni="Floor",ri="FloorDiv",ai="FusedBatchNorm",Jo="GatherV2",Yo="GatherNd",Qo="Greater",si="GreaterEqual",ii="Identity",Ld="IFFT",zd="Imag",el="IsFinite",tl="IsInf",oi="IsNan",li="LeakyRelu",nl="Less",rl="LessEqual",Pd="LinSpace",ui="Log",al="Log1p",sl="LogicalAnd",il="LogicalNot",ol="LogicalOr",a0="LogicalXor",s0="LogSoftmax",j_="LowerBound",Yu="LRN",Bd="LRNGrad",pi="Max",hi="Maximum",di="MaxPool",Wd="MaxPoolGrad",Qu="MaxPool3D",Vd="MaxPool3DGrad",Ud="MaxPoolWithArgmax",ci="Mean",fi="Min",mi="Minimum",gi="MirrorPad",ll="Mod",Gd="Multinomial",yi="Multiply",ul="Neg",pl="NotEqual",hl="NonMaxSuppressionV3",dl="NonMaxSuppressionV4",cl="NonMaxSuppressionV5",fl="OnesLike",bi="OneHot",ml="Pack",xi="PadV2",q_="Pool",wi="Pow",vi="Prelu",ki="Prod",Hd="RaggedGather",jd="RaggedRange",qd="RaggedTensorToTensor",ep="Range",Kd="Real",Ii="Reciprocal",Si="Relu",gl="Reshape",Ni="ResizeNearestNeighbor",Xd="ResizeNearestNeighborGrad",Ti="ResizeBilinear",Zd="ResizeBilinearGrad",Ci="Relu6",_i="Reverse",Ei="Round",$i="Rsqrt",yl="ScatterNd",Jd="SearchSorted",bl="Select",xl="Selu",wl="Slice",Ai="Sin",vl="Sinh",kl="Sign",Ri="Sigmoid",Il="Softplus",Fi="Sqrt",Di="Sum",Sl="SpaceToBatchND",Nl="SplitV",Mi="Softmax",tp="SparseFillEmptyRows",Tl="SparseReshape",np="SparseSegmentMean",rp="SparseSegmentSum",Yd="SparseToDense",Oi="SquaredDifference",ap="Square",Cl="StridedSlice",sp="StringNGrams",ip="StringSplit",op="StringToHashBucketFast",Li="Sub",zi="Tan",Pi="Tanh",qa="Tile",_l="TopK",El="Transform",aa="Transpose",Qd="Unique",$l="Unpack",lp="UnsortedSegmentSum",K_="UpperBound",Al="ZerosLike",Ka="Step",Bh="FromPixels",Rl="RotateWithOffset",ks="_FusedMatMul",Is="FusedConv2D",Ss="FusedDepthwiseConv2D";function Sa(...e){j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(...e)}function X_(...e){j().getBool("IS_TEST")||j().getBool("PROD")||console.log(...e)}var ho=Vm("kernelRegistry",()=>new Map),_u=Vm("gradRegistry",()=>new Map);function Wh(e,t){let n=Um(e,t);return ho.get(n)}function Mf(e){return _u.get(e)}function Vh(e){let t=ho.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function up(e){let{kernelName:t,backendName:n}=e,r=Um(t,n);ho.has(r)&&Sa(`The kernel '${t}' for backend '${n}' is already registered`),ho.set(r,e)}function i0(e){let{kernelName:t}=e;_u.has(t)&&j().getBool("DEBUG")&&Sa(`Overriding the gradient for '${t}'`),_u.set(t,e)}function Z_(e,t){let n=Um(e,t);if(!ho.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);ho.delete(n)}function J_(e){if(!_u.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);_u.delete(e)}function Y_(e,t){Vh(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});up(r)})}function Um(e,t){return`${t}_${e}`}var w={};Ee(w,{arraysEqual:()=>Ga,assert:()=>$,assertNonNegativeIntegerDimensions:()=>jn,assertNonNull:()=>Bs,assertShapesMatch:()=>bn,bytesFromStringArray:()=>Jv,bytesPerElement:()=>Oh,checkConversionForErrors:()=>Xv,clamp:()=>Cu,computeStrides:()=>$o,convertBackendValuesAndArrayBuffer:()=>L_,createScalarValue:()=>aE,createShuffledIndices:()=>F_,decodeString:()=>Uh,distSquared:()=>E_,encodeString:()=>hp,fetch:()=>iE,fingerPrint64:()=>rE,flatten:()=>Fa,getArrayFromDType:()=>Kv,getTypedArrayFromDType:()=>qv,hasEncodingLoss:()=>O_,hexToLong:()=>pp,indexToLoc:()=>B_,inferDtype:()=>xd,inferFromImplicitShape:()=>M_,isBoolean:()=>Yv,isFunction:()=>Ra,isInt:()=>po,isNumber:()=>Qv,isPromise:()=>vd,isScalarShape:()=>$_,isString:()=>Na,isTypedArray:()=>Zt,isValidDtype:()=>Zv,locToIndex:()=>P_,makeOnesTypedArray:()=>Bm,makeZerosNestedTypedArray:()=>z_,makeZerosTypedArray:()=>wd,nearestDivisor:()=>Lh,nearestLargerEven:()=>T_,now:()=>Eu,parseAxisParam:()=>mr,randUniform:()=>__,repeatedTry:()=>D_,rightPad:()=>ku,shuffle:()=>Hv,shuffleCombo:()=>N_,sizeFromShape:()=>lt,sizeToSquarishShape:()=>R_,squeezeShape:()=>jv,sum:()=>C_,swap:()=>Mh,tanh:()=>A_,toNestedArray:()=>io,toTypedArray:()=>ec});var lw=Ua(l_()),hs=lw.default||lw;function pp(e){return hs.fromString(e,!0,16)}var o0=pp("c3a5c85c97cb3127"),us=pp("b492b66fbe98f273"),ln=pp("9ae16a3b2f90404f");function Of(e){return e.xor(e.shru(47))}function l0(e,t,n){let r=e.slice(t,t+n);return hs.fromBytes(Array.from(r),!0,!0)}function ot(e,t){return l0(e,t,8)}function uw(e,t){return l0(e,t,4)}function Vt(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ea(e,t,n=pp("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Q_(e,t,n,r,a,s){a=a.add(e),s=Vt(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(Vt(a,44)),[a.add(r),s.add(i)]}function ph(e,t,n,r){return Q_(ot(e,t),ot(e,t+8),ot(e,t+16),ot(e,t+24),n,r)}function eE(e,t=e.length){if(t>=8){let n=ln.add(t*2),r=ot(e,0).add(ln),a=ot(e,t-8),s=Vt(a,37).mul(n).add(r),i=Vt(r,25).add(a).mul(n);return Ea(s,i,n)}if(t>=4){let n=ln.add(t*2),r=uw(e,0);return Ea(r.shl(3).add(t),uw(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return Of(ln.mul(s).xor(o0.mul(i))).mul(ln)}return ln}function tE(e,t=e.length){let n=ln.add(t*2),r=ot(e,0).mul(us),a=ot(e,8),s=ot(e,t-8).mul(n),i=ot(e,t-16).mul(ln);return Ea(Vt(r.add(a),43).add(Vt(s,30)).add(i),r.add(Vt(a.add(ln),18)).add(s),n)}function nE(e,t=e.length){let n=ln.add(t*2),r=ot(e,0).mul(ln),a=ot(e,8),s=ot(e,t-8).mul(n),i=ot(e,t-16).mul(ln),o=Vt(r.add(a),43).add(Vt(s,30)).add(i),l=Ea(o,r.add(Vt(a.add(ln),18)).add(s),n),p=ot(e,16).mul(n),u=ot(e,24),h=o.add(ot(e,t-32)).mul(n),d=l.add(ot(e,t-24)).mul(n);return Ea(Vt(p.add(u),43).add(Vt(h,30)).add(d),p.add(Vt(u.add(r),18)).add(h),n)}function rE(e,t=e.length){let n=hs.fromNumber(81,!0);if(t<=32)return t<=16?eE(e,t):tE(e,t);if(t<=64)return nE(e,t);let r=n,a=n.mul(us).add(113),s=Of(a.mul(ln).add(113)).mul(ln),i=[hs.UZERO,hs.UZERO],o=[hs.UZERO,hs.UZERO];r=r.mul(ln).add(ot(e,0));let l=0,p=(t-1>>6)*64,u=p+(t-1&63)-63;do r=Vt(r.add(a).add(i[0]).add(ot(e,l+8)),37).mul(us),a=Vt(a.add(i[1]).add(ot(e,l+48)),42).mul(us),r=r.xor(o[1]),a=a.add(i[0]).add(ot(e,l+40)),s=Vt(s.add(o[0]),33).mul(us),i=ph(e,l,i[1].mul(us),r.add(o[0])),o=ph(e,l+32,s.add(o[1]),a.add(ot(e,l+16))),[s,r]=[r,s],l+=64;while(l!==p);let h=us.add(s.and(255).shl(1));return l=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Vt(r.add(a).add(i[0]).add(ot(e,l+8)),37).mul(h),a=Vt(a.add(i[1]).add(ot(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(ot(e,l+40))),s=Vt(s.add(o[0]),33).mul(h),i=ph(e,l,i[1].mul(h),r.add(o[0])),o=ph(e,l+32,s.add(o[1]),a.add(ot(e,l+16))),[s,r]=[r,s],Ea(Ea(i[0],o[0],h).add(Of(a).mul(o0)).add(s),Ea(i[1],o[1],h).add(r),h)}function aE(e,t){return t==="string"?hp(e):ec([e],t)}function sE(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function ec(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Fa(e)),j().getBool("DEBUG")&&Xv(e,t),sE(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Eu(){return j().platform.now()}function iE(e,t){return j().platform.fetch(e,t)}function hp(e,t="utf-8"){return t=t||"utf-8",j().platform.encode(e,t)}function Uh(e,t="utf-8"){return t=t||"utf-8",j().platform.decode(e,t)}function Zt(e){return j().platform.isTypedArray(e)}function Fa(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||vd(e)||e==null||Zt(e)&&n)t.push(e);else if(Array.isArray(e)||Zt(e))for(let r=0;r<e.length;++r)Fa(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)Fa(e[a],t,n)}return t}var oE=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new uE)}profileKernel(e,t,n){let r,a=()=>{r=n()},s,i=Eu();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:Eu()-i})}if(j().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(p=>{lE(p,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),r,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],a,o[2])})})}};function lE(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var uE=class{logKernelProfile(e,t,n,r,a,s){let i=typeof r=="number"?ku(`${r}ms`,9):r.error,o=ku(e,25),l=t.rank,p=t.size,u=ku(t.shape.toString(),14),h="";for(let d in a){let c=a[d];if(c!=null){let f=c.shape||t.shape,m=f.length;h+=`${d}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${u}	%c${p}	%c${h}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function pE(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let p=e[l],u=p.inputs;for(let h in u){let d=u[h],c=!1;for(let f=0;f<t.length;f++)if(r[d.id]){p.outputs.forEach(m=>r[m.id]=!0),c=!0,a[p.id]=!0;break}if(c)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let p=e[l],u=p.inputs;for(let h=0;h<p.outputs.length;h++)if(s[p.outputs[h].id]){for(let d in u)s[u[d].id]=!0,i[p.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let p=e[l];if(a[p.id]&&i[p.id]){let u={};for(let d in p.inputs){let c=p.inputs[d];r[c.id]&&(u[d]=c)}let h=Object.assign({},p);h.inputs=u,h.outputs=p.outputs,o.push(h)}}return o}function hE(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(l=>{let p=e[l.id];p!=null?i.push(p):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let p=n(()=>o[l]());if(p.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${p.dtype}'`);let u=s.inputs[l];if(!Ga(p.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${p.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=p;else{let h=e[u.id];e[u.id]=r(h,p),h.dispose()}}}}var pw=20,ou=3,yf=7;function dE(e,t,n,r){let a=$o(t),s=cE(e,t,n,a),i=t.length,o=Th(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(p=>"    "+p).join(`
`)),l.join(`
`)}function cE(e,t,n,r){let a=lt(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?cu(e):e;if(o>1)for(let p=0;p<a/s;p++){let u=p*s;for(let h=0;h<s;h++)i[h]=Math.max(i[h],du(l[u+h],0,n).length)}return i}function du(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(yf))} + ${parseFloat(e[1].toFixed(yf))}j`:Na(e)?r=`'${e}'`:n==="bool"?r=u0(e):r=parseFloat(e.toFixed(yf)).toString(),ku(r,t)}function u0(e){return e===0?"false":"true"}function Th(e,t,n,r,a,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=cu(e);return[du(m[0],0,n)]}return n==="bool"?[u0(e[0])]:[e[0].toString()]}if(l===1){if(o>pw){let m=ou*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-ou)*i,o*i));return n==="complex64"&&(g=cu(g),y=cu(y)),["["+g.map((b,x)=>du(b,a[x],n)).join(", ")+", ..., "+y.map((b,x)=>du(b,a[o-ou+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?cu(e):Array.from(e)).map((m,g)=>du(m,a[g],n)).join(", ")+"]"]}let p=t.slice(1),u=r.slice(1),h=r[0]*i,d=[];if(o>pw){for(let m=0;m<ou;m++){let g=m*h,y=g+h;d.push(...Th(e.slice(g,y),p,n,u,a,!1))}d.push("...");for(let m=o-ou;m<o;m++){let g=m*h,y=g+h;d.push(...Th(e.slice(g,y),p,n,u,a,m===o-1))}}else for(let m=0;m<o;m++){let g=m*h,y=g+h;d.push(...Th(e.slice(g,y),p,n,u,a,m===o-1))}let c=l===2?",":"";d[0]="["+(o>0?d[0]+c:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+c;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function cu(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Mt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=lt(e),n!=null){let r=n.length;$(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Kv(t,this.size),this.strides=$o(e)}set(e,...t){t.length===0&&(t=[0]),$(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return xr().makeTensor(this.values,this.shape,this.dtype)}},xr=null,ro=null;function fE(e){xr=e}function mE(e){ro=e}var Pe=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=lt(e),this.strides=$o(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return ro.buffer(this.shape,this.dtype,e)}bufferSync(){return ro.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return io(this.shape,e,this.dtype==="complex64")}arraySync(){return io(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=xr().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Uh(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),xr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=xr().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Uh(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await xr().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(xr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ro.print(this,e)}clone(){return this.throwIfDisposed(),ro.clone(this)}toString(e=!1){let t=this.dataSync();return dE(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ro.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),xr().makeVariable(this,e,t,n)}};Object.defineProperty(Pe,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Y(){return Vm("Tensor",()=>Pe)}Y();var Ns=class extends Pe{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ga(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);xr().disposeTensor(this),this.dataId=e.dataId,xr().incRef(this,null)}dispose(){xr().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ns,Symbol.hasInstance,{value:e=>e instanceof Pe&&e.assign!=null&&e.assign instanceof Function});var Ir={};Ee(Ir,{assertTypesMatch:()=>p0,getTensorsInContainer:()=>Gm,isTensorInList:()=>yE,makeTypesMatch:()=>wt});var Lf;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(Lf||(Lf={}));var zf;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(zf||(zf={}));var Pf;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Pf||(Pf={}));var Bf;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(Bf||(Bf={}));var Wf;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Wf||(Wf={}));var gE={float32:Bf,int32:zf,bool:Pf,complex64:Wf};function tr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return gE[e][t]}function tc(e){return tr(e,"int32")}function wt(e,t){if(e.dtype===t.dtype)return[e,t];let n=tr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function p0(e,t){$(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function yE(e,t){return t.some(n=>n.id===e.id)}function Gm(e){let t=[];return h0(e,t,new Set),t}function h0(e,t,n){if(e==null)return;if(e instanceof Pe){t.push(e);return}if(!bE(e))return;let r=e;for(let a in r){let s=r[a];n.has(s)||(n.add(s),h0(s,t,n))}}function bE(e){return Array.isArray(e)||typeof e=="object"}function bf(e){return e.kernelName!=null}var hw=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},$u=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new hw}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Sa(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new oE(this.backendInstance),!0}setupRegisteredKernels(){Vh(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Vh(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof Hu)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,a=n.then(s=>r<this.pendingBackendInitId?!1:(this.registry[e]=s,this.pendingBackendInit=null,!0)).catch(s=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Sa(`Initialization of backend ${e} failed`),Sa(s.stack||s.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return Sa(`Initialization of backend ${e} failed`),Sa(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{let r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return $u.nextTensorId++}nextVariableId(){return $u.nextVariableId++}clone(e){let t=O.runKernel(ii,{x:e}),n={x:e},r=s=>({x:()=>{let i="float32",o={x:s},l={dtype:i};return O.runKernel(Hs,o,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,Wh(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach(o=>{a+=o.dtype==="complex64"?3:1});let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let o,l=bf(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(bf(e)){let{kernelName:c,inputs:f,attrs:m}=e;this.backendName==null&&this.backend;let g=Wh(c,this.backendName);$(g!=null,()=>`Cannot find registered kernel '${c}' for backend '${this.backendName}'`),i=()=>{let y=this.backend.numDataIds();o=g.kernelFunc({inputs:f,attrs:m,backend:this.backend});let b=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,b);let x=b.map(v=>v.rank!=null?v:this.makeTensorFromTensorInfo(v));if(r){let v=this.getTensorsForGradient(c,f,x);n=this.saveTensorsForBackwardMode(v)}return x}}else{let{forwardFunc:c}=e,f=m=>{r&&(n=m.map(g=>this.keep(this.clone(g))))};i=()=>{let m=this.backend.numDataIds();o=this.tidy(()=>c(this.backend,f));let g=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,m,g),g}}let{inputs:p,attrs:u}=e,h=bf(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(d=this.profiler.profileKernel(l,p,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),r&&this.addTapeNode(l,p,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(c=>p[c]!=null?p[c].shape:null),outputShapes:t.map(c=>c.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,n){let r=Mf(e);if(r!=null){let a=r.inputsToSave||[],s=r.outputsToSave||[],i;r.saveAllInputs?($(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=a.map(l=>t[l]);let o=n.filter((l,p)=>s[p]);return i.concat(o)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;n==="string"&&Na(e[0])&&(a=e.map(o=>hp(o)));let s=r.write(a,t,n),i=new Pe(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),n==="string"){let o=this.state.tensorInfo.get(s),l=Jv(a);this.state.numBytes+=l-o.bytes,o.bytes=l}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";let a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new Pe(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let a=new Ns(e,t,n,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Oh(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Ns||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*Oh(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=Mf(e);o!=null&&(r=o.gradFunc),r!=null&&(i.gradient=l=>(l=l.map((p,u)=>{if(p==null){let h=n[u],d=wd(h.size,h.dtype);return this.makeTensor(d,h.shape,h.dtype)}return p}),r(l.length>1?l:l[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Gm(e),n=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let s=this.state.activeScope.track[a];!s.kept&&!n.has(s.id)&&s.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,t,n,r=!1){if($(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));$(a instanceof Pe,()=>"The result y returned by f() must be a tensor.");let s=pE(this.state.activeTape,t,a);if(!r&&s.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[a.id]=n??xE(a.shape),hE(i,s,l=>this.tidy(l),wE);let o=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:a,grads:o}})}customGrad(e){return $(Ra(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{$(t.every(i=>i instanceof Pe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};t.forEach((i,o)=>{r[o]=i});let a=(i,o)=>(n=e(...t,o),$(n.value instanceof Pe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(Ra(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),s=(i,o)=>{let l=n.gradFunc(i,o),p=Array.isArray(l)?l:[l];$(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(p.every(h=>h instanceof Pe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let u={};return p.forEach((h,d)=>{u[d]=()=>h}),u};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Eu(),n=await this.backend.time(e);return n.wallMs=Eu()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new hw;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};$u.nextTensorId=0;$u.nextVariableId=0;function xE(e){let t=Bm(lt(e),"float32");return O.makeTensor(t,e,"float32")}function d0(){let e=n0();if(e._tfengine==null){let t=new t0(e);e._tfengine=new $u(t)}return G_(e._tfengine.ENV),fE(()=>e._tfengine),e._tfengine}var O=d0();function wE(e,t){let n={a:e,b:t};return O.runKernel(Ha,n)}var dp={};Ee(dp,{isBrowser:()=>c0,isMobile:()=>IE,mockIsMobile:()=>kE});function vE(){return typeof navigator<"u"&&navigator!=null}var Vf;function kE(e){Vf=e}function IE(e){if(Vf!==void 0)return Vf;if(e||vE()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function c0(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var nr=j();nr.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});nr.registerFlag("IS_BROWSER",()=>c0());nr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");nr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));nr.registerFlag("PROD",()=>!1);nr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>nr.getBool("DEBUG"));nr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);nr.registerFlag("IS_TEST",()=>!1);nr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);nr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);nr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);nr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Vr(e,t){let n=e;if(Zt(e))return t==="string"?[]:[e.length];if(typeof e=="object"){if("texture"in e){let a=e.channels||"RGBA";return[e.height,e.width*a.length]}else if("buffer"in e&&!(e.buffer instanceof ArrayBuffer))return[e.buffer.size/(t==null?4:Oh(t))]}if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Zt(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&j().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&f0(e,r,[]),r}function f0(e,t,n){if(n=n||[],!Array.isArray(e)&&!Zt(e)){$(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}$(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),$(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)f0(e[a],r,n.concat(a))}function dw(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function _(e,t,n,r="numeric"){if(e instanceof Pe)return dw(r,e.dtype,t,n),e;let a=xd(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),dw(r,a,t,n),e==null||!Zt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=Vr(e,a);!Zt(e)&&!Array.isArray(e)&&(e=[e]);let i=a!=="string"?ec(e,a):Fa(e,[],!0);return O.makeTensor(i,s,a)}function Au(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,s)=>_(a,`${t}[${s}]`,n,r))}var Hm="__op";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Hm;let a=(...s)=>{O.startScope(n);try{let i=r(...s);return vd(i)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(i),i}catch(i){throw O.endScope(null),i}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function SE(e,t){let n=_(e,"real","complex"),r=_(t,"imag","complex");bn(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return O.runKernel(Td,a)}var la=L({complex_:SE});function Xa(e,t,n,r){if(r==null)r=xd(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof e=="object"&&("texture"in e||"buffer"in e&&!(e.buffer instanceof ArrayBuffer))){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return O.backend.createTensorFromGPUData(e,t||n,r)}if(!Zt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){jn(t);let a=lt(t),s=lt(n);$(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==lt(t.slice(i)):!0;$(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Zt(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?ec(e,r):Fa(e,[],!0),O.makeTensor(e,t,r)}function dn(e,t,n){let r=Vr(e,n);return Xa(e,t,r,n)}var Uf={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Gh=4;async function NE(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let p={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async h=>{let d=await l.bytes(),c=d.reduce((g,y)=>g+y.length,0)+Gh*d.length,f=new Uint8Array(c),m=0;for(let g=0;g<d.length;g++){let y=d[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=Gh,f.set(y,m),m+=y.length}h(f)});r.push(u)}else r.push(l.data());t!=null&&(p.group=t),n.push(p)}let s=await Promise.all(r);return{data:TE(s),specs:n}}function m0(e,t){let n={},r,a=0;for(let s of t){let i=s.name,o=s.dtype,l=s.shape,p=lt(l),u;if("quantization"in s){let h=s.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${s.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(o!=="float32")throw new Error(`Weight ${s.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${o}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=Uf[h.dtype],c=e.slice(a,a+p*d),f=h.dtype==="uint8"?new Uint8Array(c):new Uint16Array(c);if(o==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];u[m]=g*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=RE()),u=r(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(o==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let m=0;m<f.length;m++){let g=f[m];u[m]=Math.round(g*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);a+=p*d}else if(o==="string"){let h=lt(s.shape);u=[];for(let d=0;d<h;d++){let c=new Uint32Array(e.slice(a,a+Gh))[0];a+=Gh;let f=new Uint8Array(e.slice(a,a+c));u.push(f),a+=c}}else{let h=Uf[o],d=e.slice(a,a+p*h);if(o==="float32")u=new Float32Array(d);else if(o==="int32")u=new Int32Array(d);else if(o==="bool")u=new Uint8Array(d);else if(o==="complex64"){u=new Float32Array(d);let c=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let y=0;y<c.length;y++)c[y]=u[y*2],f[y]=u[y*2+1];let m=dn(c,l,"float32"),g=dn(f,l,"float32");n[i]=la(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${o}`);a+=p*h}o!=="complex64"&&(n[i]=dn(u,l,o))}return n}function TE(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}var jm=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function cw(e){return jm?Buffer.byteLength(e):new Blob([e]).size}function CE(e){if(jm)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function _E(e){if(jm){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function qm(e){if(e.length===1)return e[0];let t=0;e.forEach(a=>{t+=a.byteLength});let n=new Uint8Array(t),r=0;return e.forEach(a=>{n.set(new Uint8Array(a),r),r+=a.byteLength}),n.buffer}function fw(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function g0(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function y0(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function Km(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),y0(e,n,r)}function cp(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:cw(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:cw(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function b0(e){let t=[];for(let n of e)t.push(...n.weights);return t}function EE(){let e=n=>{let r=n<<13,a=0;for(;!(r&8388608);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function $E(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function AE(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function RE(){let e=EE(),t=$E(),n=AE();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(a)}}var It=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return It.instance==null&&(It.instance=new It),It.instance}static registerSaveRouter(e){It.getInstance().saveRouters.push(e)}static registerLoadRouter(e){It.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return It.getHandlers(e,"save")}static getLoadHandlers(e,t){return It.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return(t==="load"?It.getInstance().loadRouters:It.getInstance().saveRouters).forEach(a=>{let s=a(e,n);s!==null&&r.push(s)}),r}},FE=e=>It.registerSaveRouter(e),DE=e=>It.registerLoadRouter(e),ME=e=>It.getSaveHandlers(e),OE=(e,t)=>It.getLoadHandlers(e,t),Gf="tensorflowjs",Hf=1,ms="models_store",Ta="model_info_store";function x0(){if(!j().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function jf(e){let t=e.result;t.createObjectStore(ms,{keyPath:"modelPath"}),t.createObjectStore(Ta,{keyPath:"modelPath"})}var Ts=class{constructor(e){if(this.indexedDB=x0(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let a=this.indexedDB.open(Gf,Hf);a.onupgradeneeded=()=>jf(a),a.onsuccess=()=>{let s=a.result;if(t==null){let i=s.transaction(ms,"readonly"),o=i.objectStore(ms).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),i.oncomplete=()=>s.close()}else{let i=cp(t),o=s.transaction(Ta,"readwrite"),l=o.objectStore(Ta),p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i}),u;p.onsuccess=()=>{u=s.transaction(ms,"readwrite");let h=u.objectStore(ms).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});h.onsuccess=()=>n({modelArtifactsInfo:i}),h.onerror=d=>{l=o.objectStore(Ta);let c=l.delete(this.modelPath);c.onsuccess=()=>(s.close(),r(h.error)),c.onerror=f=>(s.close(),r(h.error))}},p.onerror=h=>(s.close(),r(p.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}}},a.onerror=s=>r(a.error)})}};Ts.URL_SCHEME="indexeddb://";var w0=e=>j().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ts.URL_SCHEME)?LE(e.slice(Ts.URL_SCHEME.length)):null;It.registerSaveRouter(w0);It.registerLoadRouter(w0);function LE(e){return new Ts(e)}function zE(e){return e.startsWith(Ts.URL_SCHEME)?e.slice(Ts.URL_SCHEME.length):e}var PE=class{constructor(){this.indexedDB=x0()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Gf,Hf);n.onupgradeneeded=()=>jf(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Ta,"readonly"),s=a.objectStore(Ta).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=zE(e),new Promise((t,n)=>{let r=this.indexedDB.open(Gf,Hf);r.onupgradeneeded=()=>jf(r),r.onsuccess=()=>{let a=r.result,s=a.transaction(Ta,"readwrite"),i=s.objectStore(Ta),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=i.delete(e),u=()=>{l=a.transaction(ms,"readwrite");let h=l.objectStore(ms).delete(e);h.onsuccess=()=>t(o.result.modelArtifactsInfo),h.onerror=d=>n(o.error)};p.onsuccess=u,p.onerror=h=>(u(),a.close(),n(o.error))}},o.onerror=p=>(a.close(),n(o.error)),s.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}},ra="/",ao="tensorflowjs_models",v0="info",BE="model_topology",WE="weight_specs",VE="weight_data",UE="model_metadata";function k0(e){return{info:[ao,e,v0].join(ra),topology:[ao,e,BE].join(ra),weightSpecs:[ao,e,WE].join(ra),weightData:[ao,e,VE].join(ra),modelMetadata:[ao,e,UE].join(ra)}}function I0(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function GE(e){let t=e.split(ra);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ra)}function HE(e){return e.startsWith(Cs.URL_SCHEME)?e.slice(Cs.URL_SCHEME.length):e}var Cs=class{constructor(e){if(!j().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=k0(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=cp(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,CE(e.weightData));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw I0(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){let i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=_E(s),t}};Cs.URL_SCHEME="localstorage://";var S0=e=>j().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cs.URL_SCHEME)?jE(e.slice(Cs.URL_SCHEME.length)):null;It.registerSaveRouter(S0);It.registerLoadRouter(S0);function jE(e){return new Cs(e)}var qE=class{constructor(){$(j().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=ao+ra,n=ra+v0;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let s=GE(a);e[s]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=HE(e);let t=k0(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return I0(t),n}},oo="://",Tn=class{constructor(){this.managers={}}static getInstance(){return Tn.instance==null&&(Tn.instance=new Tn),Tn.instance}static registerManager(e,t){$(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(oo)&&(e=e.slice(0,e.indexOf(oo))),$(e.length>0,()=>"scheme must not be an empty string.");let n=Tn.getInstance();$(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=Tn.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Tn.getInstance().managers)}};function Ch(e){if(e.indexOf(oo)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Tn.getSchemes().join(",")}`);return{scheme:e.split(oo)[0],path:e.split(oo)[1]}}async function N0(e,t,n=!1){$(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=It.getLoadHandlers(e);$(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),$(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=It.getSaveHandlers(t);$(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),$(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Ch(e).scheme,l=Ch(e).path,p=o===Ch(e).scheme,u=await a.load();n&&p&&await Tn.getManager(o).removeModel(l);let h=await i.save(u);return n&&!p&&await Tn.getManager(o).removeModel(l),h.modelArtifactsInfo}async function KE(){let e=Tn.getSchemes(),t={};for(let n of e){let r=await Tn.getManager(n).listModels();for(let a in r){let s=n+oo+a;t[s]=r[a]}}return t}async function XE(e){let t=Ch(e);return Tn.getManager(t.scheme).removeModel(t.path)}async function ZE(e,t){return N0(e,t,!1)}async function JE(e,t){return N0(e,t,!0)}var YE=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!j().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}};if(j().get("IS_BROWSER")){j().setPlatform("browser",new YE);try{Tn.registerManager(Cs.URL_SCHEME,new qE)}catch{}try{Tn.registerManager(Ts.URL_SCHEME,new PE)}catch{}}var QE={importFetch:()=>u_()},xf,e$=class{constructor(){this.util=p_(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return j().global.fetch!=null?j().global.fetch(e,t):(xf==null&&(xf=QE.importFetch()),xf(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};j().get("IS_NODE")&&!j().get("IS_BROWSER")&&j().setPlatform("node",new e$);function ze(e,t="float32",n){return t=t||"float32",jn(e),new Mt(e,t,n)}function t$(e,t){let n=_(e,"x","cast");if(!Zv(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return O.runKernel(Hs,r,a)}var se=L({cast_:t$});function n$(e){let t={x:_(e,"x","clone","string_or_numeric")};return O.runKernel(ii,t)}var Pr=L({clone_:n$});function Xm(e,t=!1){console.log(e.toString(t))}d0();var r$={buffer:ze,cast:se,clone:Pr,print:Xm};mE(r$);function a$(){j().set("PROD",!0)}function s$(){j().set("DEBUG",!0)}function i$(){j().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function T0(e){j().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function o$(){O.disposeVariables()}function pr(){return O}function Hh(){return O.memory()}function l$(e){return O.profile(e)}function W(e,t){return O.tidy(e,t)}function _e(e){Gm(e).forEach(t=>t.dispose())}function Ft(e){return O.keep(e)}function u$(e){return O.time(e)}function p$(e){return O.setBackend(e)}function h$(){return O.ready()}function d$(){return O.backendName}function c$(e){O.removeBackend(e)}function f$(e){return O.findBackend(e)}function m$(e){return O.findBackendFactory(e)}function nc(e,t,n=1){return O.registerBackend(e,t,n)}function C0(){return O.backend}function g$(e,t){j().setPlatform(e,t)}function y$(e,t){let n=_(e,"a","add"),r=_(t,"b","add");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(Ha,a)}var J=L({add_:y$});function b$(e,t){let n=_(e,"a","floorDiv"),r=_(t,"b","floorDiv");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(ri,a)}var rc=L({floorDiv_:b$});function x$(e,t){let n=_(e,"a","div"),r=_(t,"b","div");if([n,r]=wt(n,r),n.dtype==="int32"&&r.dtype==="int32")return rc(n,r);let a={a:n,b:r},s={};return O.runKernel(Qs,a,s)}var me=L({div_:x$});function w$(e,t){let n=_(e,"a","mul"),r=_(t,"b","mul");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(yi,a)}var z=L({mul_:w$});function v$(e){let t=_(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return O.runKernel(Ku,n)}else{let n={x:t};return O.runKernel(Ao,n)}}var Ct=L({abs_:v$});function k$(e){let t={x:_(e,"x","acos")};return O.runKernel(Ro,t)}var Zm=L({acos_:k$});function I$(e){let t={x:_(e,"x","acosh")};return O.runKernel(Fo,t)}var Jm=L({acosh_:I$});function S$(e){$(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),$(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,s)=>_(a,`tensors${s}`,"addN")),n=t[0];t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!Ga(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return O.runKernel(Ws,r)}var _0=L({addN_:S$});function N$(e,t=null,n=!1){let r={x:_(e,"x","all","bool")},a={axis:t,keepDims:n};return O.runKernel(Do,r,a)}var ac=L({all_:N$});function T$(e,t=null,n=!1){let r={x:_(e,"x","any","bool")},a={axis:t,keepDims:n};return O.runKernel(Mo,r,a)}var Ru=L({any_:T$});function C$(e,t=0){let n={x:_(e,"x","argMax")},r={axis:t};return O.runKernel(Vs,n,r)}var _s=L({argMax_:C$});function _$(e,t=0){let n={x:_(e,"x","argMin")},r={axis:t};return O.runKernel(ju,n,r)}var Ym=L({argMin_:_$});function E$(e){let t={x:_(e,"x","asin")};return O.runKernel(Oo,t)}var Qm=L({asin_:E$});function $$(e){let t={x:_(e,"x","asinh")};return O.runKernel(Lo,t)}var eg=L({asinh_:$$});function A$(e){let t={x:_(e,"x","atan")};return O.runKernel(zo,t)}var tg=L({atan_:A$});function R$(e,t){let n=_(e,"a","atan2"),r=_(t,"b","atan2");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(Bo,a)}var ng=L({atan2_:R$});function F$(e){let t={x:_(e,"x","atanh")};return O.runKernel(Po,t)}var rg=L({atanh_:F$});function D$(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=A0(a);return fp(e,o,n,s,r,null,null,l)}function E0(e,t,n,r,a,s,i="channelsLast"){let[o,l]=Fu(t),p;if(i==="channelsLast")p=[o,l,e[3],e[3]];else if(i==="channelsFirst")p=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return fp(e,p,n,r,a,s,!1,i)}function M$(e,t,n,r,a,s,i="NDHWC"){let[o,l,p]=qf(t),u,h;if(i==="NDHWC")h="channelsLast",u=[o,l,p,e[4],e[4]];else if(i==="NCDHW")h="channelsFirst",u=[o,l,p,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return $0(e,u,n,r,a,!1,h,s)}function fp(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,p,u,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,p,u,h]=e;else if(o==="channelsFirst")[l,h,p,u]=e;else throw new Error(`Unknown dataFormat ${o}`);let[d,c,,f]=t,[m,g]=Fu(n),[y,b]=Fu(r),x=lo(d,y),v=lo(c,b),{padInfo:I,outHeight:N,outWidth:C}=z$(a,p,u,m,g,x,v,s,o),E=i?f*h:f,A;return o==="channelsFirst"?A=[l,E,N,C]:o==="channelsLast"&&(A=[l,N,C,E]),{batchSize:l,dataFormat:o,inHeight:p,inWidth:u,inChannels:h,outHeight:N,outWidth:C,outChannels:E,padInfo:I,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:c,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:A,filterShape:t}}function $0(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,p,u,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,p,u,h,d]=e;else if(i==="channelsFirst")[l,d,p,u,h]=e;else throw new Error(`Unknown dataFormat ${i}`);let[c,f,m,,g]=t,[y,b,x]=qf(n),[v,I,N]=qf(r),C=lo(c,v),E=lo(f,I),A=lo(m,N),{padInfo:F,outDepth:R,outHeight:S,outWidth:M}=P$(a,p,u,h,y,b,x,C,E,A,o),B=s?g*d:g,U;return i==="channelsFirst"?U=[l,B,R,S,M]:i==="channelsLast"&&(U=[l,R,S,M,B]),{batchSize:l,dataFormat:i,inDepth:p,inHeight:u,inWidth:h,inChannels:d,outDepth:R,outHeight:S,outWidth:M,outChannels:B,padInfo:F,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:c,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:E,effectiveFilterWidth:A,dilationDepth:v,dilationHeight:I,dilationWidth:N,inShape:e,outShape:U,filterShape:t}}function O$(e,t,n,r,a){r==null&&(r=ag(e,t,n));let s=e[0],i=e[1],o=Du((s-t+2*r)/n+1,a),l=Du((i-t+2*r)/n+1,a);return[o,l]}function L$(e,t,n,r,a,s){a==null&&(a=ag(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=Du((e[o]-t[o]+2*a)/r[o]+1,s));return i}function ag(e,t,n,r=1){let a=lo(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function Fu(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function qf(e){return typeof e=="number"?[e,e,e]:e}function lo(e,t){return t<=1?e:e+(e-1)*(t-1)}function z$(e,t,n,r,a,s,i,o,l){let p,u,h;if(typeof e=="number"){p={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let d=O$([t,n],s,r,e,o);u=d[0],h=d[1]}else if(e==="same"){u=Math.ceil(t/r),h=Math.ceil(n/a);let d=Math.max(0,(u-1)*r+s-t),c=Math.max(0,(h-1)*a+i-n),f=Math.floor(d/2),m=d-f,g=Math.floor(c/2),y=c-g;p={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")p={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/r),h=Math.ceil((n-i+1)/a);else if(typeof e=="object"){let d=l==="channelsLast"?e[1][0]:e[2][0],c=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];p={top:d,bottom:c,left:f,right:m,type:d===0&&c===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=Du((t-s+d+c)/r+1,o),h=Du((n-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outHeight:u,outWidth:h}}function P$(e,t,n,r,a,s,i,o,l,p,u){let h,d,c,f;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=L$([t,n,r,1],[o,l,p],1,[a,s,i],e,u);d=m[0],c=m[1],f=m[2]}else if(e==="same"){d=Math.ceil(t/a),c=Math.ceil(n/s),f=Math.ceil(r/i);let m=(d-1)*a+o-t,g=(c-1)*s+l-n,y=(f-1)*i+p-r,b=Math.floor(m/2),x=m-b,v=Math.floor(g/2),I=g-v,N=Math.floor(y/2),C=y-N;h={top:v,bottom:I,left:N,right:C,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:d,outHeight:c,outWidth:f}}function Du(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Da(e){let[t,n,r]=Fu(e);return t===1&&n===1&&r===1}function Hr(e,t){return Da(e)||Da(t)}function Es(e){return Fu(e).every(t=>t>0)}function A0(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function xn(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")$(po(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{$(po(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function B$(e,t){let n={x:_(e,"x","reshape","string_or_numeric")},r={shape:t};return O.runKernel(gl,n,r)}var P=L({reshape_:B$});function W$(e,t,n,r,a){let s=_(e,"x","avgPool","float32"),i=1;$(Hr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),xn("avgPool",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=O.runKernel(Us,p,u);return h=se(h,s.dtype),l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ha=L({avgPool_:W$});function V$(e,t,n,r,a,s="NDHWC"){let i=_(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),$(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),xn("avgPool3d",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=O.runKernel(qu,p,u);return h=se(h,o.dtype),l?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var sg=L({avgPool3d_:V$});function U$(e,t=0){$(e.length>=1,()=>"Pass at least one tensor to concat");let n=Au(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Pr(n[0]);let r=n,a={axis:t};return O.runKernel(Vo,r,a)}var nt=L({concat_:U$});function G$(e,t,n=!1,r=!1){let a=_(e,"a","matMul"),s=_(t,"b","matMul");[a,s]=wt(a,s);let i={a,b:s},o={transposeA:n,transposeB:r};return O.runKernel(Gs,i,o)}var Le=L({matMul_:G$});function H$(e){let t={x:_(e,"x","sigmoid","float32")};return O.runKernel(Ri,t)}var dr=L({sigmoid_:H$});function j$(e,t,n){let r=_(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return O.runKernel(wl,a,s)}var Ue=L({slice_:j$});function q$(e){let t={x:_(e,"x","tanh","float32")};return O.runKernel(Pi,t)}var $s=L({tanh_:q$});function K$(e,t,n,r,a,s){let i=_(e,"forgetBias","basicLSTMCell"),o=_(t,"lstmKernel","basicLSTMCell"),l=_(n,"lstmBias","basicLSTMCell"),p=_(r,"data","basicLSTMCell"),u=_(a,"c","basicLSTMCell"),h=_(s,"h","basicLSTMCell"),d=nt([p,h],1),c=Le(d,o),f=J(c,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Ue(f,[0,0],y),x=Ue(f,[0,g],y),v=Ue(f,[0,g*2],y),I=Ue(f,[0,g*3],y),N=J(z(dr(b),$s(x)),z(u,dr(J(i,v)))),C=z($s(N),dr(I));return[N,C]}var R0=L({basicLSTMCell_:K$});function X$(e,t,n){let r=_(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);$(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),$(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),$(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);let s={x:r},i={blockShape:t,crops:n};return O.runKernel(Wo,s,i)}var mp=L({batchToSpaceND_:X$});function Z$(e){let t;return e.rank===0||e.rank===1?t=P(e,[1,1,1,e.size]):e.rank===2?t=P(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function J$(e,t,n,r,a,s){s==null&&(s=.001);let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),p;a!=null&&(p=_(a,"scale","batchNorm"));let u;r!=null&&(u=_(r,"offset","batchNorm")),$(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(p==null||o.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let h={x:Z$(i),scale:p,offset:u,mean:o,variance:l},d={varianceEpsilon:s},c=O.runKernel(ai,h,d);return P(c,i.shape)}var Bi=L({batchNorm_:J$});function Y$(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),p;a!=null&&(p=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),$(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),$(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),$(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Bi(i,o,l,u,p,s)}var ig=L({batchNorm2d_:Y$});function Q$(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),p;a!=null&&(p=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),$(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),$(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),$(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Bi(i,o,l,u,p,s)}var og=L({batchNorm3d_:Q$});function eA(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),p;a!=null&&(p=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),$(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),$(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),$(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Bi(i,o,l,u,p,s)}var lg=L({batchNorm4d_:eA});function tA(e,t,n){let r=_(e,"x","bincount"),a=_(t,"weights","bincount");$(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);let s={x:r,weights:a},i={size:n};return O.runKernel(Sd,s,i)}var ug=L({bincount_:tA});function nA(e,t){let n=_(e,"s0","broadcastArgs","int32"),r=_(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return O.runKernel(Nd,a)}var F0=L({broadcastArgs_:nA});function rA(e,t){let n=_(e,"broadcastTo","x"),r=n.shape;if(jn(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=P(n,l)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return Pr(n);let i={x:n},o={reps:s};return O.runKernel(qa,i,o)}var ys=L({broadcastTo_:rA});function aA(e){let t={x:_(e,"x","ceil","float32")};return O.runKernel(js,t)}var pg=L({ceil_:aA});function Wn(e,t,n){jn(e);let r={shape:e,value:t,dtype:n};return O.runKernel(Ju,{},r)}function sA(e,t,n){let r=_(e,"x","clipByValue");if($(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Wn(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return O.runKernel(ja,a,s)}var an=L({clipByValue_:sA});function iA(e){return nt(e,0)}var hg=L({concat1d_:iA});function oA(e,t){return nt(e,t)}var dg=L({concat2d_:oA});function lA(e,t){return nt(e,t)}var cg=L({concat3d_:lA});function uA(e,t){return nt(e,t)}var fg=L({concat4d_:uA});function pA(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","conv2d","float32"),l=_(t,"filter","conv2d","float32"),p=o,u=!1;o.rank===3&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(p.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),$(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),xn("conv2d",r,i);let h=a==="NHWC"?p.shape[3]:p.shape[1];$(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),$(Hr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(Es(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),$(Es(n),()=>"Error in conv2D: Strides should be larger than 0.");let d={x:p,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=O.runKernel(qs,d,c);return u?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var cn=L({conv2d_:pA});function hA(e,t,n,r,a="NWC",s=1,i){let o=_(e,"x","conv1d"),l=_(t,"filter","conv1d"),p=o,u=!1;o.rank===2&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1]])),$(p.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),$(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),xn("conv1d",r,i),$(p.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${l.shape[1]}.`),$(Hr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),$(Es(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),$(Es(n),()=>"Error in conv1D: Stride should be larger than 0."),$(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let h=P(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=P(p,[p.shape[0],1,p.shape[1],p.shape[2]]),c=cn(d,h,[1,n],r,"NHWC",[1,s],i);return u?P(c,[c.shape[2],c.shape[3]]):P(c,[c.shape[0],c.shape[2],c.shape[3]])}var sc=L({conv1d_:hA});function dA(e,t,n,r,a,s="NHWC",i){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,p=!1;t.rank===3&&(p=!0,l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),$(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),$(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),$(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=s==="NHWC"?o[3]:o[1],h=s==="NHWC"?l.shape[3]:l.shape[1];$(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),$(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),xn("conv2dDerInput",a,i);let d={dy:l,filter:n},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=O.runKernel(Ks,d,c);return p?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var mg=L({conv2DBackpropInput_:dA});function cA(e,t,n,r,a,s){let i=_(e,"x","conv2dTranspose"),o=_(t,"filter","conv2dTranspose");return mg(n,i,o,r,a,"NHWC",s)}var ic=L({conv2dTranspose_:cA});function fA(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=_(e,"x","conv3d"),o=_(t,"filter","conv3d"),l=i,p=!1;i.rank===4&&(p=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),$(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),$(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),$(Hr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),$(Es(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),$(Es(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:o},h={strides:n,pad:r,dataFormat:a,dilations:s},d=O.runKernel(Xu,u,h);return p?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var gg=L({conv3d_:fA});function mA(e,t,n,r,a){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],p=i.shape[4];$(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),$(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),$(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),$(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),$(p===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`);let u={dy:i,filter:n},h={pad:a,strides:r,inputShape:s},d=O.runKernel(Ed,u,h);return o?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var D0=L({conv3DBackpropInput_:mA});function gA(e,t,n,r,a){let s=_(e,"x","conv3dTranspose"),i=_(t,"filter","conv3dTranspose");return D0(n,s,i,r,a)}var yg=L({conv3dTranspose_:gA});function yA(e){let t={x:_(e,"x","cos","float32")};return O.runKernel(Xs,t)}var gp=L({cos_:yA});function bA(e){let t={x:_(e,"x","cosh","float32")};return O.runKernel(Zs,t)}var oc=L({cosh_:bA});function xA(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(Uo,a,s)}var Mu=L({cumprod_:xA});function wA(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(Js,a,s)}var lc=L({cumsum_:wA});function vA(e,t,n,r=!1){let a=_(e,"x","denseBincount"),s=_(t,"weights","denseBincount");$(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),$(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);let i={x:a,weights:s},o={size:n,binaryOutput:r};return O.runKernel($d,i,o)}var jh=L({denseBincount_:vA});function kA(e,t,n="NHWC"){let r=_(e,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];$(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),$(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),$(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),$(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return O.runKernel(Ho,o,l)}var bg=L({depthToSpace_:kA});function IA(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","depthwiseConv2d","float32"),l=_(t,"filter","depthwiseConv2d","float32"),p=o,u=!1;o.rank===3&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(p.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),$(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let h=a==="NHWC"?p.shape[3]:p.shape[1];$(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),xn("depthwiseConv2d",r,i);let d={x:p,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=O.runKernel(Ys,d,c);return u?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Wi=L({depthwiseConv2d_:IA});function SA(e){let t={x:_(e,"x","diag")};return O.runKernel(Fd,t)}var M0=L({diag_:SA});function NA(e,t,n,r,a=[1,1],s="NHWC"){let i=_(e,"x","dilation2d"),o=_(t,"filter","dilation2d");$(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),$(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),$(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,p=!1;i.rank===3&&(l=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),p=!0),$(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let u={x:l,filter:o},h={strides:n,pad:r,dilations:a},d=O.runKernel(Zu,u,h);return p?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var xg=L({dilation2d_:NA}),Fl={};Ee(Fl,{assertAndGetBroadcastShape:()=>rt,getBroadcastDims:()=>O0,getReductionAxes:()=>Et});function O0(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&i===1&&r.unshift(s)}return r}function Et(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(a==null||a===1&&i>1)&&n.unshift(s)}return n}function rt(e,t){let n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let s=e[e.length-a-1];s==null&&(s=1);let i=t[t.length-a-1];if(i==null&&(i=1),s===1)n.unshift(i);else if(i===1)n.unshift(s);else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else n.unshift(s)}return n}function TA(e,t){let n=_(e,"a","equal","string_or_numeric"),r=_(t,"b","equal","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(qo,a)}var Vn=L({equal_:TA});function CA(e,t,n){let r=_(t,"a","where"),a=_(n,"b","where"),s=_(e,"condition","where","bool"),i=rt(rt(s.shape,r.shape),a.shape),o=ys(s,i),l=ys(r,i),p=ys(a,i),u={condition:o,t:l,e:p};return O.runKernel(bl,u)}var sn=L({where_:CA});function _A(e){let t={x:_(e,"x","zerosLike")};return O.runKernel(Al,t)}var He=L({zerosLike_:_A});function EA(e,t){let n=_(e,"a","div"),r=_(t,"b","div");[n,r]=wt(n,r);let a=me(n,r),s=He(a),i=Vn(r,s);return sn(i,s,a)}var wg=L({divNoNan_:EA});function $A(e,t){let n=_(e,"t1","dot"),r=_(t,"t2","dot");$((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if($(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),n.rank===1&&r.rank===1){let i=P(n,[1,-1]),o=P(r,[-1,1]),l=Le(i,o);return P(l,[])}else if(n.rank===1&&r.rank===2){let i=P(n,[1,-1]),o=P(r,[r.shape[0],r.shape[1]]),l=Le(i,o);return P(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=P(r,[-1,1]),o=Le(n,i);return P(o,[o.size])}else{let i=P(r,[r.shape[0],r.shape[1]]);return Le(n,i)}}var vg=L({dot_:$A});function AA(e,...t){let n=t.map((a,s)=>_(a,`tensors${s}`,"einsum")),r={equation:e};return O.runKernel(Dd,n,r)}var L0=L({einsum_:AA});function RA(e){let t={x:_(e,"x","elu","float32")};return O.runKernel(ei,t)}var Dl=L({elu_:RA});function FA(e){let t=_(e,"x","erf");$(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=se(t,"float32"));let n={x:t};return O.runKernel(jo,n)}var kg=L({erf_:FA});function Ig(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function z0(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?a.push(e[s++]):a.push(t[i++]);return a}function P0(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&n.push(e[s]);let a=t.map(s=>e[s]);return[n,a]}function As(e,t){let n=t.map(r=>1);return z0(e,n,t)}function DA(e,t,n){$(Ig(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function B0(e,t){if(Ig(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function Sg(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function MA(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function OA(e,t=null,n=!1){let r={x:_(e,"x","max")},a={reductionIndices:t,keepDims:n};return O.runKernel(pi,r,a)}var er=L({max_:OA});function LA(e,t=null,n=!1){let r={x:_(e,"x","min")},a={axis:t,keepDims:n};return O.runKernel(fi,r,a)}var co=L({min_:LA});function zA(e,t){let n=_(e,"base","pow"),r=_(t,"exp","pow");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(wi,a)}var ua=L({pow_:zA});function ve(e,t){if((Zt(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Zt(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Xa(e,[],[],t)}function PA(e){let t={x:_(e,"x","sqrt","float32")};return O.runKernel(Fi,t)}var en=L({sqrt_:PA});function BA(e){let t=_(e,"x","square"),n={};return O.runKernel("Square",{x:t},n)}var tt=L({square_:BA});function WA(e,t=null,n=!1){let r=_(e,"x","sum");r.dtype==="bool"&&(r=se(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(Di,a,s)}var ge=L({sum_:WA});function VA(e,t="euclidean",n=null,r=!1){e=_(e,"x","norm");let a=W0(e,t,n),s=a.shape;if(r){let i=mr(n,e.shape);s=As(a.shape,i)}return P(a,s)}function W0(e,t,n=null){if(e.rank===0)return Ct(e);if(e.rank!==1&&n===null)return W0(P(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ge(Ct(e),n);if(t===1/0)return er(Ct(e),n);if(t===-1/0)return co(Ct(e),n);if(t==="euclidean"||t===2)return en(ge(ua(Ct(e),ve(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return er(ge(Ct(e),n[0]),n[1]-1);if(t===1/0)return er(ge(Ct(e),n[1]),n[0]);if(t===-1/0)return co(ge(Ct(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return en(ge(tt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Ml=L({norm_:VA});function UA(e,t=null,n=!1){return Ml(e,"euclidean",t,n)}var Ng=L({euclideanNorm_:UA});function GA(e){let t={x:_(e,"x","exp")};return O.runKernel(ti,t)}var fn=L({exp_:GA});function HA(e,t=0){let n=_(e,"x","expandDims","string_or_numeric");$(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},a={dim:t};return O.runKernel(Ko,r,a)}var Jt=L({expandDims_:HA});function jA(e){let t={x:_(e,"x","expm1")};return O.runKernel(Xo,t)}var Tg=L({expm1_:jA});function qA(e,t){let n=_(e,"x","tile","string_or_numeric");$(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},a={reps:t};return O.runKernel(qa,r,a)}var Pn=L({tile_:qA});function KA(e,t,n,r="float32"){t==null&&(t=e);let a=ze([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=P(a.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Pn(Jt(i,0),[n[0],1,1]);if(n.length===2)return Pn(Jt(Jt(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Pn(Jt(Jt(Jt(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var uc=L({eye_:KA});function XA(e){let t={x:_(e,"x","floor","float32")};return O.runKernel(ni,t)}var Ol=L({floor_:XA});function ZA(e,t,n=0,r=0){let a=_(e,"x","gather"),s=_(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return O.runKernel(Jo,i,o)}var Ll=L({gather_:ZA});function JA(e,t){let n=_(e,"a","greater","string_or_numeric"),r=_(t,"b","greater","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Qo,a)}var wn=L({greater_:JA});function YA(e,t){let n=_(e,"a","greaterEqual","string_or_numeric"),r=_(t,"b","greaterEqual","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(si,a)}var da=L({greaterEqual_:YA});function QA(e){let t={input:_(e,"input","imag")};return O.runKernel(zd,t)}var yp=L({imag_:QA});function eR(e){let t={x:_(e,"x","isFinite")};return O.runKernel(el,t)}var Cg=L({isFinite_:eR});function tR(e){let t={x:_(e,"x","isInf")};return O.runKernel(tl,t)}var _g=L({isInf_:tR});function nR(e){let t={x:_(e,"x","isNaN")};return O.runKernel(oi,t)}var Eg=L({isNaN_:nR});function rR(e,t=.2){let n={x:_(e,"x","leakyRelu")},r={alpha:t};return O.runKernel(li,n,r)}var bp=L({leakyRelu_:rR});function aR(e,t){let n=_(e,"a","less","string_or_numeric"),r=_(t,"b","less","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(nl,a)}var pc=L({less_:aR});function sR(e,t){let n=_(e,"a","lessEqual","string_or_numeric"),r=_(t,"b","lessEqual","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(rl,a)}var Za=L({lessEqual_:sR});function V0(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return O.runKernel(Pd,{},r)}function iR(e,t=5,n=1,r=1,a=.5){let s=_(e,"x","localResponseNormalization");$(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),$(po(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=P(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},p={depthRadius:t,bias:n,alpha:r,beta:a},u=O.runKernel(Yu,l,p);return o?P(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var $g=L({localResponseNormalization_:iR});function oR(e){let t={x:_(e,"x","log","float32")};return O.runKernel(ui,t)}var Un=L({log_:oR});function lR(e){let t={x:_(e,"x","log1p")};return O.runKernel(al,t)}var xp=L({log1p_:lR});function uR(e){return $(Ra(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=_(t,"x","tf.grad","string_or_numeric"),a=n!=null?_(n,"dy","tf.grad"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(r),[r],a);return a!=null&&bn(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),hc(i),i[0]})}}function pR(e){return $(Ra(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{$(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=Au(t,"args","tf.grads","string_or_numeric"),a=n!=null?_(n,"dy","tf.grads"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(...r),r,a);return a!=null&&bn(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hc(i),i})}}function hR(e){return $(Ra(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{$(t instanceof Pe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),$(n==null||n instanceof Pe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=O.gradients(()=>e(t),[t],n);return hc(r),{grad:r[0],value:a}}}function dR(e){return $(Ra(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{$(Array.isArray(t)&&t.every(a=>a instanceof Pe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),$(n==null||n instanceof Pe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=O.gradients(()=>e(...t),t,n);return n!=null&&bn(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hc(r.grads),r}}function U0(e,t){$(Ra(e),()=>"The f passed in variableGrads(f) must be a function"),$(t==null||Array.isArray(t)&&t.every(p=>p instanceof Ns),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let p in O.registeredVariables)t.push(O.registeredVariables[p])}let r=n?t.filter(p=>!p.trainable):null,a=t.length;t=t.filter(p=>p.trainable),$(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let s=!0,{value:i,grads:o}=O.gradients(e,t,null,s);$(o.some(p=>p!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((p,u)=>{o[u]!=null&&(l[p.name]=o[u])}),r!=null&&r.forEach(p=>l[p.name]=null),{value:i,grads:l}}function Ur(e){return O.customGrad(e)}function hc(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function cR(e){let t={x:_(e,"x","neg")};return O.runKernel(ul,t)}var dt=L({neg_:cR});function fR(e){let t={x:_(e,"x","softplus")};return O.runKernel(Il,t)}var Vi=L({softplus_:fR});function mR(e){let t=_(e,"x","logSigmoid");return Ur(n=>({value:dt(Vi(dt(n))),gradFunc:r=>z(r,dr(dt(n)))}))(t)}var Ag=L({logSigmoid_:mR});function gR(e,t){let n=_(e,"a","sub"),r=_(t,"b","sub");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(Li,a)}var de=L({sub_:gR});function yR(e,t=-1){let n=_(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Ur((r,a)=>{let s=er(r,t,!0),i=de(r,s),o=de(se(i,"float32"),Un(ge(fn(i),t,!0)));return a([o]),{value:o,gradFunc:(l,p)=>{let[u]=p,h=!0,d=fn(u);return de(l,z(ge(l,t,h),d))}}})(n)}var dc=L({logSoftmax_:yR});function bR(e,t=null,n=!1){let r=_(e,"x","logSumExp"),a=mr(t,r.shape),s=er(r,a,!0),i=de(r,s),o=fn(i),l=ge(o,a),p=Un(l),u=J(P(s,p.shape),p);if(n){let h=As(u.shape,a);return P(u,h)}return u}var cc=L({logSumExp_:bR});function xR(e,t){let n=_(e,"a","logicalAnd","bool"),r=_(t,"b","logicalAnd","bool");rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(sl,a)}var cr=L({logicalAnd_:xR});function wR(e){let t={x:_(e,"x","logicalNot","bool")};return O.runKernel(il,t)}var wp=L({logicalNot_:wR});function vR(e,t){let n=_(e,"a","logicalOr","bool"),r=_(t,"b","logicalOr","bool");rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(ol,a)}var fc=L({logicalOr_:vR});function kR(e,t){let n=_(e,"a","logicalXor","bool"),r=_(t,"b","logicalXor","bool");return rt(n.shape,r.shape),cr(fc(e,t),wp(cr(e,t)))}var Rg=L({logicalXor_:kR}),hh=2147483648;function IR(e,t,n="left"){let r=_(e,"sortedSequence","searchSorted"),a=_(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=P(r,[-1,s]),l=P(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(lt(l.shape)>=hh)throw new Error(`values tensor size must less than ${hh}`);if(o.shape[1]>=hh)throw new Error(`trailing dim_size must less than ${hh} for int32 output type, was ${o.shape[1]}`);let p={sortedSequence:o,values:l},u={side:n};return O.runKernel(Jd,p,u)}var mc=L({searchSorted_:IR});function G0(e,t){return mc(e,t,"left")}function SR(e,t,n,r,a){let s=_(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),$(Hr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),xn("maxPool",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},h=O.runKernel(di,p,u);return l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Wt=L({maxPool_:SR});function NR(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=_(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),xn("maxPool3d",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},h=O.runKernel(Qu,p,u);return l?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var Fg=L({maxPool3d_:NR});function TR(e,t,n,r,a=!1){let s={x:_(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=O.runKernel(Ud,s,i);return{result:o[0],indexes:o[1]}}var H0=L({maxPoolWithArgmax_:TR});function CR(e,t){let n=_(e,"a","maximum"),r=_(t,"b","maximum");[n,r]=wt(n,r),n.dtype==="bool"&&(n=se(n,"int32"),r=se(r,"int32")),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(hi,a)}var jr=L({maximum_:CR});function _R(e,t=null,n=!1){let r={x:_(e,"x","mean")},a={axis:t,keepDims:n};return O.runKernel(ci,r,a)}var yt=L({mean_:_R});function bt(e,t="float32"){if(jn(e),t==="complex64"){let r=bt(e,"float32"),a=bt(e,"float32");return la(r,a)}let n=wd(lt(e),t);return O.makeTensor(n,e,t)}function Bn(e,t="float32"){if(jn(e),t==="complex64"){let r=Bn(e,"float32"),a=bt(e,"float32");return la(r,a)}let n=Bm(lt(e),t);return O.makeTensor(n,e,t)}function j0(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=_(e,"x","meshgrid",e instanceof Pe?e.dtype:"float32");if(t===void 0)return[r];let a=_(t,"y","meshgrid",t instanceof Pe?t.dtype:"float32"),s=lt(r.shape),i=lt(a.shape);return n==="xy"?(r=P(r,[1,-1]),a=P(a,[-1,1]),[Le(Bn([i,1],r.dtype),r),Le(a,Bn([1,s],a.dtype))]):(r=P(r,[-1,1]),a=P(a,[1,-1]),[Le(r,Bn([1,i],r.dtype)),Le(Bn([s,1],a.dtype),a)])}function ER(e,t){let n=_(e,"a","minimum"),r=_(t,"b","minimum");[n,r]=wt(n,r),n.dtype==="bool"&&(n=se(n,"int32"),r=se(r,"int32")),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(mi,a)}var zl=L({minimum_:ER});function $R(e,t,n){$(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=_(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)$(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:n},i={x:r};return O.runKernel(gi,i,s)}var Dg=L({mirrorPad_:$R});function AR(e,t){let n=_(e,"a","mod"),r=_(t,"b","mod");[n,r]=wt(n,r);let a={a:n,b:r};return O.runKernel(ll,a)}var Mg=L({mod_:AR});function RR(e,t=null,n=!1){e=_(e,"x","moments");let r=mr(t,e.shape),a=yt(e,r,n),s=a.shape;n||(s=As(a.shape,r));let i=tt(de(se(e,"float32"),P(a,s))),o=yt(i,r,n);return{mean:a,variance:o}}var vp=L({moments_:RR});function FR(e,t,n,r){let a=_(t,"data","multiRNNCell"),s=Au(n,"c","multiRNNCell"),i=Au(r,"h","multiRNNCell"),o=a,l=[];for(let h=0;h<e.length;h++){let d=e[h](o,s[h],i[h]);l.push(d[0]),l.push(d[1]),o=d[1]}let p=[],u=[];for(let h=0;h<l.length;h+=2)p.push(l[h]),u.push(l[h+1]);return[p,u]}var q0=L({multiRNNCell_:FR});function DR(e,t,n,r=!1){let a=_(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?P(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},p=O.runKernel(Gd,o,l);return i===1?P(p,[p.size]):p}var K0=L({multinomial_:DR});function MR(e,t){let n=_(e,"a","notEqual","string_or_numeric"),r=_(t,"b","notEqual","string_or_numeric");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(pl,a)}var Rs=L({notEqual_:MR});function OR(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:_(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return O.runKernel(bi,s,i)}var fo=L({oneHot_:OR});function LR(e){let t={x:_(e,"x","onesLike")};return O.runKernel(fl,t)}var Gn=L({onesLike_:LR});function zR(e,t){let n=_(e,"v1","outerProduct"),r=_(t,"v2","outerProduct");$(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=P(n,[-1,1]),s=P(r,[1,-1]);return Le(a,s)}var X0=L({outerProduct_:zR});function PR(e,t,n=0){let r=_(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return O.runKernel(xi,s,a)}var Er=L({pad_:PR});function BR(e,t,n=0){return $(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Er(e,[t],n)}var Z0=L({pad1d_:BR});function WR(e,t,n=0){return $(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Er(e,t,n)}var J0=L({pad2d_:WR});function VR(e,t,n=0){return $(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Er(e,t,n)}var Y0=L({pad3d_:VR});function UR(e,t,n=0){return $(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Er(e,t,n)}var Q0=L({pad4d_:UR});function GR(e,t,n){let r=_(e,"x","spaceToBatchND");$(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),$(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),$(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let a={x:r},s={blockShape:t,paddings:n};return O.runKernel(Sl,a,s)}var kp=L({spaceToBatchND_:GR});function HR(e,t,n,r,a,s,i){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=_(e,"x","maxPool"),l=o,p=!1;o.rank===3&&(p=!0,l=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(Hr(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let u=E0(l.shape,t,s,a,r),h=[u.dilationHeight,u.dilationWidth],d;r==="same"?d=qR([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];let c=h[0]===1&&h[1]===1,[f,m]=jR([u.inHeight,u.inWidth],h,d),g=c?r:"valid",y=c?l:kp(l,h,f),b=(n==="avg"?()=>ha(y,t,s,g,i):()=>Wt(y,t,s,g,i))(),x=c?b:mp(b,h,m);return p?P(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function jR(e,t,n){let r=n.map(u=>u[0]),a=n.map(u=>u[1]),s=e.concat(r,a),i=t.map((u,h)=>(u-s[h]%u)%u),o=a.map((u,h)=>u+i[h]),l=t.map((u,h)=>[r[h],o[h]]),p=t.map((u,h)=>[0,i[h]]);return[l,p]}function qR(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),a=n.map((s,i)=>s-r[i]);return n.map((s,i)=>[r[i],a[i]])}var Og=L({pool_:HR});function KR(e,t){let n=_(e,"x","prelu"),r=_(t,"alpha","prelu"),a={x:n,alpha:r};return O.runKernel(vi,a)}var Ip=L({prelu_:KR});function XR(e,t=null,n=!1){let r=_(e,"x","prod");r.dtype==="bool"&&(r=se(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(ki,a,s)}var Lg=L({prod_:XR});function ZR(e,t,n,r){let a=e.map((u,h)=>_(u,`tensors${h}`,"raggedGather","int32")),s=_(t,"paramsDenseValues","raggedGather"),i=_(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},p=O.runKernel(Hd,o,l);return{outputNestedSplits:p.slice(0,p.length-1),outputDenseValues:p[p.length-1]}}var e1=L({raggedGather_:ZR});function JR(e,t,n){let r=_(e,"starts","raggedRange"),a=_(t,"limits","raggedRange",r.dtype),s=_(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=O.runKernel(jd,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var t1=L({raggedRange_:JR});function YR(e,t,n,r,a){let s=_(e,"shape","raggedTensorToTensor","int32"),i=_(t,"values","raggedTensorToTensor"),o=_(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((h,d)=>_(h,`tensors${d}`,"raggedTensorToTensor","int32")),p={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:a};return O.runKernel(qd,p,u)}var n1=L({raggedTensorToTensor_:YR});function QR(e,t,n){jn(e);let r=lt(e),a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)a[s]=t();return O.makeTensor(a,e,n)}var r1=L({rand_:QR}),zg=Ua(yd()),a1={};Ee(a1,{TEST_EPSILON_FLOAT16:()=>s1,createVideoElement:()=>oF,encodeStrings:()=>i1,expectArrayBuffersEqual:()=>iF,expectArraysClose:()=>tF,expectArraysEqual:()=>rF,expectNumbersClose:()=>aF,expectPromiseToFail:()=>nF,expectValuesInRange:()=>sF,play:()=>lF,testEpsilon:()=>Pg});var eF=.001,s1=.1;function tF(e,t,n){return n==null&&(n=Pg()),Kf(e,t,(r,a)=>Bg(r,a,n))}function Pg(){return O.backend.floatPrecision()===32?eF:s1}function Kf(e,t,n){let r=!0;if((Zt(e)||Zt(t))&&(r=!1),Zt(e)&&Zt(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Vr(e),o=Vr(t);if(!Ga(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let a=Zt(e)?e:Fa(e),s=Zt(t)?t:Fa(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=a[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function nF(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function rF(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Na(e)||Na(e[0])||Na(t)||Na(t[0])?Kf(e,n,(r,a)=>r==a):Kf(e,t,(r,a)=>Bg(r,a,0))}function aF(e,t,n){if(n==null&&(n=Pg()),!Bg(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Bg(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function sF(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function iF(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function i1(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?i1(n):e[t]=hp(n)}return e}function oF(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function lF(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Wg=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=a||Math.random();this.random=zg.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,s;do r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},uF=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=zg.alea(a.toString()),this.randn=new Wg(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},pF=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zg.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function hF(e,t,n=1,r="float32",a){if(jn(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new uF(t,n,r,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var o1=L({randomGamma_:hF});function dF(e,t=0,n=1,r,a){if(jn(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new Wg(t,n,r,!1,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var gc=L({randomNormal_:dF});function cF(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return gc(e,0,1,t,n)}var l1=L({randomStandardNormal_:cF});function fF(e,t=0,n=1,r="float32",a){jn(e);let s=ze(e,r),i=new pF(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Pl=L({randomUniform_:fF});function Fs(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return O.runKernel(ep,{},a)}function mF(e){let t={input:_(e,"input","real")};return O.runKernel(Kd,t)}var mo=L({real_:mF});function gF(e){let t={x:_(e,"x","reciprocal")};return O.runKernel(Ii,t)}var Vg=L({reciprocal_:gF});function yF(e){let t={x:_(e,"x","relu")};return O.runKernel(Si,t)}var Ye=L({relu_:yF});function bF(e){let t={x:_(e,"x","relu6")};return O.runKernel(Ci,t)}var yc=L({relu6_:bF});function xF(e,t){let n={x:_(e,"x","reverse")},r={dims:t};return O.runKernel(_i,n,r)}var rr=L({reverse_:xF});function wF(e){let t=_(e,"x","reverse");return $(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),rr(t,0)}var u1=L({reverse1d_:wF});function vF(e,t){let n=_(e,"x","reverse");return $(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),rr(n,t)}var p1=L({reverse2d_:vF});function kF(e,t){let n=_(e,"x","reverse");return $(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),rr(n,t)}var h1=L({reverse3d_:kF});function IF(e,t){let n=_(e,"x","reverse");return $(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),rr(n,t)}var d1=L({reverse4d_:IF});function SF(e){let t={x:_(e,"x","round")};return O.runKernel(Ei,t)}var bc=L({round_:SF});function NF(e){let t={x:_(e,"x","rsqrt","float32")};return O.runKernel($i,t)}var xc=L({rsqrt_:NF});function TF(e){let t={x:_(e,"x","selu")};return O.runKernel(xl,t)}var wc=L({selu_:TF});function CF(e,t,n,r,a,s=[1,1],i="NHWC"){let o=_(e,"x","separableConv2d"),l=_(t,"depthwiseFilter","separableConv2d"),p=_(n,"pointwiseFilter","separableConv2d"),u=o,h=!1;if(o.rank===3&&(h=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),$(p.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),$(p.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),$(p.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);let d=l.shape[2],c=l.shape[3];$(p.shape[2]===d*c,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*c}, but got ${p.shape[2]}.`);let f=Wi(u,l,r,a,i,s),m=cn(f,p,1,"valid",i);return h?P(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Bl=L({separableConv2d_:CF});async function _F(e,t){let n=_(e,"x","setdiff1d"),r=_(t,"y","setdiff1d");$(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),$(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),$(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let u=0;u<a.length;u++)i.has(a[u])||o++;let l=new Mt([o],n.dtype),p=new Mt([o],"int32");for(let u=0,h=0;u<a.length;u++)i.has(a[u])||(l.values[h]=a[u],p.values[h]=u,h++);return[l.toTensor(),p.toTensor()]}var c1=_F;function EF(e){let t={x:_(e,"x","sign")};return O.runKernel(kl,t)}var Ug=L({sign_:EF});function $F(e){let t={x:_(e,"x","sin","float32")};return O.runKernel(Ai,t)}var vc=L({sin_:$F});function AF(e){let t={x:_(e,"x","sinh")};return O.runKernel(vl,t)}var kc=L({sinh_:AF});function RF(e,t,n){let r=_(e,"x","slice1d");return $(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[t],[n])}var Sp=L({slice1d_:RF});function FF(e,t,n){let r=_(e,"x","slice2d");return $(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Ic=L({slice2d_:FF});function DF(e,t,n){let r=_(e,"x","slice3d");return $(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Wl=L({slice3d_:DF});function MF(e,t,n){let r=_(e,"x","slice4d");return $(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var go=L({slice4d_:MF});function OF(e,t=-1){let n=_(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return O.runKernel(Mi,r,a)}var Ja=L({softmax_:OF});function LF(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(Od,t)}var Np=L({fft_:LF});function zF(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(Ld,t)}var yo=L({ifft_:zF});function PF(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let a=P(e,[n,t]);r=yo(a)}else{let a=[n,2*(t-1)],s=P(mo(e),[n,t]),i=P(yp(e),[n,t]),o=rr(Ue(s,[0,1],[n,t-2]),1),l=z(rr(Ue(i,[0,1],[n,t-2]),1),ve(-1)),p=nt([s,o],1),u=nt([i,l],1),h=P(la(p,u),[a[0],a[1]]);r=yo(h)}if(r=mo(r),e.rank===3&&e.shape[0]!==0){let a=r,s=e.shape[0];r=P(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}var Sc=L({irfft_:PF});function BF(e,t,n=0){let r={x:_(e,"x","split")},a={numOrSizeSplits:t,axis:n};return O.runKernel(Nl,r,a)}var _n=L({split_:BF});function WF(e,t){$(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,a;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,a=Ue(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,a=nt([e,bt(f)],e.shape.length-1),n=t}else a=e;let s=He(a),i=P(la(a,s),[r,n]),o=Np(i),l=Math.floor(n/2)+1,p=mo(o),u=yp(o),h=_n(p,[l,n-l],p.shape.length-1),d=_n(u,[l,n-l],u.shape.length-1),c=a.shape.slice();return c[a.shape.length-1]=l,P(la(h[0],d[0]),c)}var Tp=L({rfft_:WF});function VF(e,t){let n=_(e,"a","squaredDifference"),r=_(t,"b","squaredDifference");[n,r]=wt(n,r),rt(n.shape,r.shape);let a={a:n,b:r},s={};return O.runKernel(Oi,a,s)}var Nc=L({squaredDifference_:VF});function UF(e,t){let n=_(e,"x","squeeze","string_or_numeric");return P(n,jv(n.shape,t).newShape)}var Ya=L({squeeze_:UF});function GF(e,t=0){let n=Au(e,"tensors","stack","string_or_numeric");$(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&$(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,a={axis:t};return O.runKernel(ml,r,a)}var Ot=L({stack_:GF});function HF(e,t=0){let n={x:_(e,"x","step")},r={alpha:t};return O.runKernel(Ka,n,r)}var Ui=L({step_:HF});function jF(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let p={x:_(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return O.runKernel(Cl,p,u)}var Gg=L({stridedSlice_:jF});function qF(e){let t={x:_(e,"x","tan","float32")};return O.runKernel(zi,t)}var Hg=L({tan_:qF});function Je(e,t){Bs(e);let n=Vr(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Xa(e,null,n,t)}function Br(e,t,n){if(Bs(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Vr(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Xa(e,t,r,n)}function Tc(e,t,n){if(Bs(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Vr(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Xa(e,t,r,n)}function Ma(e,t,n){if(Bs(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Vr(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Xa(e,t,r,n)}function f1(e,t,n){if(Bs(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Vr(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Xa(e,t,r,n)}function m1(e,t,n){if(Bs(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Vr(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Xa(e,t,r,n)}function KF(e,t=1,n=!0){let r=_(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=O.runKernel(_l,s,i);return{values:o,indices:l}}var jg=L({topk_:KF});function XF(e,t=0,n=1,r,a){if(jn(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Wg(t,n,r,!0,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Cc=L({truncatedNormal_:XF});function ZF(e,t=0){let n=_(e,"x","unique","string_or_numeric");$(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[s,i]=O.runKernel(Qd,r,a);return{values:s,indices:i}}var qg=L({unique_:ZF});function JF(e,t,n){let r=_(e,"x","unsortedSegmentSum"),a=_(t,"segmentIds","unsortedSegmentSum","int32");$(po(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:a},i={numSegments:n};return O.runKernel(lp,s,i)}var _c=L({unsortedSegmentSum_:JF});function YF(e,t=0){let n=_(e,"x","unstack","string_or_numeric");$(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},a={axis:t};return O.runKernel($l,r,a)}var St=L({unstack_:YF});function g1(e,t){return mc(e,t,"right")}function Kg(e,t=!0,n,r){return O.makeVariable(e,t,n,r)}function y1(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=ze(e,"int32"),a=ze([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=r.indexToLoc(n[s]),o=s*e.length;a.values.set(i,o)}return a.toTensor()}async function QF(e){let t=_(e,"condition","whereAsync","bool"),n=await t.data(),r=y1(t.shape,n);return e!==t&&t.dispose(),r}var Xg=QF;async function eD(e,t,n){let r=_(e,"tensor","boolMask"),a=_(t,"mask","boolMask","bool"),s=n??0,i=a.rank,o=r.shape;$(i>0,()=>"mask cannot be scalar"),bn(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let p=o.slice(0,s).concat([l],o.slice(s+i)),u=P(r,p),h=P(a,[-1]),d=await Xg(h),c=Ya(d,[1]),f=Ll(u,c,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),c.dispose(),u.dispose(),h.dispose(),d.dispose(),f}var b1=eD;function tD(e,t,n){let r=_(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),$(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{$(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return r.dtype==="complex64"?W(()=>{let i=mo(r),o=yp(r);return i=O.runKernel(aa,{x:i},s),o=O.runKernel(aa,{x:o},s),n&&(o=dt(o)),la(i,o)}):O.runKernel(aa,a,s)}var Fe=L({transpose_:tD});function nD(e,t,n,r,a=!0){let s=_(e,"v","movingAverage"),i=_(t,"x","movingAverage"),o=_(n,"decay","movingAverage");p0(s,i),$(Ga(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=ve(1),p=de(l,o),u=z(de(i,s),p);if(a){$(r!=null,()=>"When using zeroDebias: true, step is required.");let h=_(r,"step","movingAverage");u=me(u,de(l,ua(o,h)))}return J(s,u)}var x1=L({movingAverage_:nD}),Zg={};Ee(Zg,{calculateShapes:()=>w1,validateInput:()=>Yg,validateUpdateShape:()=>Jg});function Jg(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+` update.rank != ${a+e.length-r}`);for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Yg(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Jg(n,t,e)}function w1(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let h=a;h<s;++h)i*=n[h];let o=a<1?1:a,l=lt(t.shape)/o,p=[...$o(n.slice(0,a)),1],u=lt(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:p,outputSize:u}}function rD(e,t,n){jn(n);let r=_(e,"indices","scatterND","int32"),a=_(t,"updates","scatterND");Yg(a,r,n);let s={indices:r,updates:a},i={shape:n};return O.runKernel(yl,s,i)}var v1=L({scatterND_:rD});function aD(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sD(e,t,n,r=0){jn(n);let a=_(e,"sparseIndices","sparseToDense","int32"),s=_(t,"sparseValues","sparseToDense","string_or_numeric"),i=_(r,"defaultValue","sparseToDense",s.dtype);aD(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return O.runKernel(Yd,o,l)}var k1=L({sparseToDense_:sD});function iD(e,t){let n=_(t,"indices","gatherND","int32"),r={params:_(e,"x","gatherND","string_or_numeric"),indices:n};return O.runKernel(Yo,r)}var I1=L({gatherND_:iD});function oD(e,t){if(t==null)return e.shape.slice();if(Ga(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function lD(e,t,n,r){let a=_(e,"x","dropout");if($(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),$(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Pe?a.clone():a;let s=oD(a,n),i=1-t,o=me(Ol(J(Pl(s,0,1,"float32",r),i)),i);return z(a,o)}var Qg=L({dropout_:lD});function ey(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Ec(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Je(a,"float32")}async function uD(e,t,n=1){let r=_(e,"predictions","inTopK"),a=_(t,"targets","inTopK");$(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),$(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),bn(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];$(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,p]=[i.length/s,s],u=qv("bool",l);for(let h=0;h<l;h++){let d=h*p,c=i.subarray(d,d+p),f=[];for(let m=0;m<c.length;m++)f.push({value:c[m],index:m});f.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<n;m++)if(f[m].index===o[h]){u[h]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),dn(u,a.shape,"bool")}var S1=uD,bo={};Ee(bo,{conv2d:()=>dD,depthwiseConv2d:()=>gD,matMul:()=>bD});function pD(e,t,n,r,a,s="NHWC",i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),$(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),$(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let p=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];$(p===n[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${n[2]}.`),$(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),xn("conv2dDerFilter",a,i);let h={x:o,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return O.runKernel(Cd,h,d)}var ty=L({conv2DBackpropFilter_:pD});function $c(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return z(e,Ui(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ac(e,t){let n=t,r=Et(e.shape,t.shape);return r.length>0&&(n=ge(n,r)),P(n,e.shape)}function Rc(e,t,n,r){if(t==="linear")return e;if(t==="relu")return Ye(e);if(t==="elu")return Dl(e);if(t==="relu6")return yc(e);if(t==="prelu")return Ip(e,n);if(t==="leakyrelu")return bp(e,r);if(t==="sigmoid")return dr(e);throw new Error(`Unknown fused activation ${t}.`)}var Fc=(e,t)=>!(e>0)||t==="linear";function hD({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:u}){if(l=l||"linear",Fc(O.state.gradientDepth,l)===!1){$(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=cn(e,t,n,r,a,s,i);return o!=null&&(N=J(N,o)),Rc(N,l,p,u)}let h=_(e,"x","conv2d","float32"),d=_(t,"filter","conv2d","float32"),c=h,f=!1;h.rank===3&&(f=!0,c=P(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(c.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${c.rank}.`),$(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),xn("fused conv2d",r,i);let m=a==="NHWC"?c.shape[3]:c.shape[1];$(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),$(Hr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=fp(c.shape,d.shape,n,s,r,i),y;o!=null&&(y=_(o,"bias","fused conv2d"),[y]=wt(y,h),a==="NHWC"?rt(g.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(p!=null){let N=p.shape;if($(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)$(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{rt(N,g.outShape)}catch{let E=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(E)}b=_(p,"prelu weights","fused conv2d")}let x=(N,C)=>{$(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[E,A,F,R]=C,S=$c(N,F,l);$(Da(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=mg(A.shape,S,E,n,r),B=ty(A,S,E.shape,n,r),U=[M,B];if(R!=null){let G=Ac(R,S);U.push(G)}return U},v={x:c,filter:d,bias:y,preluActivationWeights:b},I={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Ur((N,C,E)=>{let A=O.runKernel(Is,v,I);return E([C,N,A]),f&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(c,d):Ur((N,C,E,A)=>{let F=O.runKernel(Is,v,I);return A([C,N,F,E]),f&&(F=P(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(c,d,y)}var dD=L({fusedConv2d_:hD});function cD(e,t,n,r,a,s=[1,1],i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={x:o,dy:l},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return O.runKernel(Ad,p,u)}var N1=L({depthwiseConv2dNativeBackpropFilter_:cD});function fD(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={dy:o,filter:n},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},h=O.runKernel(Rd,p,u);return l?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var T1=L({depthwiseConv2dNativeBackpropInput_:fD});function mD({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:u}){if(Fc(O.state.gradientDepth,l)===!1){let I=Wi(e,t,n,r,a,s,i);return o!=null&&(I=J(I,o)),Rc(I,l,p,u)}let h=_(e,"x","depthwiseConv2d","float32"),d=_(t,"filter","depthwiseConv2d","float32"),c=h,f=!1;h.rank===3&&(f=!0,c=P(h,[1,h.shape[0],h.shape[1],h.shape[2]])),$(c.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),$(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),$(c.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),s==null&&(s=[1,1]),$(Hr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),xn("fused depthwiseConv2d",r,i);let m=fp(c.shape,d.shape,n,s,r,i,!0),g;o!=null&&(g=_(o,"bias","fused conv2d"),[g]=wt(g,h),rt(m.outShape,g.shape));let y;p!=null&&(y=_(p,"prelu weights","fused depthwiseConv2d"));let b=(I,N)=>{$(Da(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[C,E,A,F]=N,R=$c(I,A,l),S=T1(E.shape,R,C,n,r,s,i),M=N1(E,R,C.shape,n,r,s,i);if(F!=null){let B=Ac(g,R);return[S,M,B]}return[S,M]},x={x:c,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Ur((I,N,C)=>{let E=O.runKernel(Ss,x,v);return C([N,I,E]),f&&(E=P(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(c,d):Ur((I,N,C,E)=>{let A=O.runKernel(Ss,x,v);return E([N,I,A,C]),f&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(c,d,g)}var gD=L({fusedDepthwiseConv2d_:mD});function yD({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(Fc(O.state.gradientDepth,s)===!1){let F=Le(e,t,n,r);return a!=null&&(F=J(F,a)),Rc(F,s,i,o)}let l=_(e,"a","fused matMul"),p=_(t,"b","fused matMul");[l,p]=wt(l,p);let u=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?p.shape[p.rank-1]:p.shape[p.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=r?p.shape[p.rank-2]:p.shape[p.rank-1],f=l.shape.slice(0,-2),m=p.shape.slice(0,-2),g=lt(f),y=lt(m);$(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${p.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=rt(l.shape.slice(0,-2),p.shape.slice(0,-2)).concat([d,c]),x=n?P(l,[g,u,d]):P(l,[g,d,u]),v=r?P(p,[y,c,h]):P(p,[y,h,c]),I;a!=null&&(I=_(a,"bias","fused matMul"),[I]=wt(I,l),rt(b,I.shape));let N;i!=null&&(N=_(i,"prelu weights","fused matMul"));let C=(F,R)=>{let[S,M,B,U]=R,G=$c(P(F,B.shape),B,s),K,H;if(!n&&!r?(K=Le(G,M,!1,!0),H=Le(S,G,!0,!1)):!n&&r?(K=Le(G,M,!1,!1),H=Le(G,S,!0,!1)):n&&!r?(K=Le(M,G,!1,!0),H=Le(S,G,!1,!1)):(K=Le(M,G,!0,!0),H=Le(G,S,!0,!0)),a!=null){let X=Ac(U,G);return[K,H,X]}else return[K,H]},E={a:x,b:v,bias:I,preluActivationWeights:N},A={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return a==null?Ur((F,R,S)=>{let M=O.runKernel(ks,E,A);return S([F,R,M]),{value:P(M,b),gradFunc:C}})(x,v):Ur((F,R,S,M)=>{let B=O.runKernel(ks,E,A);return M([F,R,B,S]),{value:P(B,b),gradFunc:C}})(x,v,I)}var bD=L({fusedMatMul_:yD});function xD(e){return Ec(e,.54,.46)}var wD=L({hammingWindow_:xD});function vD(e){return Ec(e,.5,.5)}var C1=L({hannWindow_:vD});function kD(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ue(e,s,t)),s+=n;if(r)for(;s<e.size;){let o=s+t-e.size,l=nt([Ue(e,s,t-o),Wn([o],a)]);i.push(l),s+=n}return i.length===0?Br([],[0,t]):P(nt(i),[i.length,t])}var _1=L({frame_:kD});function ID(e,t,n,r,a=C1){r==null&&(r=ey(t));let s=_1(e,t,n),i=z(s,a(t));return Tp(i,r)}var SD=L({stft_:ID});function ND(e,t,n,r,a="bilinear",s=0){let i=_(e,"image","cropAndResize"),o=_(t,"boxes","cropAndResize","float32"),l=_(n,"boxInd","cropAndResize","int32"),p=o.shape[0];$(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${o.shape}.`),$(l.rank===1&&l.shape[0]===p,()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${o.shape}.`),$(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),$(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),$(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);let u={image:i,boxes:o,boxInd:l},h={method:a,extrapolationValue:s,cropSize:r};return O.runKernel(Go,u,h)}var TD=L({cropAndResize_:ND});function CD(e){let t=_(e,"image","flipLeftRight","float32");$(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return O.runKernel(Zo,n,{})}var _D=L({flipLeftRight_:CD});function ED(e){let t=_(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];$(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),$(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Pn(t,a)}var $D=L({grayscaleToRGB_:ED});function AD(e,t,n=0,r=.5){let a=_(e,"image","rotateWithOffset","float32");$(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);let s={image:a},i={radians:t,fillValue:n,center:r};return O.runKernel(Rl,s,i)}var RD=L({rotateWithOffset_:AD});function Vl(e,t,n,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),$(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),$(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),$(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),$(t.rank===1,()=>"scores must be a 1D tensor"),$(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),$(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function FD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppression","float32"),i=_(t,"scores","nonMaxSuppression","float32"),o=Vl(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return O.runKernel(hl,{boxes:s,scores:i},l)}var DD=L({nonMaxSuppression_:FD});function MD(e,t,n){let r=OD(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function OD(e,t,n){return zD(e,t,n||LD)}function LD(e,t){return e>t?1:e<t?-1:0}function zD(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function E1(e,t,n,r,a){return ny(e,t,n,r,a,0)}function $1(e,t,n,r,a,s){return ny(e,t,n,r,a,0,!1,s,!0)}function A1(e,t,n,r,a,s){return ny(e,t,n,r,a,s,!0)}function ny(e,t,n,r,a,s,i=!1,o=!1,l=!1){let p=[];for(let g=0;g<t.length;g++)t[g]>a&&p.push({score:t[g],boxIndex:g,suppressBeginIndex:0});p.sort(mw);let u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&p.length>0;){let g=p.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<a)break;let v=!1;for(let I=h.length-1;I>=x;--I){let N=PD(e,b,h[I]);if(N>=r){v=!0;break}if(g.score=g.score*BD(r,u,N),g.score<=a)break}g.suppressBeginIndex=h.length,v||(g.score===y?(h.push(b),d.push(g.score)):g.score>a&&MD(p,g,mw))}let c=h.length,f=n-c;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=c),m}function PD(e,t,n){let r=e.subarray(t*4,t*4+4),a=e.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),p=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),c=(o-s)*(l-i),f=(h-p)*(d-u);if(c<=0||f<=0)return 0;let m=Math.max(s,p),g=Math.max(i,u),y=Math.min(o,h),b=Math.min(l,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(c+f-x)}function BD(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function mw(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function WD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppressionAsync"),i=_(t,"scores","nonMaxSuppressionAsync"),o=Vl(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),p=l[0],u=l[1],{selectedIndices:h}=E1(p,u,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Je(h,"int32")}var VD=WD;function UD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=Vl(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let p={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},h=O.runKernel(cl,p,u);return{selectedIndices:h[0],selectedScores:h[1]}}var GD=L({nonMaxSuppressionWithScore_:UD});async function HD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=Vl(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let p=await Promise.all([i.data(),o.data()]),u=p[0],h=p[1],{selectedIndices:d,selectedScores:c}=A1(u,h,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Je(d,"int32"),selectedScores:Je(c)}}var jD=HD;function qD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=Vl(i,o,n,r,a,null),p=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:i,scores:o},c={maxOutputSize:p,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:s},f=O.runKernel(dl,d,c);return{selectedIndices:f[0],validOutputs:f[1]}}var KD=L({nonMaxSuppressionPadded_:qD});async function XD(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=Vl(i,o,n,r,a,null),p=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=$1(d,c,p,u,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Je(f,"int32"),validOutputs:ve(m,"int32")}}var ZD=XD;function JD(e,t,n=!1,r=!1){let a=_(e,"images","resizeBilinear");$(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),$(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},p=O.runKernel(Ti,o,l);return i?P(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var R1=L({resizeBilinear_:JD});function YD(e,t,n=!1,r=!1){let a=_(e,"images","resizeNearestNeighbor");$(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),$(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},p=O.runKernel(Ni,o,l);return i?P(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var F1=L({resizeNearestNeighbor_:YD});function QD(e,t="binary",n=!1,r=.5){let a=_(e,"image","threshold"),s=.2989,i=.587,o=.114,l=a.shape[0]*a.shape[1],p=z(Je([r]),255),u,h,d,c;if($(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),$(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),$(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),$(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[u,h,d]=_n(a,[1,1,1],-1);let m=z(u,s),g=z(h,i),y=z(d,o);c=J(J(m,g),y)}else c=e;if(t==="otsu"){let m=ug(se(bc(c),"int32"),dn([]),256);p=eM(m,l)}let f=n?Za(c,p):wn(c,p);return se(z(f,255),"int32")}function eM(e,t){let n=Je([-1]),r=Je([0]),a=Je([0]),s,i,o,l,p,u;for(let h=0;h<e.size-1;h++){s=Ue(e,0,h+1),i=Ue(e,h+1),p=me(ge(s),t),u=me(ge(i),t);let d=ge(z(s,Fs(0,s.size)));o=me(d,ge(s));let c=Wn(i.shape,s.size),f=J(Fs(0,i.size),c),m=z(i,f);l=me(ge(m),ge(i));let g=de(o,l),y=de(o,l),b=z(p,u);a=z(z(b,g),y);let x=wn(a,r);r=sn(x,a,r),n=sn(x,Je([h]),n)}return n}var tM=L({threshold_:QD});function nM(e,t,n="nearest",r="constant",a=0,s){let i=_(e,"image","transform","float32"),o=_(t,"transforms","transform","float32");$(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},p={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return O.runKernel(El,l,p)}var rM=L({transform_:nM});function aM(e,t,n){$(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),$(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);let r=_(e,"a","bandPart");$(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let a=r.shape,[s,i]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),n<0&&(n=i);let o=P(Fs(0,s,1,"int32"),[-1,1]),l=Fs(0,i,1,"int32"),p=de(o,l),u=cr(Za(p,ve(+t,"int32")),da(p,ve(-n,"int32"))),h=bt([s,i],r.dtype);return P(Ot(St(P(r,[-1,s,i])).map(d=>sn(u,d,h))),a)}var sM=L({bandPart_:aM});function iM(e){let t;if(Array.isArray(e)){t=!1,$(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let s=1;s<e.length;++s)$(e[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${a})`)}else t=!0,e=_n(e,e.shape[0],0).map(a=>Ya(a,[0]));$(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(O.tidy(()=>{let s=r[a];if(a>0)for(let i=0;i<a;++i){let o=z(ge(z(n[i],s)),n[i]);s=de(s,o)}return me(s,Ml(s,"euclidean"))}));return t?Ot(n,0):n}var oM=L({gramSchmidt_:iM});function lM(e,t=!1){if($(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return gw(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,p)=>l*p),r=St(P(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(l=>{let[p,u]=gw(l,t);a.push(p),s.push(u)});let i=P(Ot(a,0),e.shape),o=P(Ot(s,0),e.shape);return[i,o]}}function gw(e,t=!1){return O.tidy(()=>{$(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=uc(n),s=Pr(e),i=Br([[1]],[1,1]),o=Pr(i),l=n>=r?r:n;for(let p=0;p<l;++p){let u=s,h=o,d=a;[o,s,a]=O.tidy(()=>{let c=Ue(s,[p,p],[n-p,1]),f=Ml(c),m=Ue(s,[p,p],[1,1]),g=sn(wn(m,0),Br([[-1]]),Br([[1]])),y=de(m,z(g,f)),b=me(c,y);b.shape[0]===1?o=Pr(i):o=nt([i,Ue(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let x=dt(me(Le(g,y),f)),v=Ue(s,[p,0],[n-p,r]),I=z(x,o),N=Fe(o);if(p===0)s=de(v,Le(I,Le(N,v)));else{let A=de(v,Le(I,Le(N,v)));s=nt([Ue(s,[0,0],[p,r]),A],0)}let C=Fe(I),E=Ue(a,[0,p],[n,a.shape[1]-p]);if(p===0)a=de(E,Le(Le(E,o),C));else{let A=de(E,Le(Le(E,o),C));a=nt([Ue(a,[0,0],[n,p]),A],1)}return[o,s,a]}),_e([u,h,d])}return!t&&n>r&&(a=Ue(a,[0,0],[n,r]),s=Ue(s,[0,0],[r,r])),[a,s]})}var uM=L({qr_:lM}),un;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(un||(un={}));function pM(e,t,n=un.SUM_BY_NONZERO_WEIGHTS){let r=_(e,"losses","computeWeightedLoss"),a=null;t!=null&&(a=_(t,"weights","computeWeightedLoss"));let s=a==null?r:z(r,a);if(n===un.NONE)return s;if(n===un.SUM)return ge(s);if(n===un.MEAN){if(a==null)return yt(s);{let i=r.size/a.size,o=me(ge(s),ge(a));return i>1?me(o,ve(i)):o}}if(n===un.SUM_BY_NONZERO_WEIGHTS){if(a==null)return me(ge(s),ve(r.size));{let i=z(a,Bn(r.shape)),o=se(ge(Rs(i,ve(0))),"float32");return me(ge(s),o)}}throw Error(`Unknown reduction: ${n}`)}var ca=L({computeWeightedLoss_:pM});function hM(e,t,n,r=un.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","absoluteDifference"),s=_(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=_(n,"weights","absoluteDifference")),bn(a.shape,s.shape,"Error in absoluteDifference: ");let o=Ct(de(a,s));return ca(o,i,r)}var dM=L({absoluteDifference_:hM});function cM(e,t,n,r,a=un.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","cosineDistance"),i=_(t,"predictions","cosineDistance"),o=null;r!=null&&(o=_(r,"weights","cosineDistance")),bn(s.shape,i.shape,"Error in cosineDistance: ");let l=ve(1),p=de(l,ge(z(s,i),n,!0));return ca(p,o,a)}var fM=L({cosineDistance_:cM});function mM(e,t,n,r=un.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","hingeLoss"),s=_(t,"predictions","hingeLoss"),i=null;n!=null&&(i=_(n,"weights","hingeLoss")),bn(a.shape,s.shape,"Error in hingeLoss: ");let o=ve(1);a=de(z(ve(2),a),o);let l=Ye(de(o,z(a,s)));return ca(l,i,r)}var gM=L({hingeLoss_:mM});function yM(e,t,n,r=1,a=un.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","huberLoss"),i=_(t,"predictions","huberLoss"),o=null;n!=null&&(o=_(n,"weights","huberLoss")),bn(s.shape,i.shape,"Error in huberLoss: ");let l=ve(r),p=Ct(de(i,s)),u=zl(p,l),h=de(p,u),d=J(z(ve(.5),tt(u)),z(l,h));return ca(d,o,a)}var bM=L({huberLoss_:yM});function xM(e,t,n,r=1e-7,a=un.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","logLoss"),i=_(t,"predictions","logLoss"),o=null;n!=null&&(o=_(n,"weights","logLoss")),bn(s.shape,i.shape,"Error in logLoss: ");let l=ve(1),p=ve(r),u=dt(z(s,Un(J(i,p)))),h=z(de(l,s),Un(J(de(l,i),p))),d=de(u,h);return ca(d,o,a)}var wM=L({logLoss_:xM});function vM(e,t,n,r=un.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","meanSquaredError"),s=_(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=_(n,"weights","meanSquaredError")),bn(a.shape,s.shape,"Error in meanSquaredError: ");let o=Nc(a,s);return ca(o,i,r)}var kM=L({meanSquaredError_:vM});function IM(e,t){let n=_(e,"labels","sigmoidCrossEntropyWithLogits"),r=_(t,"logits","sigmoidCrossEntropyWithLogits");bn(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=Ye(r),s=z(r,n),i=xp(fn(dt(Ct(r))));return J(de(a,s),i)}function SM(e,t,n,r=0,a=un.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"multiClassLabels","sigmoidCrossEntropy"),i=_(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","sigmoidCrossEntropy")),bn(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let p=ve(r),u=ve(1),h=ve(.5);s=J(z(s,de(u,p)),z(h,p))}let l=IM(s,i);return ca(l,o,a)}var NM=L({sigmoidCrossEntropy_:SM});function TM(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Ur((r,a,s)=>{let i=cc(a,[n],!0),o=de(se(a,"float32"),i);s([r,o]);let l=dt(z(o,r));return{value:ge(l,[n]),gradFunc:(p,u)=>{let[h,d]=u,c=As(p.shape,[n]);return[z(P(p,c),de(se(h,"float32"),fn(d))),z(P(p,c),de(fn(d),se(h,"float32")))]}}})(e,t)}function CM(e,t,n,r=0,a=un.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"onehotLabels","softmaxCrossEntropy"),i=_(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","softmaxCrossEntropy")),bn(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let p=ve(r),u=ve(1),h=ve(s.shape[1]);s=J(z(s,de(u,p)),me(p,h))}let l=TM(s,i);return ca(l,o,a)}var _M=L({softmaxCrossEntropy_:CM});function EM(e,t,n,r){let a=_(e,"indices","sparseFillEmptyRows","int32"),s=_(t,"values","sparseFillEmptyRows"),i=_(n,"denseShape","sparseFillEmptyRows","int32"),o=_(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},p=O.runKernel(tp,l);return{outputIndices:p[0],outputValues:p[1],emptyRowIndicator:p[2],reverseIndexMap:p[3]}}var $M=L({sparseFillEmptyRows_:EM});function AM(e,t,n){let r=_(e,"inputIndices","sparseReshape","int32"),a=_(t,"inputShape","sparseReshape","int32"),s=_(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=O.runKernel(Tl,i);return{outputIndices:o[0],outputShape:o[1]}}var RM=L({sparseReshape_:AM});function FM(e,t,n){let r=_(e,"data","sparseSegmentMean"),a=_(t,"indices","sparseSegmentMean","int32"),s=_(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(np,i)}var DM=L({sparseSegmentMean_:FM});function MM(e,t,n){let r=_(e,"data","sparseSegmentSum"),a=_(t,"indices","sparseSegmentSum","int32"),s=_(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(rp,i)}var OM=L({sparseSegmentSum_:MM});function LM(e,t,n,r,a,s,i,o){let l=_(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let p=_(t,"dataSplits","stringNGrams");if(p.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:p},d=O.runKernel(sp,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}var zM=L({stringNGrams_:LM});function PM(e,t,n=!0){let r=_(e,"input","stringSplit","string"),a=_(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=O.runKernel(ip,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var BM=L({stringSplit_:PM});function WM(e,t){let n=_(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return O.runKernel(op,a,r)}var VM=L({stringToHashBucketFast_:WM}),D1={fft:Np,ifft:yo,rfft:Tp,irfft:Sc},M1={hammingWindow:wD,hannWindow:C1,frame:_1,stft:SD},wr={flipLeftRight:_D,grayscaleToRGB:$D,resizeNearestNeighbor:F1,resizeBilinear:R1,rotateWithOffset:RD,cropAndResize:TD,nonMaxSuppression:DD,nonMaxSuppressionAsync:VD,nonMaxSuppressionWithScore:GD,nonMaxSuppressionWithScoreAsync:jD,nonMaxSuppressionPadded:KD,nonMaxSuppressionPaddedAsync:ZD,threshold:tM,transform:rM},ry={bandPart:sM,gramSchmidt:oM,qr:uM},O1={absoluteDifference:dM,computeWeightedLoss:ca,cosineDistance:fM,hingeLoss:gM,huberLoss:bM,logLoss:wM,meanSquaredError:kM,sigmoidCrossEntropy:NM,softmaxCrossEntropy:_M},L1={sparseFillEmptyRows:$M,sparseReshape:RM,sparseSegmentMean:DM,sparseSegmentSum:OM},z1={stringNGrams:zM,stringSplit:BM,stringToHashBucketFast:VM},ne={};Ee(ne,{Serializable:()=>P1,SerializationMap:()=>ds,registerClass:()=>B1});var P1=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},ds=class{constructor(){this.classNameMap={}}static getMap(){return ds.instance==null&&(ds.instance=new ds),ds.instance}static register(e){ds.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function B1(e){$(e.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),$(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ds.register(e)}var fa=class extends P1{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(s)}else this.applyGradients(a);return _e(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return U0(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(fa,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var ay=class extends fa{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:W(()=>He(r).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:W(()=>He(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;W(()=>{let l=J(z(i,this.rho),z(tt(s),1-this.rho)),p=z(me(en(J(o,this.epsilon)),en(J(i,this.epsilon))),s),u=J(z(o,this.rho),z(tt(p),1-this.rho));i.assign(l),o.assign(u);let h=J(z(p,-this.learningRate),r);r.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(e=>e.variable)),_e(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},sy=class extends fa{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:W(()=>Wn(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let s=this.accumulatedGrads[n].variable;W(()=>{let i=J(s,tt(a));s.assign(i);let o=J(z(me(a,en(J(i,O.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},iy=class extends fa{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],W(()=>{this.accBeta1=ve(t).variable(),this.accBeta2=ve(n).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);W(()=>{let n=de(1,this.accBeta1),r=de(1,this.accBeta2);t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:W(()=>He(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${a}/v`,variable:W(()=>He(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let p=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,h=J(z(p,this.beta1),z(l,1-this.beta1)),d=J(z(u,this.beta2),z(tt(l),1-this.beta2)),c=me(h,n),f=me(d,r);p.assign(h),u.assign(d);let m=J(z(me(c,J(en(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),W(()=>{this.accBeta1.assign(ua(this.beta1,this.iterations_+1)),this.accBeta2.assign(ua(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},oy=class extends fa{constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],W(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(t).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);W(()=>{let n=de(1,this.accBeta1),r=me(-this.learningRate,J(z(this.iteration,this.decay),1));t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:He(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${a}/v`,variable:He(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let p=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,h=J(z(p,this.beta1),z(l,1-this.beta1)),d=z(u,this.beta2),c=Ct(l),f=jr(d,c);p.assign(h),u.assign(f);let m=J(z(me(r,n),me(h,J(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Dc=class extends fa{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let a=O.registeredVariables[t];W(()=>{let s=J(z(this.c,r),a);a.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ft(ve(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},ly=class extends Dc{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=ve(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:W(()=>He(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&W(()=>{let i,o=J(z(this.m,a),s);this.useNesterov?i=J(z(this.c,J(s,z(o,this.m))),r):i=J(z(this.c,o),r),a.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},uy=class extends fa{constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=O.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:W(()=>He(r).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:W(()=>He(r).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:W(()=>He(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;W(()=>{let l=J(z(i,this.decay),z(tt(s),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[n].variable,u=J(z(p,this.decay),z(s,1-this.decay)),h=me(z(s,this.learningRate),en(de(l,J(tt(u),this.epsilon)))),d=J(z(o,this.momentum),h);i.assign(l),p.assign(u),o.assign(d);let c=de(r,d);r.assign(c)}else{let p=J(z(i,this.decay),z(tt(s),1-this.decay)),u=J(z(o,this.momentum),me(z(s,this.learningRate),en(J(p,this.epsilon))));i.assign(p),o.assign(u);let h=de(r,u);r.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},UM=[ay,sy,iy,oy,ly,uy,Dc];function GM(){for(let e of UM)B1(e)}var Qt={};Ee(Qt,{browserFiles:()=>JM,browserHTTPRequest:()=>nO,concatenateArrayBuffers:()=>qm,copyModel:()=>ZE,decodeWeights:()=>m0,encodeWeights:()=>NE,fromMemory:()=>aO,fromMemorySync:()=>H1,getLoadHandlers:()=>OE,getModelArtifactsForJSON:()=>Km,getModelArtifactsForJSONSync:()=>y0,getModelArtifactsInfoForJSON:()=>cp,getSaveHandlers:()=>ME,getWeightSpecs:()=>b0,http:()=>hy,isHTTPScheme:()=>Xf,listModels:()=>KE,loadWeights:()=>YM,moveModel:()=>JE,registerLoadRouter:()=>DE,registerSaveRouter:()=>FE,removeModel:()=>XE,weightsLoaderFactory:()=>V1,withSaveHandler:()=>sO,withSaveHandlerSync:()=>iO});var HM="model",jM=".json",qM=".weights.bin";function yw(e){return new Promise(t=>setTimeout(t)).then(e)}var xo=class{constructor(e){if(!j().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(xo.URL_SCHEME)&&(e=e.slice(xo.URL_SCHEME.length)),(e==null||e.length===0)&&(e=HM),this.modelJsonFileName=e+jM,this.weightDataFileName=e+qM}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=g0(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await yw(()=>s.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await yw(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:cp(e)}}}};xo.URL_SCHEME="downloads://";var KM=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let a=JSON.parse(r.target.result),s=a.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=Km(a,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(a).then(s=>[t,qm(s)])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=s=>{let i=s.target.result;n(i)},a.onerror=s=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>fw(a.name)),r={};for(let a of e)a.paths.forEach(s=>{let i=fw(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},XM=e=>j().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(xo.URL_SCHEME)?ZM(e.slice(xo.URL_SCHEME.length)):null;It.registerSaveRouter(XM);function ZM(e="model"){return new xo(e)}function JM(e){return new KM(e)}function bw(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let a=0,s=l=>(l.then(p=>{let u=n+ ++a/e.length*(r-n);return t(u),p}),l);function i(l){$(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,p){$(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),$(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),$(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}return Promise.all(e.map(s))}async function W1(e,t){t==null&&(t={});let n=t.fetchFunc==null?j().platform.fetch:t.fetchFunc,r=e.map(p=>n(p,t.requestInit,{isBinary:!0})),a=0,s=.5,i=(t.onProgress==null?await Promise.all(r):await bw(r,t.onProgress,a,s)).map(p=>p.arrayBuffer()),o=.5,l=1;return t.onProgress==null?await Promise.all(i):await bw(i,t.onProgress,o,l)}async function YM(e,t="",n,r){return V1(a=>W1(a,{requestInit:r}))(e,t,n)}function V1(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((c,f)=>{let m=0;c.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=Uf[y]*lt(g.shape),x=()=>{a[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((v,I)=>{v===g.name&&(x(),i[I]=!0)}):x(),o.push(g.name),m+=b})}),!i.every(c=>c)){let c=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${c.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((c,f,m)=>(f&&c.push(m),c),[]),p=[];l.forEach(c=>{t[c].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;p.push(m)})});let u=await e(p),h={},d=0;return l.forEach(c=>{let f=t[c].paths.length,m=0;for(let x=0;x<f;x++)m+=u[d+x].byteLength;let g=new ArrayBuffer(m),y=new Uint8Array(g),b=0;for(let x=0;x<f;x++){let v=new Uint8Array(u[d+x]);y.set(v,b),b+=v.byteLength}s[c].forEach(x=>{let v=g.slice(x.groupOffset,x.groupOffset+x.sizeBytes),I=m0(v,[x.manifestEntry]);for(let N in I)h[N]=I[N]}),d+=f}),h}}var QM="application/octet-stream",eO="application/json",py=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?($(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=j().platform.fetch,$(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&$(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=g0(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:eO}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:QM}),"model.weights.bin");let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:cp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Km(t,a=>this.loadWeights(a))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=tO(t),a=this.weightPathPrefix||n,s=b0(e),i=[],o=[];for(let p of e)for(let u of p.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(u)):i.push(a+u+r);this.weightUrlConverter&&i.push(...await Promise.all(o));let l=await W1(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,qm(l)]}};py.URL_SCHEME_REGEX=/^https?:\/\//;function tO(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function Xf(e){return e.match(py.URL_SCHEME_REGEX)!=null}var U1=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>Xf(r)):n=Xf(e),n)return hy(e,t)}return null};It.registerSaveRouter(U1);It.registerLoadRouter(U1);function hy(e,t){return new py(e,t)}function nO(e,t){return hy(e,t)}var wf=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},G1=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},rO=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function aO(e,t,n,r){let a=arguments;return new rO(H1(...a))}function H1(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new wf(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wf({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wf({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function sO(e){return new G1(e)}function iO(e){return new G1(e)}var j1={};Ee(j1,{confusionMatrix:()=>lO});function oO(e,t,n){let r=_(e,"labels","confusionMatrix"),a=_(t,"predictions","confusionMatrix");$(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),$(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),$(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),$(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),$(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=fo(se(r,"int32"),n),i=fo(se(a,"int32"),n),o=Fe(s),l=Le(o,i);return se(l,"int32")}var lO=L({confusionMatrix_:oO}),Cp={};Ee(Cp,{fromPixels:()=>mO,fromPixelsAsync:()=>cO,toPixels:()=>fO});var os;function q1(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Wh(Bh,O.backendName)!=null){let d={pixels:e},c={numChannels:t};return O.runKernel(Bh,d,c)}let[l,p]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(i)u=e.getContext("2d").getImageData(0,0,l,p).data;else if(r||n)u=e.data;else if(s||a||o){if(os==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")os=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else os=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});os.canvas.width=l,os.canvas.height=p,os.drawImage(e,0,0,l,p),u=os.getImageData(0,0,l,p).data}let h;if(t===4)h=new Int32Array(u);else{let d=l*p;h=new Int32Array(d*t);for(let c=0;c<d;c++)for(let f=0;f<t;++f)h[c*t+f]=u[c*4+f]}return Tc(h,[p,l,t],"int32")}function uO(e){return e!=null&&e.data instanceof Uint8Array}function pO(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function hO(e){return e!=null&&e.width!==0&&e.height!==0}function dO(e){return pO()&&!(e instanceof ImageBitmap)&&hO(e)&&!uO(e)}async function cO(e,t=3){let n=null;if(j().getBool("WRAP_TO_IMAGEBITMAP")&&dO(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return q1(n,t)}async function fO(e,t){let n=_(e,"img","toPixels");if(!(e instanceof Pe)){let p=n;n=se(p,"int32"),p.dispose()}if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,a]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(a*r*4);for(let p=0;p<r*a;++p){let u=[0,0,0,255];for(let d=0;d<s;d++){let c=i[p*s+d];if(n.dtype==="float32"){if(c<0||c>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${c}.`)}else if(n.dtype==="int32"&&(c<0||c>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${c}.`);s===1?(u[0]=c*o,u[1]=c*o,u[2]=c*o):u[d]=c*o}let h=p*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(t!=null){t.width=a,t.height=r;let p=t.getContext("2d"),u=new ImageData(l,a,r);p.putImageData(u,0,0)}return n!==e&&n.dispose(),l}var mO=L({fromPixels_:q1}),dy={};Ee(dy,{prepareAndValidate:()=>K1});function K1(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(lt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let h=0;h<a.length-1;++h)i*=a[h];let o=e.shape,l=a.slice();l.pop();let p=1;for(let h=s;h<n;++h)p*=o[h],l.push(o[h]);let u=[...$o(e.shape).map(h=>h/p),1].slice(0,s);return[l,i,p,u]}var Lt={};Ee(Lt,{assertParamsValid:()=>yO,computeFlatOffset:()=>kO,computeOutShape:()=>xO,getNormalizedAxes:()=>wO,isSliceContinous:()=>vO,maskToAxes:()=>bO,parseSliceParams:()=>rk,sliceInfo:()=>IO,startForAxis:()=>tk,startIndicesWithElidedDims:()=>Y1,stopForAxis:()=>nk,stopIndicesWithElidedDims:()=>Q1,stridesForAxis:()=>ek,stridesWithElidedDims:()=>X1});var Zf=-2,gO=-1;function yO(e,t,n){let r=e.shape.length;$(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),$(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)$(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function bO(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function xO(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function X1(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Z1(e,t,n){return n<=e?n:n-(t-1)}function J1(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function wO(e,t,n,r,a,s,i,o,l){let p=e.length,u=new Array(p),h=new Array(p),d=new Array(p);if(t.length&&n>0){let c=t[0],f=n+1;u=Y1(i,c,f,r,e),h=Q1(o,c,f,a,e),d=X1(s,c,f,e)}else for(let c=0;c<p;c++)u[c]=tk(i,r,s,e,c,l),h[c]=nk(o,a,s,e,c,l),d[c]=ek(s,c,l);return{begin:u,end:h,strides:d}}function Y1(e,t,n,r,a){let s=[...a],i=J1(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=Z1(t,n,o),p=r[l];e&1<<l&&(p=0),s[o]=p}return s}function Q1(e,t,n,r,a){let s=[...a],i=J1(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=Z1(t,n,o),p=r[l];e&1<<l&&(p=Number.MAX_SAFE_INTEGER),s[o]=p}for(let o=0;o<s.length;o++){let l=a[o];s[o]<0&&(s[o]+=l),s[o]=Cu(0,s[o],a[o])}return s}function ek(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function tk(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=Cu(0,i,l-1),i}function nk(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),o>0?i=Cu(0,i,l):i=Cu(-1,i,l-1),i}function vO(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function kO(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function rk(e,t,n){let r,a=e.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(i=>{$(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(a).fill(-1):typeof n=="number"?s=[n,...new Array(a-1).fill(-1)]:n.length<a?s=n.concat(new Array(a-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:($(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,s]}function IO(e,t,n,r,a,s,i,o,l){let p;if(r==null?(p=new Array(t.length),p.fill(1)):p=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,h={dims:p.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:p.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)u&&1<<b&o&&h.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};SO(h,d);let c=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let x=!!(d.shrinkAxisMask&1<<b),v=e[b];if(v===-1){g.push(x?1:-1);continue}let I=[d.beginMask&1<<b,d.endMask&1<<b],N=[d.strides[b]>0?0:-1,d.strides[b]>0?v:v-1];if(x&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[b]===1;let C=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(x){let R=d.begin[b]<0?v+d.begin[b]:d.begin[b];if(d.begin[b]=R,d.end[b]=d.begin[b]+1,R<0||R>=v)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=xw(d.begin[b],0,d.strides[b],v,I,N),d.end[b]=xw(d.end[b],1,d.strides[b],v,I,N);let F=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===v;c=c&&F,f=f&&(b===0&&d.strides[b]===1||F)}else c=c&&d.strides[b]===1&&C,f=f&&(b===0&&d.strides[b]===1||C);let E,A=!1;if(d.beginValid&&d.endValid?(E=d.end[b]-d.begin[b],A=!0):x?(E=1,A=!0):C&&v>=0&&(d.strides[b]<0?E=-v:E=v,A=!0),A){let F;E===0||E<0!=d.strides[b]<0?F=0:F=Math.trunc(E/d.strides[b])+(E%d.strides[b]!==0?1:0),g.push(F)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){let x=d.finalShapeGatherIndices[b];x>=0?y.push(g[x]):x===Zf&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>d.finalShapeGatherIndices[x]!==Zf),finalShape:y,isIdentity:c,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function SO(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Zf),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(gO),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function xw(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var NO="4.2.0",ak=class{static sgd(e){return new Dc(e)}static momentum(e,t,n=!1){return new ly(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new uy(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new iy(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new ay(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new oy(e,t,n,r,a)}static adagrad(e,t=.1){return new sy(e,t)}},ps=ak,TO=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e())();function cy(){return new Promise(e=>TO(()=>e()))}var T={};Ee(T,{ERF_A1:()=>WO,ERF_A2:()=>VO,ERF_A3:()=>UO,ERF_A4:()=>GO,ERF_A5:()=>HO,ERF_P:()=>BO,PARALLELIZE_THRESHOLD:()=>fy,RowPartitionType:()=>Mr,SELU_SCALE:()=>ik,SELU_SCALEALPHA:()=>sk,applyActivation:()=>Rc,assertAndGetBroadcastShape:()=>rt,assertAxesAreInnerMostDims:()=>DA,assertParamsConsistent:()=>CO,assignToTypedArray:()=>JO,axesAreInnerMostDims:()=>Ig,calculateShapes:()=>w1,checkEinsumDimSizes:()=>r3,checkPadOnDimRoundingMode:()=>xn,combineLocations:()=>z0,combineRaggedTensorToTensorShapes:()=>EO,complexWithEvenIndex:()=>KO,complexWithOddIndex:()=>XO,computeConv2DInfo:()=>fp,computeConv3DInfo:()=>$0,computeDefaultPad:()=>ag,computeDilation2DInfo:()=>D$,computeOptimalWindowSize:()=>FO,computeOutAndReduceShapes:()=>P0,computeOutShape:()=>_O,computePool2DInfo:()=>E0,computePool3DInfo:()=>M$,convertConv2DDataFormat:()=>A0,decodeEinsumEquation:()=>t3,eitherStridesOrDilationsAreOne:()=>Hr,expandShapeToKeepDim:()=>As,exponent:()=>QO,exponents:()=>YO,fromStringArrayToUint8:()=>S3,fromUint8ToStringArray:()=>I3,getAxesPermutation:()=>B0,getBroadcastDims:()=>O0,getComplexWithIndex:()=>ZO,getEinsumComputePath:()=>a3,getEinsumPermutation:()=>n3,getFusedBiasGradient:()=>Ac,getFusedDyActivation:()=>$c,getImageCenter:()=>DO,getInnerMostAxes:()=>MA,getPermuted:()=>OO,getRaggedRank:()=>AO,getReductionAxes:()=>Et,getReshaped:()=>MO,getReshapedPermuted:()=>LO,getRowPartitionTypesHelper:()=>$O,getSliceBeginCoords:()=>zO,getSliceSize:()=>PO,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>l3,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>u3,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>p3,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>c3,getSparseReshapeInputOutputMismatchErrorMessage:()=>m3,getSparseReshapeInputOutputMultipleErrorMessage:()=>f3,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>h3,getSparseReshapeNegativeOutputDimErrorMessage:()=>d3,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>x3,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>g3,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>y3,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>b3,getUndoAxesPermutation:()=>Sg,isIdentityPermutation:()=>s3,log:()=>X_,mergeRealAndImagArrays:()=>jO,prepareAndValidate:()=>K1,prepareSplitSize:()=>o3,segment_util:()=>ok,shouldFuse:()=>Fc,slice_util:()=>Lt,splitRealAndImagArrays:()=>qO,stridesOrDilationsArePositive:()=>Es,tupleValuesAreOne:()=>Da,upcastType:()=>tr,validateDefaultValueShape:()=>RO,validateInput:()=>Yg,validateUpdateShape:()=>Jg,warn:()=>Sa});function CO(e,t){let n=e[0].length;e.forEach((a,s)=>{$(a.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),$(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,s)=>{for(let i=0;i<n;i++)$(i===t||a[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function _O(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Mr;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Mr||(Mr={}));function EO(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function $O(e){let t={FIRST_DIM_SIZE:Mr.FIRST_DIM_SIZE,VALUE_ROWIDS:Mr.VALUE_ROWIDS,ROW_LENGTHS:Mr.ROW_LENGTHS,ROW_SPLITS:Mr.ROW_SPLITS,ROW_LIMITS:Mr.ROW_LIMITS,ROW_STARTS:Mr.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function AO(e){return e.length===0?0:e[0]===Mr.FIRST_DIM_SIZE?e.length-1:e.length}function RO(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let s=e[a],i=t[a+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${s} but ragged tensor input.flatValues.shape[${a-e.length}] = ${i}`)}}var fy=30;function FO(e){return e<=fy?e:Lh(e,Math.floor(Math.sqrt(e)))}function DO(e,t,n){let r=n*(typeof e=="number"?e:e[0]),a=t*(typeof e=="number"?e:e[1]);return[r,a]}function MO(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)a=a.concat([e[i+1]/t[i],t[i]]);a=a.concat(e.slice(s+1))}return a}function OO(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):a.push(i);r.push(...a),r.push(0),r.push(...s)}return r}function LO(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function zO(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function PO(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var sk=1.7580993408473768,ik=1.0507009873554805,BO=.3275911,WO=.254829592,VO=-.284496736,UO=1.421413741,GO=-1.453152027,HO=1.061405429;function jO(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function qO(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function KO(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function XO(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function ZO(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function JO(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function YO(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function QO(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var vf="->",e3=/->/g,ww=",",vw="...";function t3(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(e3,"").length)/vf.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${vf}").`);let[r,a]=e.split(vf);$(r.indexOf(vw)===-1,()=>`The ellipsis notation ("${vw}") is not supported yet.`);let s=r.split(ww),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let c=a[d];if(!s.some(f=>f.indexOf(c)!==-1))throw new Error(`Output subscripts contain the label ${c} not present in the input subscripts.`);o.indexOf(c)===-1&&o.push(c)}for(let d=0;d<r.length;++d){let c=r[d];o.indexOf(c)===-1&&c!==ww&&o.push(c)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let c=0;c<s[d].length;++c)l[d].push(o.indexOf(s[d][c]))}let p=o.length,u=a.length,h=[];for(let d=u;d<p;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function n3(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function r3(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let s=n[a].shape;for(let i=0;i<t[a].length;++i)r[t[a][i]]===void 0?r[t[a][i]]=s[i]:$(r[t[a][i]]===s[i],()=>`Expected dimension ${r[t[a][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function a3(e,t){let n=e,r=[],a=0;e.length===0&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=i3(t,o);for(let p of l)s.indexOf(p)===-1&&(r[i].push(p),s.push(p))}return{path:n,steps:r}}function s3(e){return e.every((t,n)=>t===n)}function i3(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function o3(e,t,n=0){let r=[];if(typeof t=="number")$(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);$(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}$(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function l3(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function u3(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function p3(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function h3(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function d3(e,t){return`size ${e} must be non-negative, not ${t}`}function c3(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function f3(e,t){let n=lt(e),r=lt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function m3(e,t){let n=lt(e),r=lt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function g3(){return"segment ids must be >= 0"}function y3(){return"segment ids are not increasing"}function b3(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function x3(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var ok={};Ee(ok,{collectGatherOpShapeInfo:()=>k3,computeOutShape:()=>v3,segOpComputeOptimalWindowSize:()=>w3});function w3(e,t){let n=!1,r;for(e<=fy?(r=e,n=!0):r=Lh(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=Lh(e,r+1);return r}function v3(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function k3(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);let i=e.shape[n],o=[],l=1,p=1,u=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),p*=e.shape[h];for(let h=r;h<a;h++)o.push(t.shape[h]);for(let h=n+1;h<s;h++)o.push(e.shape[h]),u*=e.shape[h];return{batchSize:l,sliceSize:u,outerSize:p,dimSize:i,outputShape:o}}function I3(e){try{return e.map(t=>Uh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function S3(e){return e.map(t=>hp(t))}var qr={};Ee(qr,{nonMaxSuppressionV3Impl:()=>E1,nonMaxSuppressionV4Impl:()=>$1,nonMaxSuppressionV5Impl:()=>A1,whereImpl:()=>y1});GM();var lk={kernelName:Ao,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,Ui(se(n,"float32"),-1))}}},N3={kernelName:Ro,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=tt(se(n,"float32")),a=en(de(ve(1),r));return dt(me(e,a))}}}},T3={kernelName:Fo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=en(de(tt(se(n,"float32")),1));return me(e,r)}}}},C3={kernelName:Ha,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=e,i=Et(n.shape,a);return i.length>0&&(s=ge(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Et(r.shape,a);return i.length>0&&(s=ge(s,i)),P(s,r.shape)}}}},_3={kernelName:Ws,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},E3={kernelName:Vs,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>He(n)}}},$3={kernelName:ju,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>He(n)}}},A3={kernelName:Oo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,en(de(ve(1),tt(se(n,"float32")))))}}},R3={kernelName:Lo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=en(J(ve(1),tt(se(n,"float32"))));return me(e,r)}}}},F3={kernelName:Bo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=J(tt(n),tt(r)),i=z(e,me(r,s)),o=Et(n.shape,a);return o.length>0&&(i=ge(i,o)),P(i,n.shape)},b:()=>{let s=J(tt(n),tt(r)),i=dt(z(e,me(n,s))),o=Et(r.shape,a);return o.length>0&&(i=ge(i,o)),P(i,r.shape)}}}},D3={kernelName:zo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,J(tt(se(n,"float32")),1))}}},M3={kernelName:Po,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,de(ve(1),tt(se(n,"float32"))))}}};function O3(e,t,n,r,a,s){let i=_(e,"dy","avgPool3dGrad"),o=_(t,"input","avgPool3dGrad"),l=i,p=o,u=!1;o.rank===4&&(u=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),$(p.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),xn("avgPool3dGrad",a,s);let h={dy:l,input:p},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},c=O.runKernel(Id,h,d);return u?P(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var L3=L({avgPool3dGrad_:O3}),z3={kernelName:qu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>L3(e,r,a,s,i,o)}}};function P3(e,t,n,r,a){let s=_(e,"dy","avgPoolGrad"),i=_(t,"input","avgPoolGrad");$(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,p=!1;i.rank===3&&(p=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),$(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let u={dy:l,input:o},h={filterSize:n,strides:r,pad:a},d=O.runKernel(kd,u,h);return p?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var B3=L({avgPoolGrad_:P3}),W3={kernelName:Us,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>B3(e,r,a,s,i)}}},V3={kernelName:Gs,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>Le(e,a,!1,!0),b:()=>Le(r,e,!0,!1)}:!s&&i?{a:()=>Le(e,a,!1,!1),b:()=>Le(e,r,!0,!1)}:s&&!i?{a:()=>Le(a,e,!1,!0),b:()=>Le(r,e,!1,!1)}:{a:()=>Le(a,e,!0,!0),b:()=>Le(e,r,!0,!0)}}},U3={kernelName:Wo,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>kp(e,r,a)}}},G3={kernelName:r0,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(a[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ge(e,o,!0)}}},H3={kernelName:Hs,gradFunc:e=>({x:()=>e.clone()})},j3={kernelName:js,gradFunc:e=>({x:()=>He(e)})},q3={kernelName:ja,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>sn(cr(da(r,a),Za(r,s)),e,He(e))}}},K3={kernelName:Ku,inputsToSave:["x"],gradFunc:lk.gradFunc},X3={kernelName:Vo,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,s=mr(a,t[0].shape)[0],i=r.map(o=>o[s]);return _n(e,i,s).map(o=>()=>o)}},Z3={kernelName:qs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return $(Da(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>mg(r.shape,e,a,i,o,l),filter:()=>ty(r,e,a.shape,i,o,l)}}},J3={kernelName:Ks,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>cn(e,a,s,i,o,1,l),filter:()=>ty(e,r,a.shape,s,i,o,l)}}};function Y3(e,t,n,r,a){let s=e;e.rank===4&&(s=P(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),$(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),$(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),$(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),$(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),$(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return O.runKernel(_d,o,l)}var Q3=L({conv3DBackpropFilter_:Y3}),eL={kernelName:Xu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;$(Da(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>D0(i.shape,e,o,a,s),filter:()=>Q3(i,e,o.shape,a,s)}}},tL={kernelName:Xs,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(dt(vc(se(n,"float32"))),e)}}},nL={kernelName:Zs,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(kc(se(n,"float32")),e)}}},rL={kernelName:Js,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let o=B0([a],r.rank),l=lc(e,a,s,!i);return o!=null&&(l=Fe(l,o)),l}}}},aL={kernelName:Ys,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=r??[1,1];$(Da(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,p]=t;return $(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),$(p.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),$(l.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),$(Hr(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),xn("depthwiseConv2d",s,i),{x:()=>T1(l.shape,e,p,a,s,o,i),filter:()=>N1(l,e,p.shape,a,s,o,i)}}},sL={kernelName:Zu,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>O.runKernel(zh,s,n),filter:()=>O.runKernel(Ph,i,n)}}},iL={kernelName:ei,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>O.runKernel(Md,r)}}},oL={kernelName:jo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(fn(dt(tt(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,r)}}},lL={kernelName:ti,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},uL={kernelName:Ko,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>P(e,n.shape)}}},pL={kernelName:Xo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,fn(n))}}},hL={kernelName:ni,gradFunc:e=>({x:()=>He(e)})},dL={kernelName:ri,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=me(e,se(r,"float32")),i=Et(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Et(r.shape,a);i.length>0&&(s=P(ge(s,i),r.shape));let o=tt(r);return dt(me(s,se(o,"float32")))}}}},cL={kernelName:ai,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=o??ve(1),p=Et(s.shape,a.shape),u=[];if(s.rank===1){for(let m=0;m<a.shape.length-1;++m)u.push(a.shape[m]);u.push(1)}let h=de(a,s),d=z(e,l),c=xc(J(i,ve(r))),f=z(z(z(c,c),c),ve(-.5));return{x:()=>s.rank===1?P(z(z(e,Pn(P(c,[1,1,1,s.shape[0]]),u)),l),a.shape):P(z(z(e,c),l),a.shape),mean:()=>{let m=z(z(c,ve(-1)),d);return s.rank===1&&(m=ge(m,p)),P(m,s.shape)},variance:()=>{let m=z(z(f,h),d);return s.rank===1&&(m=ge(m,p)),P(m,s.shape)},scale:()=>{let m=z(h,c),g=z(e,m);return s.rank===1&&(g=ge(g,p)),P(g,s.shape)},offset:()=>{let m=e;return s.rank===1&&(m=ge(m,p)),P(m,s.shape)}}}},fL={kernelName:Jo,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s}=n,i=mr(s,r.shape)[0];return{x:()=>{let o=r.shape,l=a.size,p=o.slice(0,i),u=p.length,h=o.slice(s,o.length).slice(1),d=h.length,c=kw(0,u),f=kw(u+1,u+1+d),m=Iw([p,[l],h]),g=P(e,m),y=P(a,[l]),b=Iw([[u],c,f]),x=Fe(g,b),v=_c(x,y,r.shape[i]),I=Sg(b);return v=Fe(v,I),v},indices:()=>a}}};function kw(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Iw(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var mL={kernelName:si,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>He(n),b:()=>He(r)}}},gL={kernelName:ii,gradFunc:e=>({x:()=>se(e,"float32")})},yL={kernelName:el,gradFunc:e=>({x:()=>He(e)})},bL={kernelName:tl,gradFunc:e=>({x:()=>He(e)})},xL={kernelName:oi,gradFunc:e=>({x:()=>He(e)})},wL={kernelName:li,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=wn(r,0);return{x:()=>sn(s,e,z(e,a))}}},vL={kernelName:al,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,J(n,1))}}},kL={kernelName:ui,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,se(n,"float32"))}}},IL={kernelName:s0,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let s=fn(r);return de(e,z(ge(e,a,!0),s))}}}};function SL(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return O.runKernel(Bd,o,l)}var NL=L({localResponseNormalizationBackprop_:SL}),TL={kernelName:Yu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>NL(r,a,e,s,i,o,l)}}};function uk(e,t,n,r){return t.rank<n.rank&&(t=P(t,As(t.shape,r))),e.rank<n.rank&&(e=P(e,As(e.shape,r))),{x:()=>z(e,se(Vn(n,t),e.dtype))}}var Sw={kernelName:pi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=mr(a,s.shape),l=uk(e,i,s,o);return{x:()=>l.x()}}},CL={kernelName:hi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,se(da(n,r),"float32")),b:()=>z(e,se(pc(n,r),"float32"))}}};function _L(e,t,n,r,a,s,i){let o=_(e,"dy","maxPool3dGrad"),l=_(t,"input","maxPool3dGrad"),p=_(n,"output","maxPool3dGrad"),u=o,h=l,d=p,c=!1;l.rank===4&&(c=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=P(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=P(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),$(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),$(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),$(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),xn("maxPool3dGrad",s,i);let f={dy:u,input:h,output:d},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=O.runKernel(Vd,f,m);return c?P(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var EL=L({maxPool3dGrad_:_L}),$L={kernelName:Qu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>EL(e,r,a,s,i,o,l)}}};function AL(e,t,n,r,a,s,i){let o=_(e,"dy","maxPoolGrad"),l=_(t,"input","maxPoolGrad"),p=_(n,"output","maxPoolGrad");$(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),$(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),$(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),xn("maxPoolGrad",s,i);let u={dy:o,input:l,output:p},h={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return O.runKernel(Wd,u,h)}var RL=L({maxPoolGrad_:AL}),FL={kernelName:di,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>RL(e,r,a,s,i,o)}}},DL={kernelName:ci,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=mr(a,r.shape),i=P0(r.shape,s)[1],o=lt(i);return{x:()=>{let l=r.shape.slice();s.forEach(u=>{l[u]=1});let p=P(e,l);return me(z(p,Bn(r.shape,"float32")),o)}}}},ML={kernelName:fi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=mr(a,s.shape),l=uk(e,i,s,o);return{x:()=>l.x()}}},OL={kernelName:mi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,se(Za(n,r),"float32")),b:()=>z(e,se(wn(n,r),"float32"))}}},LL={kernelName:gi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},zL={kernelName:ll,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=Et(n.shape,a);return s.length>0?P(ge(e,s),n.shape):e},b:()=>{let s=z(e,dt(Ol(me(n,r)))),i=Et(r.shape,a);return i.length>0?P(ge(s,i),r.shape):s}}}},PL={kernelName:yi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=z(e,se(r,"float32")),i=Et(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Et(r.shape,a);return i.length>0?P(ge(s,i),r.shape):s}}}},BL={kernelName:ul,gradFunc:e=>({x:()=>dt(e)})},WL={kernelName:bi,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>bt(n.shape,"float32")}}},VL={kernelName:fl,gradFunc:e=>({x:()=>He(e)})},UL={kernelName:ml,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return St(e,r).map(a=>()=>a)}},Nw={kernelName:xi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},GL={kernelName:wi,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=rt(s.shape,i.shape);return{a:()=>{let l=se(i,"float32"),p=z(e,z(l,ua(s,de(l,ve(1))))),u=Et(s.shape,o);return u.length>0&&(p=ge(p,u)),P(p,s.shape)},b:()=>{let l=wn(s,0),p=sn(l,Un(s),He(s)),u=z(e,z(a,p)),h=Et(i.shape,o);return h.length>0&&(u=ge(u,h)),P(u,i.shape)}}}},HL={kernelName:vi,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=wn(n,0);return{x:()=>sn(a,e,z(e,r)),alpha:()=>{let s=sn(a,He(e),z(e,n)),i=Et(r.shape,e.shape);return i.length>0&&(s=ge(s,i)),P(s,r.shape)}}}};function jL(e,t,n){let r=e.shape.slice();r[n]=1;let a=P(t,r),s=Mu(e,n,!0,!1),i=Mu(e,n,!0,!0),o=z(s,i);return z(a,o)}function qL(e,t,n){let r=e.shape.length,a=r-n.length,s=T.getAxesPermutation(n,r),i=e;s!=null&&(i=Fe(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((h,d)=>h*d,1);o.push(l);let p=i.reshape(o),u=jL(p,t,a);if(u=u.reshape(i.shape),s!=null){let h=T.getUndoAxesPermutation(s);u=Fe(u,h)}return u}var KL={kernelName:ki,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return a==null?s=r.shape.map((i,o)=>o):typeof a=="number"?s=[a]:s=a,{x:()=>qL(r,e,s)}}},XL={kernelName:Qs,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=me(e,se(r,"float32")),i=Et(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Et(r.shape,a);i.length>0&&(s=P(ge(s,i),r.shape));let o=tt(r);return dt(me(s,se(o,"float32")))}}}},ZL={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,dt(tt(n)))}}},JL={kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(Za(n,6),Ui(n));return{x:()=>z(e,se(r,"float32"))}}},YL={kernelName:Si,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,se(Ui(n),"float32"))}}},QL={kernelName:gl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>P(e,n.shape)}}},ez={kernelName:Ti,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(Zd,a,n)}}},tz={kernelName:Ni,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(Xd,a,n)}}},nz={kernelName:_i,gradFunc:(e,t,n)=>{let{dims:r}=n,a=mr(r,e.shape);return{x:()=>rr(e,a)}}},rz={kernelName:Ei,gradFunc:e=>({x:()=>He(e)})},az={kernelName:$i,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>dt(me(e,z(ua(n,1.5),2)))}}},sz={kernelName:bl,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>se(He(n),"float32"),t:()=>z(e,se(n,e.dtype)),e:()=>z(e,se(wp(n),e.dtype))}}},iz={kernelName:xl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=wn(n,ve(0)),a=ve(sk),s=ve(ik),i=z(e,s),o=z(z(e,a),fn(se(n,"float32")));return sn(r,i,o)}}}},oz={kernelName:Ri,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,de(ve(1),n)))}}},lz={kernelName:kl,gradFunc:e=>({x:()=>He(e)})},uz={kernelName:Ai,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(gp(se(n,"float32")),e)}}},pz={kernelName:vl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(oc(se(n,"float32")),e)}}},hz={kernelName:wl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=rk(r,a,s),p=[];for(let u=0;u<e.rank;u++)p.push([o[u],i[u]-o[u]-l[u]]);return{x:()=>Er(e,p)}}},dz={kernelName:Mi,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=z(e,r);return{logits:()=>de(i,z(ge(i,[a],s),r))}}},cz={kernelName:Il,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,dr(n))}}},Tw={kernelName:Sl,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>mp(e,r,a)}}},Cw={kernelName:Nl,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>nt(e,r)}}},fz={kernelName:Fi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,z(en(se(n,"float32")),2))}}},mz={kernelName:ap,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(se(n,"float32"),2))}}},gz={kernelName:Oi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ve(2);return{a:()=>z(e,z(a,de(n,r))),b:()=>z(e,z(a,de(r,n)))}}},yz={kernelName:Ka,gradFunc:e=>({x:()=>He(e)})},bz={kernelName:Li,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=rt(n.shape,r.shape);return{a:()=>{let s=e,i=Et(n.shape,a);return i.length>0&&(s=ge(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Et(r.shape,a);return i.length>0&&(s=ge(s,i)),P(dt(s),r.shape)}}}},xz={kernelName:Di,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;mr(s,r.shape).forEach(l=>{a[l]=1});let i=P(e,a),o=z(i,Bn(r.shape,"float32"));return{x:()=>o}}},wz={kernelName:zi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>me(e,tt(gp(n)))}}},vz={kernelName:Pi,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(de(ve(1),tt(n)),e)}}},kz={kernelName:qa,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let s=He(r);if(r.rank===1)for(let i=0;i<a[0];++i)s=J(s,Ue(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)s=J(s,Ue(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)s=J(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let p=0;p<a[3];++p)s=J(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],p*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},Iz={kernelName:aa,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=Sg(a);return{x:()=>Fe(e,s)}}},Sz={kernelName:$l,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Ot(e,a)}}},Nz={kernelName:lp,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Tz(e,n)}}};function Tz(e,t){let n=jr(t,He(t)),r=Ll(e,n),a=da(t,ve(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=Jt(a,o+1);a=cr(a,Bn(r.shape,"bool"));let i=He(r);return sn(a,r,i)}var Cz={kernelName:Al,gradFunc:e=>({x:()=>He(e)})},_z=[lk,N3,T3,C3,_3,E3,$3,A3,R3,F3,D3,M3,z3,W3,V3,U3,G3,H3,j3,q3,K3,X3,J3,Z3,eL,tL,nL,rL,aL,sL,XL,iL,oL,lL,uL,pL,dL,hL,cL,fL,mL,gL,yL,bL,xL,wL,vL,kL,IL,TL,Sw,Sw,CL,$L,FL,DL,ML,OL,LL,zL,PL,BL,WL,VL,UL,Nw,Nw,GL,HL,KL,ZL,JL,YL,QL,ez,tz,nz,rz,az,sz,iz,oz,lz,uz,pz,hz,dz,cz,Tw,Tw,Cw,Cw,fz,gz,mz,yz,bz,xz,wz,vz,kz,Iz,Sz,Nz,Cz];for(let e of _z)i0(e);Y().prototype.abs=function(){return this.throwIfDisposed(),Ct(this)};Y().prototype.acos=function(){return this.throwIfDisposed(),Zm(this)};Y().prototype.acosh=function(){return this.throwIfDisposed(),Jm(this)};Y().prototype.add=function(e){return this.throwIfDisposed(),J(this,e)};Y().prototype.all=function(e,t){return this.throwIfDisposed(),ac(this,e,t)};Y().prototype.any=function(e,t){return this.throwIfDisposed(),Ru(this,e,t)};Y().prototype.argMax=function(e){return this.throwIfDisposed(),_s(this,e)};Y().prototype.argMin=function(e){return this.throwIfDisposed(),Ym(this,e)};Y().prototype.asScalar=function(){return this.throwIfDisposed(),$(this.size===1,()=>"The array must have only 1 element."),P(this,[])};Y().prototype.asType=function(e){return this.throwIfDisposed(),se(this,e)};Y().prototype.as1D=function(){return this.throwIfDisposed(),P(this,[this.size])};Y().prototype.as2D=function(e,t){return this.throwIfDisposed(),P(this,[e,t])};Y().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),P(this,[e,t,n])};Y().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),P(this,[e,t,n,r])};Y().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),P(this,[e,t,n,r,a])};Y().prototype.asin=function(){return this.throwIfDisposed(),Qm(this)};Y().prototype.asinh=function(){return this.throwIfDisposed(),eg(this)};Y().prototype.atan=function(){return this.throwIfDisposed(),tg(this)};Y().prototype.atan2=function(e){return this.throwIfDisposed(),ng(this,e)};Y().prototype.atanh=function(){return this.throwIfDisposed(),rg(this)};Y().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),ha(this,e,t,n,r)};Y().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),mp(this,e,t)};Y().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),Bi(this,e,t,n,r,a)};Y().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ys(this,e)};Y().prototype.cast=function(e){return this.throwIfDisposed(),se(this,e)};Y().prototype.ceil=function(){return this.throwIfDisposed(),pg(this)};Y().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),an(this,e,t)};Y().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Pe&&(e=[e]),nt([this,...e],t)};Y().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),sc(this,e,t,n,r,a,s)};Y().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),ic(this,e,t,n,r,a)};Y().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),cn(this,e,t,n,r,a,s)};Y().prototype.cos=function(){return this.throwIfDisposed(),gp(this)};Y().prototype.cosh=function(){return this.throwIfDisposed(),oc(this)};Y().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Mu(this,e,t,n)};Y().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),lc(this,e,t,n)};Y().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),bg(this,e,t)};Y().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Wi(this,e,t,n,r,a,s)};Y().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),xg(this,e,t,n,r,a)};Y().prototype.divNoNan=function(e){return this.throwIfDisposed(),wg(this,e)};Y().prototype.div=function(e){return this.throwIfDisposed(),me(this,e)};Y().prototype.dot=function(e){return this.throwIfDisposed(),vg(this,e)};Y().prototype.elu=function(){return this.throwIfDisposed(),Dl(this)};Y().prototype.equal=function(e){return this.throwIfDisposed(),Vn(this,e)};Y().prototype.erf=function(){return this.throwIfDisposed(),kg(this)};Y().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Ng(this,e,t)};Y().prototype.exp=function(){return this.throwIfDisposed(),fn(this)};Y().prototype.expandDims=function(e){return this.throwIfDisposed(),Jt(this,e)};Y().prototype.expm1=function(){return this.throwIfDisposed(),Tg(this)};Y().prototype.fft=function(){return this.throwIfDisposed(),Np(this)};Y().prototype.flatten=function(){return this.throwIfDisposed(),P(this,[this.size])};Y().prototype.floor=function(){return this.throwIfDisposed(),Ol(this)};Y().prototype.floorDiv=function(e){return this.throwIfDisposed(),rc(this,e)};Y().prototype.gather=function(e,t){return this.throwIfDisposed(),Ll(this,e,t)};Y().prototype.greaterEqual=function(e){return this.throwIfDisposed(),da(this,e)};Y().prototype.greater=function(e){return this.throwIfDisposed(),wn(this,e)};Y().prototype.ifft=function(){return this.throwIfDisposed(),yo(this)};Y().prototype.irfft=function(){return this.throwIfDisposed(),Sc(this)};Y().prototype.isFinite=function(){return this.throwIfDisposed(),Cg(this)};Y().prototype.isInf=function(){return this.throwIfDisposed(),_g(this)};Y().prototype.isNaN=function(){return this.throwIfDisposed(),Eg(this)};Y().prototype.leakyRelu=function(e){return this.throwIfDisposed(),bp(this,e)};Y().prototype.lessEqual=function(e){return this.throwIfDisposed(),Za(this,e)};Y().prototype.less=function(e){return this.throwIfDisposed(),pc(this,e)};Y().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),$g(this,e,t,n,r)};Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),Ag(this)};Y().prototype.logSoftmax=function(e){return this.throwIfDisposed(),dc(this,e)};Y().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),cc(this,e,t)};Y().prototype.log=function(){return this.throwIfDisposed(),Un(this)};Y().prototype.log1p=function(){return this.throwIfDisposed(),xp(this)};Y().prototype.logicalAnd=function(e){return this.throwIfDisposed(),cr(this,e)};Y().prototype.logicalNot=function(){return this.throwIfDisposed(),wp(this)};Y().prototype.logicalOr=function(e){return this.throwIfDisposed(),fc(this,e)};Y().prototype.logicalXor=function(e){return this.throwIfDisposed(),Rg(this,e)};Y().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Le(this,e,t,n)};Y().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Wt(this,e,t,n,r)};Y().prototype.max=function(e,t){return this.throwIfDisposed(),er(this,e,t)};Y().prototype.maximum=function(e){return this.throwIfDisposed(),jr(this,e)};Y().prototype.mean=function(e,t){return this.throwIfDisposed(),yt(this,e,t)};Y().prototype.min=function(e,t){return this.throwIfDisposed(),co(this,e,t)};Y().prototype.minimum=function(e){return this.throwIfDisposed(),zl(this,e)};Y().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Dg(this,e,t)};Y().prototype.mod=function(e){return this.throwIfDisposed(),Mg(this,e)};Y().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)};Y().prototype.neg=function(){return this.throwIfDisposed(),dt(this)};Y().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ml(this,e,t,n)};Y().prototype.notEqual=function(e){return this.throwIfDisposed(),Rs(this,e)};Y().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),fo(this,e,t,n)};Y().prototype.onesLike=function(){return this.throwIfDisposed(),Gn(this)};Y().prototype.pad=function(e,t){return this.throwIfDisposed(),Er(this,e,t)};Y().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),Og(this,e,t,n,r,a,s)};Y().prototype.pow=function(e){return this.throwIfDisposed(),ua(this,e)};Y().prototype.prelu=function(e){return this.throwIfDisposed(),Ip(this,e)};Y().prototype.prod=function(e,t){return this.throwIfDisposed(),Lg(this,e,t)};Y().prototype.reciprocal=function(){return this.throwIfDisposed(),Vg(this)};Y().prototype.relu=function(){return this.throwIfDisposed(),Ye(this)};Y().prototype.relu6=function(){return this.throwIfDisposed(),yc(this)};Y().prototype.reshapeAs=function(e){return this.throwIfDisposed(),P(this,e.shape)};Y().prototype.reshape=function(e){return this.throwIfDisposed(),P(this,e)};Y().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),R1(this,e,t,n)};Y().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),F1(this,e,t,n)};Y().prototype.reverse=function(e){return this.throwIfDisposed(),rr(this,e)};Y().prototype.rfft=function(){return this.throwIfDisposed(),Tp(this)};Y().prototype.round=function(){return this.throwIfDisposed(),bc(this)};Y().prototype.rsqrt=function(){return this.throwIfDisposed(),xc(this)};Y().prototype.selu=function(){return this.throwIfDisposed(),wc(this)};Y().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Bl(this,e,t,n,r,a,s)};Y().prototype.sigmoid=function(){return this.throwIfDisposed(),dr(this)};Y().prototype.sign=function(){return this.throwIfDisposed(),Ug(this)};Y().prototype.sin=function(){return this.throwIfDisposed(),vc(this)};Y().prototype.sinh=function(){return this.throwIfDisposed(),kc(this)};Y().prototype.slice=function(e,t){return this.throwIfDisposed(),Ue(this,e,t)};Y().prototype.softmax=function(e){return this.throwIfDisposed(),Ja(this,e)};Y().prototype.softplus=function(){return this.throwIfDisposed(),Vi(this)};Y().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),kp(this,e,t)};Y().prototype.split=function(e,t){return this.throwIfDisposed(),_n(this,e,t)};Y().prototype.sqrt=function(){return this.throwIfDisposed(),en(this)};Y().prototype.square=function(){return this.throwIfDisposed(),tt(this)};Y().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Nc(this,e)};Y().prototype.squeeze=function(e){return this.throwIfDisposed(),Ya(this,e)};Y().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Pe?[this,e]:[this,...e];return Ot(n,t)};Y().prototype.step=function(e){return this.throwIfDisposed(),Ui(this,e)};Y().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Gg(this,e,t,n,r,a,s,i,o)};Y().prototype.sub=function(e){return this.throwIfDisposed(),de(this,e)};Y().prototype.sum=function(e,t){return this.throwIfDisposed(),ge(this,e,t)};Y().prototype.tan=function(){return this.throwIfDisposed(),Hg(this)};Y().prototype.tanh=function(){return this.throwIfDisposed(),$s(this)};Y().prototype.tile=function(e){return this.throwIfDisposed(),Pn(this,e)};Y().prototype.toBool=function(){return this.throwIfDisposed(),se(this,"bool")};Y().prototype.toFloat=function(){return this.throwIfDisposed(),se(this,"float32")};Y().prototype.toInt=function(){return this.throwIfDisposed(),se(this,"int32")};Y().prototype.topk=function(e,t){return this.throwIfDisposed(),jg(this,e,t)};Y().prototype.transpose=function(e){return this.throwIfDisposed(),Fe(this,e)};Y().prototype.unique=function(e){return this.throwIfDisposed(),qg(this,e)};Y().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),_c(this,e,t)};Y().prototype.unstack=function(e){return this.throwIfDisposed(),St(this,e)};Y().prototype.where=function(e,t){return this.throwIfDisposed(),sn(e,this,t)};Y().prototype.zerosLike=function(){return this.throwIfDisposed(),He(this)};var Qr=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Qr.prototype)}},vr=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vr.prototype)}},V=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,V.prototype)}},Re=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Re.prototype)}},pk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pk.prototype)}},hk=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Ds(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Or(e,t){if(!e)throw new pk(t)}function _w(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Cn(e){return e.length===1?e[0]:e}function ht(e){return Array.isArray(e)?e:[e]}function ea(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function cs(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var ir={};function my(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Jf(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Jf(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Jf(r))}}}function _p(e,t={},n={},r="object",a=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in ir)i=ir[s];else if(i=t[s],i==null)throw new V(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new V(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in ir?[o,l]=ir.className:i in t&&([o,l]=t[i]),o==null)throw new V(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let p={};for(let c of Object.keys(ir))p[c]=ir[c];for(let c of Object.keys(n))p[c]=n[c];let u=s.config;u.customObjects=p;let h=Object.assign({},ir);for(let c of Object.keys(n))ir[c]=n[c];Jf(s.config);let d=l(o,s.config,n,a);return ir=Object.assign({},h),d}else{let p=Object.assign({},ir);for(let h of Object.keys(n))ir[h]=n[h];let u=new o(s.config);return ir=Object.assign({},p),u}}}function Ez(e,t){return e<t?-1:e>t?1:0}function dh(e,t){return-1*Ez(e,t)}function $a(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function $z(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Gi(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function gy(e,t,n=0,r=1/0){return Or(n>=0),Or(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function Ut(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>Ut(n,`element ${r+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${dk(e)}.`)}function dk(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>dk(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Az(e,t,n){let r=n!=null?n():w.now(),a;return(...s)=>{let i=n!=null?n():w.now();return i-r<t||(r=i,a=e(...s)),a}}function ck(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Rz=0;function fk(){return Rz++}var ch={};function Mc(e=""){return e in ch||(ch[e]=0),ch[e]+=1,e+ch[e].toString()}var Fz=["channelsFirst","channelsLast"],Dz=["nearest","bilinear"],Mz=["valid","same","causal"],Oz=["max","avg"],Lz=["sum","mul","concat","ave"],eo=new Map;function Nt(e){Gi(Fz,"DataFormat",e)}function zz(e){Gi(Dz,"InterpolationFormat",e)}function ar(e){Gi(Mz,"PaddingMode",e)}function mk(e){Gi(Oz,"PoolMode",e)}var Iu=[],Ew="/";function bs(e,t){Iu.push(e);try{let n=t();return Iu.pop(),n}catch(n){throw Iu.pop(),n}}function Pz(){return Iu.length===0?"":Iu.join(Ew)+Ew}function gk(e){if(!bk(e))throw new Error("Not a valid tensor name: '"+e+"'");return Pz()+e}function yk(e){if(!bk(e))throw new Error("Not a valid tensor name: '"+e+"'");eo.has(e)||eo.set(e,0);let t=eo.get(e);if(eo.set(e,eo.get(e)+1),t>0){let n=`${e}_${t}`;return eo.set(n,1),n}else return e}var Bz=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function bk(e){return!!e.match(Bz)}function Wz(e){return e===parseInt(e.toString(),10)}function Aa(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function wo(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Oa(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Tr(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var kf;function Dt(){return kf==null&&(kf=C0().epsilon()),kf}function Cr(){return"channelsLast"}function pa(e,t){return se(e,t)}function Ep(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),P(e,n)}function Vz(e,t){return W(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Ep(e,1);return Yf(n,[1,t,1])})}function Uz(e){let t=[Aa(e.shape)];return P(e,t)}function Gz(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Aa(e.shape,1)];return P(e,t)}function xs(e,t,n){return W(()=>{switch(e.rank){case 1:return Sp(e,t,n);case 2:return Ic(e,[t,0],[n,e.shape[1]]);case 3:return Wl(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return go(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ue(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ue(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function If(e,t,n){return W(()=>{switch(e.rank){case 1:return Sp(e,t,n);case 2:return Ic(e,[0,t],[e.shape[0],n]);case 3:return Wl(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return go(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function fh(e,t,n,r){return W(()=>{switch(e.rank){case 1:return Sp(e,t,n);case 2:switch(r){case 1:return xs(e,t,n);case 2:return If(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return xs(e,t,n);case 2:return Wl(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return If(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return xs(e,t,n);case 2:return go(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return go(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return If(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function yy(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),nt(e,t)}function $w(e,t){switch(e.rank){case 1:return hg([e,t]);case 2:return dg([e,t],0);case 3:return cg([e,t],0);case 4:return fg([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Yf(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Pn(e,t)}function Oc(e,t=0,n=1,r,a){return gc(e,t,n,r,a)}function Wr(e,t,n,r){if(e.rank<2||t.rank<2)throw new Re(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let a=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new Re(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return bo.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Qf(e.rank,r,Cr()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=P(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),p=[...i,o],u=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=P(Fe(t,u),[l,-1]);let h=[...a,...p],d=!1,c=!1;return P(bo.matMul({a:e,b:t,transposeA:d,transposeB:c,bias:r?Qf(e.rank,r,Cr()):null,activation:n}),h)}}function xk(e,t,n){return W(()=>(Array.isArray(t)?t=Je(t,"int32"):t=se(t,"int32"),Ll(e,t,n)))}function $p(e){return z(e,e)}function Qf(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1,1]):P(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1]):P(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1]):P(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,r[0]]):P(t,[1].concat(r))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function $r(e,t,n){return W(()=>(n==null&&(n=Cr()),Nt(n),J(e,Qf(e.rank,t,n))))}function Hz(e,t=1){if(t!==1)throw new Re(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Dl(e)}function jz(e){return W(()=>me(e,J(Ct(e),1)))}function wk(e,t,n,r){return W(()=>Qg(e,t,n,r))}function qz(e){return W(()=>{let t=J(.5,z(.2,e));return an(t,0,1)})}function Ap(e,t,n=!1){return n?e():t()}var Kz=["fanIn","fanOut","fanAvg"],Xz=["normal","uniform","truncatedNormal"];function Zz(e){Gi(Kz,"FanMode",e)}function Jz(e){Gi(Xz,"Distribution",e)}var gr=class extends ne.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},by=class extends gr{apply(e,t){return bt(e,t)}};by.className="Zeros";ne.registerClass(by);var Lc=class extends gr{apply(e,t){return Bn(e,t)}};Lc.className="Ones";ne.registerClass(Lc);var xy=class extends gr{constructor(e){if(super(),typeof e!="object")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return W(()=>z(ve(this.value),Bn(e,t)))}getConfig(){return{value:this.value}}};xy.className="Constant";ne.registerClass(xy);var wy=class extends gr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Pl(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};wy.className="RandomUniform";ne.registerClass(wy);var vy=class extends gr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Re(`randomNormal does not support dType ${t}.`);return Oc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};vy.className="RandomNormal";ne.registerClass(vy);var ky=class extends gr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Re(`truncatedNormal does not support dType ${t}.`);return Cc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};ky.className="TruncatedNormal";ne.registerClass(ky);var Iy=class extends gr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return W(()=>{if(e.length!==2||e[0]!==e[1])throw new V("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,uc(e[0]))})}getConfig(){return{gain:this.gain}}};Iy.className="Identity";ne.registerClass(Iy);function Yz(e,t="channelsLast"){let n,r;if(Nt(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let a=Aa(e,2);n=e[1]*a,r=e[0]*a}else if(t==="channelsLast"){let a=Aa(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=Aa(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}var $n=class extends gr{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Zz(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Jz(this.distribution),this.seed=e.seed}apply(e,t){let n=Yz(e),r=n[0],a=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Re(`${this.getClassName()} does not support dType ${t}.`);return Cc(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return Pl(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};$n.className="VarianceScaling";ne.registerClass($n);var zc=class extends $n{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $n.className}};zc.className="GlorotUniform";ne.registerClass(zc);var Pc=class extends $n{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $n.className}};Pc.className="GlorotNormal";ne.registerClass(Pc);var Bc=class extends $n{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $n.className}};Bc.className="HeNormal";ne.registerClass(Bc);var Wc=class extends $n{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $n.className}};Wc.className="HeUniform";ne.registerClass(Wc);var Vc=class extends $n{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return $n.className}};Vc.className="LeCunNormal";ne.registerClass(Vc);var Uc=class extends $n{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return $n.className}};Uc.className="LeCunUniform";ne.registerClass(Uc);var Sy=class extends gr{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Re("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return W(()=>{if(e.length<2)throw new Re("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,r=Oc(n,0,1,"float32"),a=ry.gramSchmidt(r);return e[0]>e[1]&&(a=Fe(a)),z(this.gain,a)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Sy.className="Orthogonal";ne.registerClass(Sy);var Aw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Rw(e,t={}){return _p(e,ne.SerializationMap.getMap().classNameMap,t,"initializer")}function xt(e){return my(e)}function ft(e){if(typeof e=="string"){let t=e in Aw?Aw[e]:e;if(t==="GlorotNormal")return new Pc;if(t==="GlorotUniform")return new zc;if(t==="HeNormal")return new Bc;if(t==="HeUniform")return new Wc;if(t==="LeCunNormal")return new Vc;if(t==="LeCunUniform")return new Uc;{let n={};return n.className=t,n.config={},Rw(n)}}else return e instanceof gr?e:Rw(e)}function em(e){return Array.isArray(e)&&Array.isArray(e[0])}function qh(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Ce(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Xe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Kh(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,a)=>r*a);return t}var Fw="Variable",vk=class{constructor(e,t="float32",n=Fw,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=fk(),n=n??Fw,this.originalName=gk(n),this.name=yk(this.originalName),this.trainable_=r,this.constraint=a,this.val=Kg(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Qz(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Qz(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function tm(e){return e.map(t=>t.read())}function Ny(e){e.forEach(t=>{t[0].write(t[1])})}var _t=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},kr=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=fk(),s!=null&&(this.originalName=gk(s),this.name=yk(this.originalName)),this.rank=t.length}},eP=0,Gc=class{constructor(e,t){this.callArgs=t,this.id=eP++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},tP=0,Ve=class extends ne.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tP++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=ea(n)+"_"+Mc(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new vr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Cn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Cn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Qr(`Layer ${this.name} is not connected, no input to return.`);return Cn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Qr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qr(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Cn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=ht(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=ht(this.inputSpec);if(e.length!==t.length)throw new V(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],a=t[n];if(a==null)continue;let s=r.rank;if(a.ndim!=null&&s!==a.ndim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(a.maxNDim!=null&&s>a.maxNDim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(a.minNDim!=null&&s<a.minNDim)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(a.dtype!=null&&r.dtype!==a.dtype)throw new V(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let i=r.shape;for(let o in a.axes){let l=Number(o),p=a.axes[o],u=l>=0?i[l]:i[i.length+l];if(p!=null&&[p,null].indexOf(u)===-1)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${p} but got shape ${i}.`)}}if(a.shape!=null)for(let i=0;i<a.shape.length;++i){let o=a.shape[i],l=r.shape[i];if(o!=null&&l!=null&&o!==l)throw new V(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=ht(e),r=!0;for(let s of n)if(!(s instanceof kr)){r=!1;break}let a=!0;for(let s of n)if(s instanceof kr){a=!1;break}if(r===a)throw new V("Arguments to apply() must be all SymbolicTensors or all Tensors");return bs(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of ht(e))s.push(i.shape);this.build(Cn(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let s=this.call(e,t),i=ht(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=Cn(o),this.activityRegularizer!=null)throw new Re("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=nP(e),i=this.computeOutputShape(s),o,l=rP(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((p,u)=>new kr(l,p,this,ht(e),t,this.name,u)):o=new kr(l,i,this,ht(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new Re("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Qr(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Qr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Kh(this.weights)}build(e){this.built=!0}getWeights(e=!1){return tm(e?this.trainableWeights:this.weights)}setWeights(e){W(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=tm(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!w.arraysEqual(s.shape,o.shape))throw new V(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Ny(n)})}addWeight(e,t,n,r,a,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():ft("zeros"));let l=r.apply(t,n),p=new vk(l,n,e,s,i);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(p.read())),s==null&&(s=!0),s?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=ht(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,a,s,i=null){let o=ht(e);t=ht(t),n=ht(n),r=ht(r),a=qh(a),s=qh(s);let l=[],p=[],u=[];for(let h of o)l.push(h.sourceLayer),p.push(h.nodeIndex),u.push(h.tensorIndex);new Gc({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function nP(e){e=ht(e);let t=[];for(let n of e)t.push(n.shape);return Cn(t)}function rP(e){return"float32"}function kk(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let a=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],p=kk(i,o,l);for(let u of p)a.indexOf(u)===-1&&a.push(u)}return a}}}var Ul=class extends Ve{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Mc("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new kr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Gc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Ul.className="InputLayer";ne.registerClass(Ul);function Ik(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new V("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Ul({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function aP(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return se(t,e.dtype)}catch{throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var gs=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof gs)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=aP(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new V(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof kr){if(this.id2Value[e.id]==null)throw new V(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new V(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof kr){if(this.id2Value[e.id]==null)throw new V(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new V(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&_e(this.id2Mask)}},Xh=new hk,Zh=new hk;function sP(e){Xh!=null&&Xh.setMaxEntries(e),Zh!=null&&Zh.setMaxEntries(e)}function fu(e,t,n,r){let a=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(f=>f.name),l=[],p=t.names();for(let f of o)p.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let u=o.join(",")+"|"+t.names().sort().join(","),h=Xh.get(u),d;if(h==null){let f=iP(i,t);h=f.sorted,d=f.recipientCounts,Xh.put(u,h),Zh.put(u,d)}d={},a||Object.assign(d,Zh.get(u));let c=new gs(t);for(let f=0;f<h.length;++f){if(r!=null){let A=Hh().numTensors;A>r.maxNumTensors&&(r.maxNumTensors=A),A<r.minNumTensors&&(r.minNumTensors=A)}let m=h[f],g=m.sourceLayer;if(g instanceof Ul)continue;let y=[],b=[],x=[],v=!1;for(let A of m.inputs){let F=c.getValue(A),R=c.getMask(A);y.push(F),b.push(R),R!=null&&(v=!0),a||(d[A.name]--,d[A.name]===0&&!t.hasKey(A)&&o.indexOf(A.name)===-1&&!F.isDisposed&&A.sourceLayer.stateful!==!0&&x.push(F))}v&&(n=n||{},n.mask=b[0]);let I=ht(g.apply(y,n)),N=null;g.supportsMasking&&(N=g.computeMask(y,b));let C=lP(m),E=Array.isArray(C)?C:[C];for(let A=0;A<E.length;++A){c.hasKey(E[A])||c.add(E[A],I[A],Array.isArray(N)?N[0]:N);let F=o.indexOf(E[A].name);F!==-1&&(l[F]=I[A])}a||_e(x)}return c.disposeMasks(),s?l:l[0]}function iP(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let a=Dw(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:i,recipientMap:o}=Dw(s,t);for(let l of i)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(p=>r[l].add(p))}}return{sorted:n,recipientCounts:oP(r)}}function oP(e){let t={};for(let n in e)t[n]=e[n].size;return t}function Dw(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let p of o.inputs)a[p.name]==null&&(a[p.name]=new Set),a[p.name].add(o.name),!n.has(p.name)&&s.push(p)}}return{sorted:r,recipientMap:a}}function lP(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var uP=j();uP.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,sP);var Sk={};Ee(Sk,{maxNorm:()=>pP,minMaxNorm:()=>cP,nonNeg:()=>dP,unitNorm:()=>hP});function Ty(e,t){return W(()=>en(ge(z(e,e),t,!0)))}var Rp=class extends ne.Serializable{getConfig(){return{}}},Cy=class extends Rp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return W(()=>{let t=Ty(e,this.axis),n=an(t,0,this.maxValue);return z(e,me(n,J(Dt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Cy.className="MaxNorm";ne.registerClass(Cy);var _y=class extends Rp{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return W(()=>me(e,J(Dt(),Ty(e,this.axis))))}getConfig(){return{axis:this.axis}}};_y.className="UnitNorm";ne.registerClass(_y);var Ey=class extends Rp{apply(e){return Ye(e)}};Ey.className="NonNeg";ne.registerClass(Ey);var $y=class extends Rp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return W(()=>{let t=Ty(e,this.axis),n=J(z(this.rate,an(t,this.minValue,this.maxValue)),z(1-this.rate,t));return z(e,me(n,J(Dt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};$y.className="MinMaxNorm";ne.registerClass($y);var Mw={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function zt(e){return my(e)}function Ow(e,t={}){return _p(e,ne.SerializationMap.getMap().classNameMap,t,"constraint")}function Pt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in Mw?Mw[e]:e,config:{}};return Ow(t)}else return e instanceof Rp?e:Ow(e)}function pP(e){return new Cy(e)}function hP(e){return new _y(e)}function dP(){return new Ey}function cP(e){return new $y(e)}var Nk={};Ee(Nk,{constant:()=>gP,glorotNormal:()=>IP,glorotUniform:()=>kP,heNormal:()=>SP,heUniform:()=>NP,identity:()=>wP,leCunNormal:()=>TP,leCunUniform:()=>CP,ones:()=>mP,orthogonal:()=>_P,randomNormal:()=>bP,randomUniform:()=>yP,truncatedNormal:()=>xP,varianceScaling:()=>vP,zeros:()=>fP});function fP(){return new by}function mP(){return new Lc}function gP(e){return new xy(e)}function yP(e){return new wy(e)}function bP(e){return new vy(e)}function xP(e){return new ky(e)}function wP(e){return new Iy(e)}function vP(e){return new $n(e)}function kP(e){return new zc(e)}function IP(e){return new Pc(e)}function SP(e){return new Bc(e)}function NP(e){return new Wc(e)}function TP(e){return new Vc(e)}function CP(e){return new Uc(e)}function _P(e){return new Sy(e)}var Tk={};Ee(Tk,{Layer:()=>Ve,RNN:()=>Kr,RNNCell:()=>Lp,activation:()=>tW,add:()=>pW,alphaDropout:()=>qW,average:()=>hW,averagePooling1d:()=>Bb,averagePooling2d:()=>Wb,averagePooling3d:()=>Vb,avgPool1d:()=>wW,avgPool2d:()=>kW,avgPool3d:()=>SW,avgPooling1d:()=>vW,avgPooling2d:()=>IW,avgPooling3d:()=>NW,batchNormalization:()=>yW,bidirectional:()=>PW,categoryEncoding:()=>YW,centerCrop:()=>ZW,concatenate:()=>dW,conv1d:()=>jB,conv2d:()=>qB,conv2dTranspose:()=>KB,conv3d:()=>XB,conv3dTranspose:()=>ZB,convLstm2d:()=>MW,convLstm2dCell:()=>OW,cropping2D:()=>YB,dense:()=>nW,depthwiseConv2d:()=>eW,dot:()=>gW,dropout:()=>rW,elu:()=>BB,embedding:()=>uW,flatten:()=>sW,gaussianDropout:()=>jW,gaussianNoise:()=>HW,globalAveragePooling1d:()=>TW,globalAveragePooling2d:()=>CW,globalMaxPool1d:()=>WW,globalMaxPool2d:()=>VW,globalMaxPooling1d:()=>yI,globalMaxPooling2d:()=>bI,gru:()=>EW,gruCell:()=>$W,input:()=>Gk,inputLayer:()=>PB,layerNormalization:()=>bW,leakyReLU:()=>VB,lstm:()=>AW,lstmCell:()=>RW,masking:()=>KW,maxPool1d:()=>UW,maxPool2d:()=>GW,maxPooling1d:()=>xI,maxPooling2d:()=>wI,maxPooling3d:()=>_W,maximum:()=>cW,minimum:()=>fW,multiply:()=>mW,permute:()=>lW,prelu:()=>UB,reLU:()=>WB,repeatVector:()=>iW,rescaling:()=>XW,reshape:()=>oW,resizing:()=>JW,rnn:()=>LW,separableConv2d:()=>JB,simpleRNN:()=>FW,simpleRNNCell:()=>DW,softmax:()=>GB,spatialDropout1d:()=>aW,stackedRNNCells:()=>zW,thresholdedReLU:()=>HB,timeDistributed:()=>BW,upSampling2d:()=>QB,zeroPadding2d:()=>xW});async function va(e){if(e==null)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(a),r.push(i)}}if(t.length>0){let a=await Promise.all(t);for(let s=0;s<a.length;++s)e[n[s]]=a[s][0];_e(r)}}function Ck(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var Lw;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(Lw||(Lw={}));var EP=125,vo=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},_k=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},$P=class extends vo{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let i=W(()=>J(this.totals[r],z(a,n)));this.totals[r]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:W(()=>{let r=z(me(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),Ft(t[n])}))}},Ek=class extends vo{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let s=this.history[a];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},$k=class extends vo{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||cy,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=EP),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=Az(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await va(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await va(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await va(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await va(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await va(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await va(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await va(e),await this.trainEnd(e))}};function Ak(e,t){return e==null&&(e={}),e instanceof vo?[e]:Array.isArray(e)&&e[0]instanceof vo?e:ht(e).map(n=>new $k(n,t))}var ur=class{constructor(){}static registerCallbackConstructor(e,t){w.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ur.checkForDuplicate(t),ur.constructors[e]==null&&(ur.constructors[e]=[]),ur.constructors[e].push(t)}static checkForDuplicate(e){for(let t in ur.constructors)ur.constructors[+t].forEach(n=>{if(n===e)throw new V("Duplicate callback constructor.")})}static clear(){ur.constructors={}}static createCallbacks(e){let t=[];for(let n in ur.constructors){let r=+n;e>=r&&t.push(...ur.constructors[r])}return t.map(n=>new n)}};ur.constructors={};function Rk(e,t,n,r,a,s,i,o,l){let p=new Ek,u=[new $P,...ur.createCallbacks(t)];e!=null&&u.push(...e),u.push(p);let h=new _k(u);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:p}}function Sr(e,t={},n=!1){return _p(e,ne.SerializationMap.getMap().classNameMap,t,"layer",n)}function Jh(e,t){return W(()=>{e.dtype!=="float32"&&(e=se(e,"float32"));let n=ge($p(e),t,!0),r=Wn(n.shape,Dt()),a=en(jr(n,r));return me(e,a)})}function Hi(e,t){return W(()=>yt($p(de(t,e)),-1))}function Hc(e,t){return W(()=>yt(Ct(de(t,e)),-1))}function Gl(e,t){return W(()=>{let n=de(e,t),r=an(Ct(e),Dt(),Number.MAX_VALUE),a=Ct(me(n,r));return z(100,yt(a,-1))})}function AP(e,t){return W(()=>{let n=an(t,Dt(),Number.MAX_VALUE),r=Un(J(1,n)),a=an(e,Dt(),Number.MAX_VALUE),s=Un(J(1,a));return yt($p(de(r,s)),-1)})}function RP(e,t){return W(()=>{let n=jr(0,de(1,z(e,t)));return yt($p(n),-1)})}function FP(e,t){return W(()=>{let n=jr(0,de(1,z(e,t)));return yt(n,-1)})}function DP(e,t){return W(()=>{let n=ge(z(e,t),-1),r=er(z(de(1,e),t),-1);return jr(0,J(1,de(r,n)))})}function MP(e,t){return W(()=>{let n=Math.log(2),r=de(t,e),a=de(J(r,Vi(z(-2,r))),n);return yt(a,-1)})}function Ou(e,t,n=!1){return W(()=>{if(n)t=Ja(t);else{let r=ge(t,t.shape.length-1,!0);t=me(t,r)}return t=an(t,Dt(),1-Dt()),dt(ge(z(se(e,"float32"),Un(t)),t.shape.length-1))})}function Yh(e,t,n=!1){return W(()=>{let r=se(Ol(Uz(e)),"int32");t=an(t,Dt(),1-Dt());let a=t.shape,s=P(fo(r,a[a.length-1]),a);return Ou(s,t,n)})}function OP(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return W(()=>{let n=Ye(t),r=dt(Ct(t));return J(de(n,z(t,e)),xp(fn(r)))})}function jc(e,t){return W(()=>{let n;return n=an(t,Dt(),1-Dt()),n=Un(me(n,de(1,n))),yt(OP(e,n),-1)})}function LP(e,t){return W(()=>{let n=an(e,Dt(),1),r=an(t,Dt(),1);return ge(z(e,Un(me(n,r))),-1)})}function zP(e,t){return W(()=>{let n=Un(J(Dt(),t));return yt(de(t,z(e,n)),-1)})}function Ay(e,t){return W(()=>{let n=Jh(e,-1),r=Jh(t,-1),a=z(n,r);return dt(ge(a,-1))})}var Qh={meanSquaredError:Hi,meanAbsoluteError:Hc,meanAbsolutePercentageError:Gl,meanSquaredLogarithmicError:AP,squaredHinge:RP,hinge:FP,categoricalHinge:DP,logcosh:MP,categoricalCrossentropy:Ou,sparseCategoricalCrossentropy:Yh,binaryCrossentropy:jc,kullbackLeiblerDivergence:LP,poisson:zP,cosineProximity:Ay};function Sf(e){if(typeof e=="string"){if(e in Qh)return Qh[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function Ry(e,t){return W(()=>{let n=z(.5,Gn(t)),r=pa(wn(t,n),e.dtype);return yt(Vn(e,r),-1)})}function Fy(e,t){return W(()=>pa(Vn(_s(e,-1),_s(t,-1)),"float32"))}function Fk(e,t){return W(()=>se(ge(cr(Vn(e,1),Vn(t,1))),"float32"))}function PP(e,t){return W(()=>se(ge(cr(Vn(e,1),Vn(t,0))),"float32"))}function BP(e,t){return W(()=>se(ge(cr(Vn(e,0),Vn(t,1))),"float32"))}function Dk(e,t){return W(()=>{let n=Fk(e,t),r=BP(e,t),a=J(n,r);return se(sn(wn(a,0),me(n,a),0),"float32")})}function WP(e,t){return W(()=>{let n=Fk(e,t),r=PP(e,t),a=J(n,r);return se(sn(wn(a,0),me(n,a),0),"float32")})}function Mk(e,t){return jc(e,t)}function Ok(e,t){return e.rank===t.rank&&(e=Ya(e,[e.rank-1])),t=_s(t,-1),t.dtype!==e.dtype&&(t=se(t,e.dtype)),se(Vn(e,t),"float32")}var VP=Hi,UP=Hi,GP=Hc,HP=Hc,jP=Gl,qP=Gl,Dy=Ou,KP=Ay,Lk=Yh,ed={binaryAccuracy:Ry,categoricalAccuracy:Fy,precision:Dk,categoricalCrossentropy:Dy,sparseCategoricalCrossentropy:Lk,mse:VP,MSE:UP,mae:GP,MAE:HP,mape:jP,MAPE:qP,cosine:KP};function XP(e){if(typeof e=="string"&&e in ed)return ed[e];if(typeof e!="string"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function mh(e){if(Or(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(Qh))if(Qh[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(ed))if(ed[n]===e){t=n;break}return t!==void 0?t:e.name}}function ZP(e){let t={Adagrad:()=>ps.adagrad(.01),Adadelta:()=>ps.adadelta(1,.95,Dt()),Adam:()=>ps.adam(.001,.9,.999,Dt()),Adamax:()=>ps.adamax(.002,.9,.999,Dt(),0),RMSProp:()=>ps.rmsprop(.001,.9,0,Dt()),SGD:()=>ps.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}function zw(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!nm(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function nm(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!nm(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!nm(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function JP(e,t,n,r=console.log){let a=QP(e),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(u=>Math.floor(t*u)));let i;if(!a){s.push("Receives inputs"),i=[];for(let u in e.nodesByDepth)i.push(...e.nodesByDepth[u])}r("_".repeat(t)),td(s,n,r),r("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)a?eB(o[u],n,r):tB(o[u],n,i,r),r((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=YP(e),p=Kh(e.nonTrainableWeights);r(`Total params: ${l+p}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${p}`),r("_".repeat(t))}function YP(e){let t;return e.collectedTrainableWeights!=null?t=Kh(e.collectedTrainableWeights):t=Kh(e.trainableWeights),t}function QP(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let s=!1;for(let i of a.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function td(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function eB(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];td(o,t,n)}function tB(e,t,n,r){let a,s;try{s=e.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=[];for(let h of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){let c=h.inboundLayers[d].name,f=h.nodeIndices[d],m=h.tensorIndices[d];i.push(`${c}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),p=i.length===0?"":i[0],u=[`${o} (${l})`,s,a,e.countParams().toString(),p];td(u,t,r);for(let h=1;h<i.length;++h)td(["","","","",i[h]],t,r)}function zk(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function Lu(e,t){if(e===null)return null;if(typeof e=="string")return cs(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];zk(t,a,s)?n.push(s):n.push(Lu(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r];if(r==="name"&&typeof a=="string")n[r]=a;else{let s=cs(r);n[s]=Lu(a,s)}}return n}}function rm(e,t){if(e==null)return null;if(typeof e=="string")return ea(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];zk(t,a,s)?n.push(s):n.push(rm(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r],s=ea(r);(r==="name"||r==="className")&&typeof a=="string"?n[s]=a:n[s]=rm(a,r)}return n}}var My="4.2.0",Fr=class extends Ve{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=Mc(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],$a(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);$a(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let b=y.sourceLayer,x=y.nodeIndex,v=y.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(v)}for(let y of this.inputs){let b=y.sourceLayer,x=y.nodeIndex,v=y.tensorIndex;Or(x===0,"input layer has >1 nodes"),Or(v===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(v)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let b=this.inputLayers[y];if(!(b instanceof Ul))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let t={},n={},r={},a={},s={},i=[],o=(y,b,x,v,I,N)=>{(v==null||I==null||N==null)&&(v=y.sourceLayer,I=y.nodeIndex,N=y.tensorIndex);let C=v.inboundNodes[I];if(x.indexOf(C)!==-1)throw new vr(`The tensor ${y.name} at layer "${v.name}" is part of a cycle.`);if(b.indexOf(C)!==-1)return;this.containerNodes.add(Fr.nodeKey(v,I)),v.id in s||(s[v.id]=Object.keys(s).length),x.indexOf(C)===-1&&x.push(C);let E=C.inboundLayers.length;for(let A=0;A<E;A++){let F=C.inputTensors[A],R=C.inboundLayers[A],S=C.nodeIndices[A],M=C.tensorIndices[A];o(F,b,x,R,S,M)}for(b.push(C);x.indexOf(C)>=0;)x.splice(x.indexOf(C),1);i.push(C)},l=[],p=[];for(let y of this.outputs)o(y,l,p);let u=i.slice().reverse();for(let y of u){n[y.id]=y,y.id in t||(t[y.id]=0);let b=t[y.id],x=r[y.outboundLayer.id]==null?0:r[y.outboundLayer.id];b=Math.max(b,x),r[y.outboundLayer.id]=b,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=b;for(let v=0;v<y.inboundLayers.length;v++){let I=y.inboundLayers[v],N=y.nodeIndices[v],C=I.inboundNodes[N],E=t[C.id]==null?0:t[C.id];t[C.id]=Math.max(b+1,E),n[C.id]=C}}let h={};for(let y in t){let b=t[y];b in h||(h[b]=[]),h[b].push(n[y])}let d={};for(let y in r){let b=r[y];b in d||(d[b]=[]),d[b].push(a[y])}let c=Object.keys(d).map(y=>parseInt(y,10)).sort(dh);this.layers=[];for(let y of c){let b=d[y];b.sort((x,v)=>{let I=s[x.id],N=s[v.id];return I<N?-1:I>N?1:0});for(let x of b)x instanceof Fr&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=d,c=Object.keys(h).map(y=>parseInt(y,10)).sort(dh);let f=this.inputs.slice(),m=[];for(let y of c)for(let b of h[y]){let x=b.outboundLayer;if(x!=null){for(let v of b.inputTensors)if(f.indexOf(v)===-1)throw new vr(`Graph disconnected: cannot obtain value for tensor ${v} at layer "${x.name}". The following previous layers were accessed without issue: ${m}`);for(let v of b.outputTensors)f.push(v);m.push(x.name)}}this.nodesByDepth=h;let g=this.layers.map(y=>y.name);for(let y of g){let b=g.filter(x=>x===y).length;if(b!==1)throw new vr(`The name "${y}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Gc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new V("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let s of this.layers)for(let i of s.weights){if(n[i.originalName]!=null)throw new V(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,r++}let a=[];for(let s in e){let i=s;if(n[s]==null){let o=s.split("/");i=o.slice(0,-2).concat([o[o.length-1]]).join("/")}if(n[i]!=null)a.push([n[i],e[s]]);else if(t)throw new V(`Provided weight data has no target variable: ${s}`);delete n[i]}if(t){let s=[];for(let i in n)s.push(i);if(s.length>0)throw new V(`${s.length} of ${r} weights are not set: ${s}`)}Ny(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${My}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=rm(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return W(()=>{e=ht(e);let n=new gs;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return fu(this.outputs,n,t)})}computeMask(e,t){return W(()=>{e=ht(e);let n;return t==null?n=Ds(null,e.length):n=ht(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=qh(e);if(t.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let o=this.inputLayers[i],l=t[i],p=o.name+"_0_0";n[p]=l}let r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(dh);if(r.length>1)for(let i of r){let o=this.nodesByDepth[i];for(let l of o){let p=l.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(p.id)!==-1)continue;let u=[];for(let f=0;f<l.inboundLayers.length;f++){let m=l.inboundLayers[f],g=l.nodeIndices[f],y=l.tensorIndices[f],b=`${m.name}_${g}_${y}`,x=n[b];u.push(x)}let h=p.computeOutputShape(Cn(u)),d=qh(h),c=p.inboundNodes.indexOf(l);for(let f=0;f<d.length;f++){let m=`${p.name}_${c}_${f}`;n[m]=d[f]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],p=this.outputLayersTensorIndices[i],u=`${o.name}_${l}_${p}`;s.push(u)}for(let i=0;i<s.length;i++){let o=s[i];Or(o in n),a.push(n[o])}return Cn(a)}runInternalGraph(e,t){t==null&&(t=Ds(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let l=this.inputs[o],p=e[o],u=t[o];n[l.id]=[p,u]}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(dh);for(let o of r){let l=this.nodesByDepth[o];for(let p of l){let u=p.outboundLayer,h=p.inputTensors,d=p.outputTensors,c=new Array;for(let f of h)f.id in n&&c.push(n[f.id]);if(c.length===h.length){let f={},m,g,y,b;if(p.callArgs!=null&&(f=p.callArgs),c.length===1){let[x,v]=c[0];f.mask==null&&(f.mask=v),y=ht(u.call(x,f)),b=ht(u.computeMask(x,v)),m=[x],g=[v]}else m=c.map(x=>x[0]),g=c.map(x=>x[1]),f.mask==null&&(f.mask=g),y=ht(u.call(m,f)),b=ht(u.computeMask(m,g));if(u.activityRegularizer)throw new Re("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<d.length;++x){let v=d[x],I=y[x],N=b[x];n[v.id]=[I,N]}}}}let a=[],s=[],i=[];for(let o of this.outputs){Or(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[l,p]=n[o.id];i.push(l.shape),a.push(l),s.push(p)}return[a,s,i]}buildNodeConversionMap(e){let t={},n;for(let r of this.layers){n=r instanceof Fr?1:0;for(let a=0;a<r.inboundNodes.length;a++){let s=Fr.nodeKey(r,a);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new V(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new V("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new V(`No such layer: ${e}`)}calculateLosses(){return W(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=Fr.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let s of this.layers){let i=s.getClassName(),o=s.getConfig(),l=[];for(let u=0;u<s.inboundNodes.length;u++){let h=s.inboundNodes[u],d=Fr.nodeKey(s,u),c={};if(this.containerNodes.has(d)){if(h.callArgs)try{JSON.stringify(h.callArgs),c=h.callArgs}catch{console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),c={}}if(h.inboundLayers.length>0){let f=[];for(let m=0;m<h.inboundLayers.length;m++){let g=h.inboundLayers[m],y=h.nodeIndices[m],b=h.tensorIndices[m],x=Fr.nodeKey(g,y),v=t[x];v==null&&(v=0),f.push([g.name,v,b,c])}l.push(f)}}}let p={};p.name=s.name,p.className=i,p.config=o,p.inboundNodes=l,n.push(p)}e.layers=n;let r=[];for(let s=0;s<this.inputLayers.length;s++){let i=this.inputLayers[s],o=this.inputLayersNodeIndices[s],l=Fr.nodeKey(i,o);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let u=this.inputLayersTensorIndices[s];r.push([i.name,p,u])}e.inputLayers=r;let a=[];for(let s=0;s<this.outputLayers.length;s++){let i=this.outputLayers[s],o=this.outputLayersNodeIndices[s],l=Fr.nodeKey(i,o);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let u=this.outputLayersTensorIndices[s];a.push([i.name,p,u])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(m,g){m.name in s?s[m.name].push(g):s[m.name]=[g]}function o(m,g){let y=[],b;for(let x of g){let v=x[0],I=x[1],N=x[2];if(b=x[3]==null?{}:x[3],!(v in a)){i(m,g);return}let C=a[v];if(C.inboundNodes.length<=I){i(m,g);return}let E=C.inboundNodes[I];y.push(E.outputTensors[N])}y.length>0&&m.apply(Cn(y),b)}function l(m){let g=m.name,y=Sr(m,t.customObjects!=null?t.customObjects:{});y.setFastWeightInitDuringBuild(r),a[g]=y,m.inboundNodes.forEach(b=>{if(!(b instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${b}`);i(y,b)})}let p=t.name,u=t.layers;for(let m of u)l(m);for(;!$z(s);)for(let m of u){let g=a[m.name];if(g.name in s){let y=s[g.name];delete s[g.name];for(let b of y)o(g,b)}}let h=[],d=[],c=t.inputLayers;for(let m of c){let g=m[0],y=m[1],b=m[2];Or(g in a);let x=a[g].inboundNodes[y].outputTensors;h.push(x[b])}let f=t.outputLayers;for(let m of f){let g=m[0],y=m[1],b=m[2];Or(g in a);let x=a[g].inboundNodes[y].outputTensors;d.push(x[b])}return new e({inputs:h,outputs:d,name:p})}get stateful(){if(this._stateful)throw new V("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){W(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function nB(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let a=[];return t.forEach(s=>{s in e?a.push(e[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function Pk(e,t){return nB(e,t,"classWeight")}async function Bk(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let a=W(()=>{if(e.shape.length===1)return Pr(e);if(e.shape.length===2){if(e.shape[1]>1)return _s(e,1);if(e.shape[1]===1)return P(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());_e(a);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Je(i,"float32")}else return null}function rB(e,t){return z(e,t)}var aB=32;function Wk(e,t){let n,r,a=t;n=a.xs,r=a.ys,w.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=Pw("input",e.inputNames,n),i=Pw("output",e.outputNames,r),o=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function Pw(e,t,n){if(n instanceof Pe)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(n[a]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function sB(e){if(e.length===3)throw new Re("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function iB(e,t,n){let r=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a=n.validationData!=null,s,i;if(a)if(Bw(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=sB(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),p;a?p=l.slice().concat(l.map(g=>"val_"+g)):p=l.slice();let u=Ak(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:c}=Rk(u,h,n.epochs,null,null,oB(t,n),null,a,p);d.setModel(e),e.history=c,await d.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await d.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){let x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:I}=Wk(e,x.value),N={};N.batch=b,N.size=v[0].shape[0],await d.onBatchBegin(b,N);let C=[];if(n.classWeight!=null){let F=Pk(n.classWeight,e.outputNames);for(let R=0;R<F.length;++R)C.push(await Bk(I[R],null,F[R]))}let E=v.concat(I).concat(C),A=o(E);_e(E);for(let F=0;F<l.length;++F){let R=l[F],S=A[F];N[R]=S,Ft(S)}await d.onBatchEnd(b,N),Ck(N),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(a){let v;Bw(n.validationData)?v=ht(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=ht(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?aB:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)g[`val_${e.metricsNames[I]}`]=v[I]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,g),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function oB(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function Bw(e){return typeof e.iterator=="function"}function lB(e){return typeof e.next=="function"}async function uB(e,t,n){n=n||{};let r=n.batches!=null,a=e.testFunction,s=[];if(n.verbose>0)throw new Re("Verbose mode is not implemented yet.");w.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=lB(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let p=await i.next();if(s=W(()=>{if(p.value){let{xs:u,ys:h}=Wk(e,p.value),d=u.concat(h),c=W(()=>a(d));if(_e(d),l===0)for(let m=0;m<c.length;++m)s.push(ve(0));let f=d[0].shape[0];for(let m=0;m<c.length;++m){let g=c[m],y=s[m];s[m]=W(()=>J(s[m],z(f,g))),l>0&&_e(y)}_e(c),o+=f,++l}return s}),p.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let p=0;p<s.length;++p){let u=s[p];s[p]=me(s[p],o),_e(u)}return Cn(s)}function Nf(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function lu(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>xs(r,t,n-t)):xs(e,t,n-t)}function am(e,t){return W(()=>e==null?null:Array.isArray(e)?e.map(n=>am(n,t)):xk(e,t.dtype==="int32"?t:se(t,"int32")))}function Tf(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Vk(e){let t=[];e instanceof Pe&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Ep(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function br(e,t){if(e==null)return;let n=[];if(t instanceof Pe)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(t!=null)for(let a in t){let s=t[a];n.push(s.id)}let r=[];if(e instanceof Pe)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{n.indexOf(a.id)===-1&&r.push(a)});else if(e!=null)for(let a in e){let s=e[a];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function pB(e){return e instanceof Pe}function sm(e){return Array.isArray(e)}function Ww(e){return!pB(e)&&!sm(e)}function Vw(e,t,n,r=!0,a=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(sm(e)&&e.length>0)i=!0;else if(Ww(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new V(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(Ww(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new V(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(sm(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new V(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=Vk(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let p=o.shape[l],u=n[i][l];if(u!=null&&u>=0&&p!==u)throw new V(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function hB(e,t,n){let r=$a(e.map(s=>s.shape[0]));r.sort();let a=$a(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(a.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!w.arraysEqual(r,a))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function dB(e,t,n){let r=[Hi,jc,Ou];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(i!=null){if(i===Ou&&s.shape[s.shape.length-1]===1)throw new V(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),p=o.slice(1);for(let u=0;u<l.length;++u){let h=l[u],d=p[u];if(d!=null&&h!==d)throw new V(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Uw(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let p=o.shape[l],u=n[i][l];if(u!=null&&u!==p)throw new V(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function cB(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let s=n.hasOwnProperty(a)?n[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var fB="layers-model",sa=class extends Fr{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");JP(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=ZP(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof fa))throw new V("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new V(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(Sf(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>Sf(s))}else{let s=Sf(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],bs("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=cB(e.metrics,this.outputNames),a=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};bs("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=r[s];(o=>{let l="",p,u,h;for(let d of o){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===jc?["accuracy","acc"].indexOf(d)!==-1?u=Ry:["crossentropy","ce"].indexOf(d)!==-1&&(u=Mk):this.lossFunctions[s]===Yh?["accuracy","acc"].indexOf(d)!==-1?u=Ok:["crossentropy","ce"].indexOf(d)!==-1&&(u=Lk):["accuracy","acc"].indexOf(d)!==-1?u=Fy:["crossentropy","ce"].indexOf(d)!==-1&&(u=Dy);let m;["accuracy","acc"].indexOf(d)!==-1?m="acc":["crossentropy","ce"].indexOf(d)!==-1&&(m="ce"),h=u,p=l+m}else h=XP(d),p=l+mh(d);let c;bs(p,()=>{c=h}),a(s,p,c)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;Nf(r);let a=!0,s=this.standardizeUserDataXY(e,t,a,r);try{let i=s[0].concat(s[1]);this.makeTestFunction();let o=this.testFunction,l=this.testLoop(o,i,r,n.verbose,n.steps);return Cn(l)}finally{br(s[0],e),br(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),uB(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new V(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new gs;if(e instanceof Pe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new V(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=fu(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Ds(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=a[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((a,s)=>{a==null&&r.push(e[s])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return W(()=>{let r=this.checkNumSamples(e);if(n)throw new Re("Verbose predictLoop() is not implemented yet.");let a=Tf(r,t),s=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)W(()=>{let o=a[i][0],l=a[i][1],p=lu(e,o,l),u=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)u.push({key:this.inputs[d],value:p[d]});else u.push({key:this.inputs[0],value:p});let h=new gs(u);return fu(this.outputs,h)}).forEach((o,l)=>s[l].push(o));return Cn(s.map(i=>nt(i,0)))})}predict(e,t={}){let n=Vk(e);Uw(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return Nf(r),this.predictLoop(n,r)}finally{br(n,e)}}predictOnBatch(e){Uw(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new vr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===Yh?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=Vw(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Vw(t,this.feedOutputNames,a,!1,"target"),hB(e,t),dB(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let p=Pk(r,this.outputNames);l=[];for(let u=0;u<p.length;++u)l.push(await Bk(o[u],null,p[u]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return W(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Re("Verbose mode is not implemented yet.");if(a!=null)throw new Re("steps mode in testLoop() is not implemented yet");{let o=Tf(s,n),l=Je(Tr(0,s));for(let p=0;p<o.length;++p){let u=o[p][0],h=o[p][1],d=xs(l,u,h-u),c=am(t,d),f=e(c);if(p===0)for(let m=0;m<f.length;++m)i.push(ve(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=J(i[m],z(h-u,g))}}for(let p=0;p<i.length;++p)i[p]=me(i[p],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(_w(e,r)>1){let s=_w(e.slice(0,n),r);a+=`_${s}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let p=[];for(let c=0;c<this.inputs.length;++c)p.push({key:this.inputs[c],value:n[c]});let u=new gs(p),h=fu(this.outputs,u,{training:!0}),d;for(let c=0;c<this.lossFunctions.length;++c){let f=this.lossFunctions[c],m=f(r[c],h[c]);a[c]!=null&&(m=rB(m,a[c]));let g=yt(m);t.push(g),c===0?d=m:d=J(d,m)}for(let c=0;c<this.metricsTensors.length;++c){let f;if(this.outputs.length>1&&c<this.outputs.length)f=t[c];else{let m=this.metricsTensors[c][0],g=this.metricsTensors[c][1];f=yt(m(r[g],h[g]))}Ft(f),s.push(f)}return d=yt(d),this.calculateLosses().forEach(c=>{d=J(d,c)}),d},o=this.collectedTrainableWeights.map(p=>p.read()),l=!0;return[this.optimizer_.minimize(i,l,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>W(()=>{let t=[],n,r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let i=new gs(s),o=fu(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],u=yt(p(a[l],o[l]));l===0?n=u:n=J(n,u),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],u=this.metricsTensors[l][1],h=yt(p(a[u],o[u]));t.push(h)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,s,i,o,l,p,u,h;try{let d=n.batchSize==null?32:n.batchSize;Nf(d);let c=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,c,d);r=f[0],a=f[1],h=f[2];let m=!1,g;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Re("validationData including sample weights is not supported yet."):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let C=!0,E=await this.standardizeUserData(o,l,null,null,C,d);p=E[0],u=E[1],g=p.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let C=Math.floor(r[0].shape[0]*(1-n.validationSplit)),E=r[0].shape[0];p=lu(r,C,E),s=r,r=lu(r,0,C),u=lu(a,C,E),i=a,a=lu(a,0,C),g=p.concat(u)}else n.validationSteps!=null&&(m=!0);let y=r.concat(a).concat(h);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),x=this.getDedupedMetricsNames(),v,I;m?(this.makeTestFunction(),v=this.testFunction,I=x.slice().concat(x.map(C=>"val_"+C))):(v=null,g=[],I=x.slice());let N=Ak(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,x,d,n.epochs,n.verbose,N,v,g,n.shuffle,I,n.initialEpoch,null,null)}finally{this.isTraining=!1,br(r,e),br(a,t),br(s,e),br(i,t),br(p,o),br(u,l),h!=null&&_e(h)}}async fitLoop(e,t,n,r,a,s,i,o,l,p,u,h,d,c){r==null&&(r=32),a==null&&(a=1),p==null&&(p=!0),h==null&&(h=0);let f=!1;if(o!=null&&l!=null&&(f=!0),c!=null&&(f=!0,d==null))throw new V("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,d,"steps_per_epoch"),g;m!=null&&(g=Tr(0,m)),s==null&&(s=1);let{callbackList:y,history:b}=Rk(i,s,a,h,m,d,r,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<a;++x){await y.onEpochBegin(x);let v={};if(d!=null)throw new Re("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Re("batch shuffling is not implemneted yet");p&&w.shuffle(g);let I=Je(g),N=Tf(m,r);for(let C=0;C<N.length;++C){let E={};if(await y.onBatchBegin(C,E),W(()=>{let A=N[C][0],F=N[C][1],R=xs(I,A,F-A);E.batch=C,E.size=F-A;let S=am(t,R),M=e(S);for(let B=0;B<n.length;++B){let U=n[B],G=M[B];E[U]=G,Ft(G)}if(C===N.length-1&&f){let B=this.testLoop(o,l,r);for(let U=0;U<n.length;++U){let G=n[U],K=B[U];Ft(K),v["val_"+G]=K}}}),await y.onBatchEnd(C,E),Ck(E),this.stopTraining_)break}I.dispose()}if(await y.onEpochEnd(x,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return iB(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return _e(s),br(n[0],e),br(n[1],t),Cn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Hh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Hh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ea(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ea(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=ea(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ea(mh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ea(mh(e)));{let e={};for(let t in this.metrics)e[t]=ea(mh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Lu(e.optimizer_config),n=Sr(t),r;if(typeof e.loss=="string")r=cs(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(s=>cs(s));else if(e.loss!=null){r={};for(let s in e.loss)r[s]=cs(e.loss[s])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(s=>cs(s));else if(e.metrics!=null){a={};for(let s in e.metrics)a[s]=cs(e.metrics[s])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){let i=Qt.getSaveHandlers(e);if(i.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new V(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(e.save==null)throw new V("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Qt.encodeWeights(this.getNamedWeights(t)),r=!1,a=null,s={modelTopology:this.toJSON(a,r),format:fB,generatedBy:`TensorFlow.js tfjs-layers v${My}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){s.trainingConfig=this.getTrainingConfig();let i="optimizer",{data:o,specs:l}=await Qt.encodeWeights(await this.optimizer.getWeights(),i);n.specs.push(...l),n.data=Qt.concatenateArrayBuffers([n.data,o])}return this.userDefinedMetadata!=null&&(zw(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,e.save(s)}setUserDefinedMetadata(e){zw(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};sa.className="Model";ne.registerClass(sa);var Uk=class extends sa{};Uk.className="Functional";ne.registerClass(Uk);async function mB(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=Lu(n),a=Sr(r,t);if(e.weightsManifest!=null){let s=await Qt.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),i={};for(let o of a.weights)i[o.originalName]=s[o.originalName];a.loadWeights(i),_e(s)}return a}async function gB(e,t){if(t==null&&(t={}),typeof e=="string"){let n=Qt.getLoadHandlers(e,t);if(n.length===0)n.push(Qt.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return yB(e,void 0,t)}async function yB(e,t,n){if(n==null&&(n={}),e.load==null)throw new V("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;a.model_config!=null&&(a=a.model_config);let s=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&s,o=Sr(Lu(a),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new V("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:p,optimizerWeights:u}=bB(r.weightData,r.weightSpecs);o.loadWeights(p,s),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),_e(p),_e(u.map(h=>h.tensor))}return o}function bB(e,t){let n=Qt.decodeWeights(e,t),r={},a=[];return t.forEach(s=>{s.group==="optimizer"?a.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:a}}var ko=class extends sa{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Mc("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new V(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof ko||e instanceof sa,n;if(t){if(n=e,n.outputs.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new V("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new V("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=Ik({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=kk(this.outputs[0])}this.inboundNodes=[],new Gc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ds(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Xe(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new sa({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new vr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new vr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new vr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new vr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new V("Legacy serialization format not supported yet.");a=t}else w.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof ko))throw new Re(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let o of a){let l=Sr(o,void 0,r);r&&l.setFastWeightInitDuringBuild(!0),i.add(l)}return i}set stopTraining(e){if(this.model==null)throw new V("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new V("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};ko.className="Sequential";ne.registerClass(ko);function xB(e){return new sa(e)}function wB(e){return new ko(e)}function Gk(e){return Ik(e)}function vB(e,t){ur.registerCallbackConstructor(e,t)}var Rn=class extends ne.Serializable{getConfig(){return{}}},Hk=class extends Rn{apply(e,t=1){return Hz(e,t)}};Hk.className="elu";ne.registerClass(Hk);var jk=class extends Rn{apply(e){return wc(e)}};jk.className="selu";ne.registerClass(jk);var qk=class extends Rn{apply(e){return Ye(e)}};qk.className="relu";ne.registerClass(qk);var Kk=class extends Rn{apply(e){return W(()=>zl(6,Ye(e)))}};Kk.className="relu6";ne.registerClass(Kk);var Xk=class extends Rn{apply(e){return e}};Xk.className="linear";ne.registerClass(Xk);var Zk=class extends Rn{apply(e){return dr(e)}};Zk.className="sigmoid";ne.registerClass(Zk);var Jk=class extends Rn{apply(e){return qz(e)}};Jk.className="hardSigmoid";ne.registerClass(Jk);var Yk=class extends Rn{apply(e){return Vi(e)}};Yk.className="softplus";ne.registerClass(Yk);var Qk=class extends Rn{apply(e){return jz(e)}};Qk.className="softsign";ne.registerClass(Qk);var eI=class extends Rn{apply(e){return $s(e)}};eI.className="tanh";ne.registerClass(eI);var Oy=class extends Rn{apply(e,t=-1){return Ja(e,t)}};Oy.className="softmax";ne.registerClass(Oy);var tI=class extends Rn{apply(e,t=-1){return dc(e,t)}};tI.className="logSoftmax";ne.registerClass(tI);var nI=class extends Rn{apply(e,t=1){return W(()=>z(dr(z(e,t)),e))}};nI.className="swish";ne.registerClass(nI);var rI=class extends Rn{apply(e){return W(()=>z(e,$s(Vi(e))))}};rI.className="mish";ne.registerClass(rI);function La(e){return e.getClassName()}function Cf(e,t={}){return _p(e,ne.SerializationMap.getMap().classNameMap,t,"activation")}function za(e){if(e==null){let t={};return t.className="linear",t.config={},Cf(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},Cf(t)}else return e instanceof Rn?e:Cf(e)}function Ly(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var aI=class extends ne.Serializable{},Fp=class extends aI{constructor(e){super(),Ly(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return W(()=>{let t=bt([1]);return this.hasL1&&(t=J(t,ge(z(this.l1,Ct(e))))),this.hasL2&&(t=J(t,ge(z(this.l2,$p(e))))),P(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Fp.className="L1L2";ne.registerClass(Fp);function kB(e){return Ly(e),new Fp({l1:e!=null?e.l1:null,l2:0})}function IB(e){return Ly(e),new Fp({l2:e!=null?e.l2:null,l1:0})}var Gw={l1l2:"L1L2"};function at(e){return my(e)}function Hw(e,t={}){return _p(e,ne.SerializationMap.getMap().classNameMap,t,"regularizer")}function mt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in Gw?Gw[e]:e,config:{}};return Hw(t)}else return e instanceof aI?e:Hw(e)}var zy=class extends Ve{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ce(e);let n=Ye(e);return this.maxValue!=null&&(n=an(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};zy.className="ReLU";ne.registerClass(zy);var Py=class extends Ve{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ce(e);return bp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Py.className="LeakyReLU";ne.registerClass(Py);var By=class extends Ve{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ft(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=mt(e.alphaRegularizer),this.alphaConstraint=Pt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Xe(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new _t({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ce(e),Ip(e,this.alpha.read())}getConfig(){let e={alphaInitializer:xt(this.alphaInitializer),alphaRegularizer:at(this.alphaRegularizer),alphaConstraint:zt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};By.className="PReLU";ne.registerClass(By);var Wy=class extends Ve{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Re(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ce(e);return Dl(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Wy.className="ELU";ne.registerClass(Wy);var Vy=class extends Ve{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ce(e);return z(n,se(wn(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Vy.className="ThresholdedReLU";ne.registerClass(Vy);var Uy=class extends Ve{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Oy().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Ce(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Uy.className="Softmax";ne.registerClass(Uy);function uo(e,t,n){if(typeof e=="number")return Ds(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!Wz(a))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Nr(e,t,n,r,a=1){if(e==null)return e;let s=t+(t-1)*(a-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+r-1)/r)}function Lr(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Oa([n-t,0]);else if(r==="same")e=e*t;else throw new V(`Unsupport padding mode: ${r}.`);return e}function Gy(e,t){return W(()=>(Nt(t),t==="channelsFirst"?Fe(e,[0,2,3,1]):e))}function sI(e,t){return W(()=>(Nt(t),t==="channelsFirst"?Fe(e,[0,2,3,4,1]):e))}function SB(e,t,n,r=1,a="valid",s,i=1){return W(()=>{if(s==null&&(s=Cr()),Nt(s),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(e=Fe(e,[0,2,1])),a==="causal")throw new Re("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=sc(e,t,r,a==="same"?"same":"valid","NWC",i);return n!=null&&(o=$r(o,n)),o})}function jw(e,t,n,r=[1,1],a="valid",s,i,o=null){return W(()=>{if(s==null&&(s=Cr()),Nt(s),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Gy(e,s);if(a==="causal")throw new Re("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=bo.conv2d({x:l,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Fe(l,[0,3,1,2])),l})}function NB(e,t,n,r=[1,1,1],a="valid",s,i){return W(()=>{if(s==null&&(s=Cr()),Nt(s),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=sI(e,s);if(a==="causal")throw new Re("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=gg(o,t,r,a==="same"?"same":"valid","NDHWC",i),n!=null&&(o=$r(o,n)),s==="channelsFirst"&&(o=Fe(o,[0,4,1,2,3])),o})}var Hy=class extends Ve{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Hy.verifyArgs(t),this.rank=e,Ut(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Re(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=uo(t.kernelSize,e,"kernelSize"),this.strides=uo(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,ar(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Nt(this.dataFormat),this.activation=za(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=ft(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Pt(t.biasConstraint),this.biasRegularizer=mt(t.biasRegularizer),this.activityRegularizer=mt(t.activityRegularizer),this.dilationRate=uo(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Or("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!gy(e.kernelSize,"number",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:La(this.activation),useBias:this.useBias,biasInitializer:xt(this.biasInitializer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),biasConstraint:zt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Dp=class extends Hy{constructor(e,t){super(e,t),this.kernel=null,Dp.verifyArgs(t),this.filters=t.filters,Ut(this.filters,"filters"),this.kernelInitializer=ft(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Pt(t.kernelConstraint),this.kernelRegularizer=mt(t.kernelRegularizer)}build(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return W(()=>{e=Ce(e);let n,r=this.bias==null?null:this.bias.read(),a=ck(this.activation.getClassName());if(a!=null&&this.rank===2)n=jw(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)n=SB(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=jw(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=NB(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Re("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Xe(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let s=Nr(n[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);t.push(s)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:xt(this.kernelInitializer),kernelRegularizer:at(this.kernelRegularizer),kernelConstraint:zt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Mp=class extends Dp{constructor(e){super(2,e),Mp.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!gy(e.kernelSize,"number",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Mp.className="Conv2D";ne.registerClass(Mp);var Op=class extends Dp{constructor(e){super(3,e),Op.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};Op.className="Conv3D";ne.registerClass(Op);var jy=class extends Mp{constructor(e){if(super(e),this.inputSpec=[new _t({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==4)throw new V("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new _t({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return W(()=>{let n=Ce(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=r[s],l=r[i],p=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],d=this.strides[1],c=Lr(o,h,p,this.padding),f=Lr(l,d,u,this.padding),m=[a,c,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Fe(n,[0,2,3,1]));let g=ic(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Fe(g,[0,3,1,2])),this.bias!=null&&(g=$r(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Lr(t[r],o,s,this.padding),t[a]=Lr(t[a],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};jy.className="Conv2DTranspose";ne.registerClass(jy);var qy=class extends Op{constructor(e){if(super(e),this.inputSpec=[new _t({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==5)throw new V("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new _t({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return W(()=>{let n=Ce(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=r[o],p=r[s],u=r[i],h=this.kernelSize[0],d=this.kernelSize[1],c=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=Lr(l,f,h,this.padding),b=Lr(p,m,d,this.padding),x=Lr(u,g,c,this.padding),v=[a,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Fe(n,[0,2,3,4,1]));let I=yg(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Fe(I,[0,4,1,2,3])),this.bias!==null&&(I=$r(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,r,a,s;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=Lr(t[r],p,i,this.padding),t[a]=Lr(t[a],u,o,this.padding),t[s]=Lr(t[s],h,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};qy.className="Conv3DTranspose";ne.registerClass(qy);var iI=class extends Dp{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ft(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=mt(t.depthwiseRegularizer),this.depthwiseConstraint=Pt(t.depthwiseConstraint),this.pointwiseInitializer=ft(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=mt(t.pointwiseRegularizer),this.pointwiseConstraint=Pt(t.pointwiseConstraint)}build(e){if(e=Xe(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new _t({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return W(()=>{e=Ce(e);let n;if(this.rank===1)throw new Re("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Fe(e,[0,2,3,1])),n=Bl(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=$r(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Fe(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=xt(this.depthwiseInitializer),e.pointwiseInitializer=xt(this.pointwiseInitializer),e.depthwiseRegularizer=at(this.depthwiseRegularizer),e.pointwiseRegularizer=at(this.pointwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseConstraint),e.pointwiseConstraint=zt(this.pointwiseConstraint),e}};iI.className="SeparableConv";var Ky=class extends iI{constructor(e){super(2,e)}};Ky.className="SeparableConv2D";ne.registerClass(Ky);var qc=class extends Dp{constructor(e){super(1,e),qc.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!gy(e.kernelSize,"number",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};qc.className="Conv1D";ne.registerClass(qc);var Xy=class extends Ve{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return W(()=>{if(e=Ce(e),this.dataFormat==="channelsLast"){let n=fh(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return fh(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=fh(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return fh(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Xy.className="Cropping2D";ne.registerClass(Xy);var Zy=class extends Ve{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,zz(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return W(()=>{let n=Ce(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Fe(n,[0,2,3,1]);let a=this.size[0]*r[2],s=this.size[1]*r[3],i=this.interpolation==="nearest"?wr.resizeNearestNeighbor(n,[a,s]):wr.resizeBilinear(n,[a,s]);return Fe(i,[0,3,1,2])}else{let a=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?wr.resizeNearestNeighbor(n,[a,s]):wr.resizeBilinear(n,[a,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};Zy.className="UpSampling2D";ne.registerClass(Zy);function TB(e,t,n=[1,1],r="valid",a,s){return W(()=>{a==null&&(a=Cr()),Nt(a);let i=Gy(e,a);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Wi(i,t,n,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(i=Fe(i,[0,3,1,2])),i})}var Jy=class extends Hy{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ft(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Pt(e.depthwiseConstraint),this.depthwiseRegularizer=mt(e.depthwiseRegularizer)}build(e){if(e=Xe(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return W(()=>{e=Ce(e);let n=TB(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=$r(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Nr(t,this.kernelSize[0],this.padding,this.strides[0]),s=Nr(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=xt(this.depthwiseInitializer),e.depthwiseRegularizer=at(this.depthwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseRegularizer),e}};Jy.className="DepthwiseConv2D";ne.registerClass(Jy);function oI(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new V("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function lI(e,t,n,r=!1,a,s,i=!1,o=!1){return W(()=>{let l=t.shape.length;if(l<3)throw new V(`Input should be at least 3D, but is ${l}D.`);let p=[1,0].concat(Tr(2,l));if(t=Fe(t,p),s!=null)throw new Re("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=se(se(a,"bool"),"float32"),a.rank===l-1&&(a=Jt(a,-1)),a=Fe(a,p)),r&&(t=rr(t,0),a!=null&&(a=rr(a,0)));let u=[],h,d=n,c=t.shape[0],f=St(t),m;a!=null&&(m=St(a));for(let y=0;y<c;++y){let b=f[y],x=W(()=>e(b,d));if(a==null)h=x[0],d=x[1];else{let v=W(()=>{let I=m[y],N=de(Gn(I),I),C=J(z(x[0],I),z(d[0],N)),E=d.map((A,F)=>J(z(x[1][F],I),z(A,N)));return{output:C,newStates:E}});h=v.output,d=v.newStates}o&&u.push(h)}let g;return o&&(g=Ot(u,1)),[h,g,d]})}var Kr=class extends Ve{constructor(e){super(e);let t;if(e.cell==null)throw new V("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Zc({cells:e.cell}):t=e.cell,t.stateSize==null)throw new V("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new _t({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Tr(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){em(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){let a=[];for(let s of t)a.push([e[0],s]);return[r].concat(a)}else return r}computeMask(e,t){return W(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let r=this.states.map(a=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Re("Constants support is not implemented in RNN yet.");em(e)&&(e=e[0]),e=e;let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new _t({shape:[t,null,...n]});let r=[e[0]].concat(e.slice(2));this.cell.build(r);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(s=>s.shape[s.shape.length-1]),a))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(s=>new _t({shape:[null,s]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){W(()=>{if(!this.stateful)throw new Qr("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>bt([n,r])):this.states_=[bt([n,this.cell.stateSize])];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>bt([n,r])):this.states_[0]=bt([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let r=0;r<this.states_.length;++r){let a=e[r],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[n,s];if(!w.arraysEqual(a.shape,i))throw new V(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${a.shape}`);this.states_[r]=a}}this.states_=this.states_.map(r=>Ft(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=oI(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(n!=null){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let o of n)this.stateSpec.push(new _t({shape:o.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof kr){let o=[e].concat(s),l=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=l;let u=super.apply(o,t);return this.inputSpec=p,u}else return super.apply(e,t)}call(e,t){return W(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;e=Ce(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new V(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=lI((d,c)=>{let f=this.cell.call([d].concat(c),i);return[f[0],f.slice(1)]},e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],p=o[1],u=o[2];this.stateful&&this.resetStates(u,r);let h=this.returnSequences?p:l;return this.returnState?[h].concat(u):h})}getInitialState(e){return W(()=>{let t=bt(e.shape);return t=ge(t,[1,2]),t=Ep(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Yf(t,[1,n]):t):this.cell.stateSize>1?[Yf(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Kr.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=t.cell,a=Sr(r,n);return new e(Object.assign(t,{cell:a}))}};Kr.className="RNN";ne.registerClass(Kr);var Lp=class extends Ve{},Kc=class extends Lp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ut(this.units,"units"),this.activation=za(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=wo([1,Oa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=wo([1,Oa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return W(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pa({ones:()=>Gn(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pa({ones:()=>Gn(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?a=Wr(z(e,s),this.kernel.read()):a=Wr(e,this.kernel.read()),this.bias!=null&&(a=$r(a,this.bias.read())),i!=null&&(n=z(n,i));let o=J(a,Wr(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:La(this.activation),useBias:this.useBias,kernelInitializer:xt(this.kernelInitializer),recurrentInitializer:xt(this.recurrentInitializer),biasInitializer:xt(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};Kc.className="SimpleRNNCell";ne.registerClass(Kc);var Yy=class extends Kr{constructor(e){e.cell=new Kc(e),super(e)}call(e,t){return W(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}};Yy.className="SimpleRNN";ne.registerClass(Yy);var Xc=class extends Lp{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new V("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ut(this.units,"units"),this.activation=za(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=za(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=wo([1,Oa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=wo([1,Oa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return W(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pa({ones:()=>Gn(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pa({ones:()=>Gn(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=z(e,a[0]));let p=Wr(e,this.kernel.read());this.useBias&&(p=$r(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,s[0]));let u=this.recurrentKernel.read(),[h,d]=_n(u,[2*this.units,this.units],u.rank-1),c=Wr(r,h),[f,m,g]=_n(p,3,p.rank-1),[y,b]=_n(c,2,c.rank-1);i=this.recurrentActivation.apply(J(f,y)),o=this.recurrentActivation.apply(J(m,b));let x=Wr(z(o,r),d);l=this.activation.apply(J(g,x));let v=J(z(i,r),z(J(1,dt(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:La(this.activation),recurrentActivation:La(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xt(this.kernelInitializer),recurrentInitializer:xt(this.recurrentInitializer),biasInitializer:xt(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Xc.className="GRUCell";ne.registerClass(Xc);var Qy=class extends Kr{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Xc(e),super(e)}call(e,t){return W(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Qy.className="GRU";ne.registerClass(Qy);var zp=class extends Lp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ut(this.units,"units"),this.activation=za(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=za(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ft(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=mt(e.kernelRegularizer),this.recurrentRegularizer=mt(e.recurrentRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=wo([1,Oa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=wo([1,Oa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Xe(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,s=this.units;r=new(t=class extends gr{apply(i,o){let l=a.apply([s]),p=new Lc().apply([s]),u=a.apply([s*2]);return $w($w(l,p),u)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return W(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pa({ones:()=>Gn(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pa({ones:()=>Gn(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,p,u;0<this.dropout&&this.dropout<1&&(e=z(e,s[0]));let h=Wr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,i[0])),h=J(h,Wr(r,this.recurrentKernel.read())),this.useBias&&(h=$r(h,this.bias.read()));let[d,c,f,m]=_n(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(c),p=J(z(l,a),z(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);let g=z(u,this.activation.apply(p));return[g,g,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:La(this.activation),recurrentActivation:La(this.recurrentActivation),useBias:this.useBias,kernelInitializer:xt(this.kernelInitializer),recurrentInitializer:xt(this.recurrentInitializer),biasInitializer:xt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:at(this.kernelRegularizer),recurrentRegularizer:at(this.recurrentRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};zp.className="LSTMCell";ne.registerClass(zp);var eb=class extends Kr{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new zp(e),super(e)}call(e,t){return W(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};eb.className="LSTM";ne.registerClass(eb);var Zc=class extends Lp{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return W(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(let i of a.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){em(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{bs(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(Sr(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return tm(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],a[s]])}Ny(t)}};Zc.className="StackedRNNCells";ne.registerClass(Zc);function Pa(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):wk(t(),n),o=()=>Ap(i,t,r);return!a||a<=1?Ft(o().clone()):Array(a).fill(void 0).map(o).map(l=>Ft(l.clone()))}var CB=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n},uI=class extends Kr{constructor(e){if(e.unroll)throw new Re("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Re("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new _t({ndim:5})]}call(e,t){return W(()=>{if(this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return W(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=bt(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){W(()=>{if(!this.stateful)throw new Qr("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>bt(a)):this.states_=[bt(a)];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>bt(a)):this.states_[0]=bt(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=a;if(!w.arraysEqual(i.shape,o))throw new V(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ft(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],p=e[o?4:3],u=Nr(l,r[0],a,s[0],i[0]),h=Nr(p,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}};uI.className="ConvRNN2D";var Jc=class extends zp{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ut(this.filters,"filters"),this.kernelSize=uo(n,2,"kernelSize"),this.kernelSize.forEach(o=>Ut(o,"kernelSize")),this.strides=uo(r||1,2,"strides"),this.strides.forEach(o=>Ut(o,"strides")),this.padding=a||"valid",ar(this.padding),this.dataFormat=s||"channelsLast",Nt(this.dataFormat),this.dilationRate=uo(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>Ut(o,"dilationRate"))}build(e){var t;e=Xe(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,p=this.filters;o=new(t=class extends gr{apply(u,h){let d=l.apply([p]),c=Bn([p]),f=l.apply([p*2]);return yy([d,c,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return W(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Pa({ones:()=>Gn(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(X,ee,Z)=>!ee||!ee[Z]?X:z(ee[Z],X),p=l(r,o,0),u=l(r,o,1),h=l(r,o,2),d=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Pa({ones:()=>Gn(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let c=this.recurrentDropoutMask,f=l(a,c,0),m=l(a,c,1),g=l(a,c,2),y=l(a,c,3),b=3,[x,v,I,N]=_n(this.kernel.read(),i,b),[C,E,A,F]=this.useBias?_n(this.bias.read(),i):[null,null,null,null];p=this.inputConv(p,x,C,this.padding),u=this.inputConv(u,v,E,this.padding),h=this.inputConv(h,I,A,this.padding),d=this.inputConv(d,N,F,this.padding);let[R,S,M,B]=_n(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,R),m=this.recurrentConv(m,S),g=this.recurrentConv(g,M),y=this.recurrentConv(y,B);let U=this.recurrentActivation.apply(J(p,f)),G=this.recurrentActivation.apply(J(u,m)),K=J(z(G,s),z(U,this.activation.apply(J(h,g)))),H=z(this.recurrentActivation.apply(J(d,y)),this.activation.apply(K));return[H,H,K]})}getConfig(){let e=super.getConfig(),t=CB(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),n)}inputConv(e,t,n,r){let a=cn(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?$r(a,n,this.dataFormat):a}recurrentConv(e,t){return cn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Jc.className="ConvLSTM2DCell";ne.registerClass(Jc);var tb=class extends uI{constructor(e){let t=new Jc(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};tb.className="ConvLSTM2D";ne.registerClass(tb);var Yc=class extends Ve{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return Ap(()=>wk(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Yc.className="Dropout";ne.registerClass(Yc);var nb=class extends Yc{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};nb.className="SpatialDropout1D";ne.registerClass(nb);var rb=class extends Ve{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ut(this.units,"units"),this.activation=za(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ft(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ft(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Pt(e.kernelConstraint),this.biasConstraint=Pt(e.biasConstraint),this.kernelRegularizer=mt(e.kernelRegularizer),this.biasRegularizer=mt(e.biasRegularizer),this.activityRegularizer=mt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Xe(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Xe(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=ck(this.activation.getClassName()),a;return r!=null?a=Wr(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Wr(n,this.kernel.read()),this.bias!=null&&(a=$r(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:La(this.activation),useBias:this.useBias,kernelInitializer:xt(this.kernelInitializer),biasInitializer:xt(this.biasInitializer),kernelRegularizer:at(this.kernelRegularizer),biasRegularizer:at(this.biasRegularizer),activityRegularizer:at(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),biasConstraint:zt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};rb.className="Dense";ne.registerClass(rb);var ab=class extends Ve{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xe(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Aa(e,1)]}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=Fe(n,r)}return Gz(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};ab.className="Flatten";ne.registerClass(ab);var sb=class extends Ve{constructor(e){super(e),this.supportsMasking=!0,this.activation=za(e.activation)}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);return this.activation.apply(n)})}getConfig(){let e={activation:La(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};sb.className="Activation";ne.registerClass(sb);var ib=class extends Ve{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return W(()=>(e=Ce(e),Vz(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};ib.className="RepeatVector";ne.registerClass(ib);var ob=class extends Ve{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new V("Can only specifiy one unknown dimension.");else a*=l}let i=Aa(e);if(s!==null){if(a===0||i%a!==0)throw new V(n);r[s]=i/a}else if(i!==a)throw new V(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return P(n,a)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};ob.className="Reshape";ne.registerClass(ob);var lb=class extends Ve{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Tr(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new _t({ndim:this.dims.length+1})]}computeOutputShape(e){e=Xe(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Fe(Ce(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};lb.className="Permute";ne.registerClass(lb);var ub=class extends Ve{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ce(e),r=-1;return Ru(Rs(n,this.maskValue),r)}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=-1,a=!0,s=Ru(Rs(n,this.maskValue),r,a);return z(n,se(s,n.dtype))})}};ub.className="Masking";ne.registerClass(ub);var pb=class extends Ve{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ht(e.inputLength))}this.inputDim=e.inputDim,Ut(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ut(this.outputDim,"outputDim"),this.embeddingsInitializer=ft(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=mt(e.embeddingsRegularizer),this.activityRegularizer=mt(e.activityRegularizer),this.embeddingsConstraint=Pt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return W(()=>this.maskZero?(e=Ce(e),Rs(e,He(e))):null)}computeOutputShape(e){if(e=Xe(e),this.inputLength==null)return[...e,this.outputDim];let t=ht(this.inputLength);if(t.length!==e.length-1)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(a!=null&&s!=null&&a!==s)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);n.dtype!=="int32"&&(n=pa(n,"int32"));let r=xk(this.embeddings.read(),P(n,[n.size]));return P(r,Xe(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:xt(this.embeddingsInitializer),embeddingsRegularizer:at(this.embeddingsRegularizer),activityRegularizer:at(this.activityRegularizer),embeddingsConstraint:zt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};pb.className="Embedding";ne.registerClass(pb);var ji=class extends Ve{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Re}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(a==null||s==null||a<0||s<0)n.push(null);else if(a===1)n.push(s);else if(s===1)n.push(a);else{if(a!==s)throw new V("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Xe(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=$a(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let s=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=e.map(a=>a.length);e.indexOf(null)===-1&&$a(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return W(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){let a=Oa(r);for(let s of e){let i=s.rank;for(let o=0;o<a-i;++o)s=Ep(s,1);n.push(s)}return this.mergeFunction(n)}else{let a=!1;for(let o of e){let l=o.rank;if(l==null){let p=o.shape,u=p[0],h=p.slice(1).concat([u]),d=P(o,[u].concat(Aa(p.slice(1))));d=Fe(d,[1,0]),d=P(d,h),n.push(d),a=!0}else if(l>1){let p=Tr(1,l).concat([0]);n.push(Fe(o,p)),a=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(a){if(i==null){let o=s.shape,l=o.length,p=o[l-1],u=[p].concat(o.slice(0,o.length-1));s=P(Fe(P(s,[-1,p]),[1,0]),u)}else if(i>1){let o=[i-1].concat(Tr(0,i-1));s=Fe(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=$a(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return W(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an Array");if(!Array.isArray(e))throw new V("`inputs` should be an Array");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Jt(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=cr(n,t[r]);return n})}},hb=class extends ji{constructor(e){super(e)}mergeFunction(e){return W(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=J(t,e[n]);return t})}};hb.className="Add";ne.registerClass(hb);var db=class extends ji{constructor(e){super(e)}mergeFunction(e){return W(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=z(t,e[n]);return t})}};db.className="Multiply";ne.registerClass(db);var cb=class extends ji{constructor(e){super(e)}mergeFunction(e){return W(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=J(t,e[n]);return z(1/e.length,t)})}};cb.className="Average";ne.registerClass(cb);var fb=class extends ji{constructor(e){super(e)}mergeFunction(e){return W(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=jr(t,e[n]);return t})}};fb.className="Maximum";ne.registerClass(fb);var mb=class extends ji{constructor(e){super(e)}mergeFunction(e){return W(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=zl(t,e[n]);return t})}};mb.className="Minimum";ne.registerClass(mb);var gb=class extends ji{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let a=e[r].slice();a.splice(this.axis,1);let s=!1;for(let i of n)if(w.arraysEqual(i,a)){s=!0;break}s||n.push(a)}if(n.length>1)throw new V("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return W(()=>yy(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new V("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return W(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<e.length;++s)t[s]==null?r.push(se(Gn(e[s]),"bool")):t[s].rank<e[s].rank?r.push(Jt(t[s],-1)):r.push(t[s]);let a=nt(r,this.axis);return ac(a,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};gb.className="Concatenate";ne.registerClass(gb);function uu(e,t){for(;e<0;)e+=t;return e}function _B(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Re("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Re("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;n==null&&(n=[r-1,a-2]);let s=n;return W(()=>{let i;if(r>a){i=r-a;let l=[];for(let p=0;p<i;++p)l.push(1);t=P(t,t.shape.concat(l))}else if(a>r){i=a-r;let l=[];for(let p=0;p<i;++p)l.push(1);e=P(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ge(z(e,t),s[0]):o=ge(z(Fe(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,p=s[1]===t.shape.length-1;o=Le(e,t,l,p)}if(i>0){let l;r>a?l=r+a-3:l=r-1;let p=[];for(let u=l;u<l+i;++u)p.push(u);o=Ya(o,p)}return o.shape.length===1&&(o=Jt(o,1)),o})}var yb=class extends ji{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Re("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new V(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,s)=>uu(a,e[s].shape.length)):r=[uu(this.axes,t.shape.length),uu(this.axes,n.shape.length)],this.normalize&&(t=Jh(t,r[0]),n=Jh(n,r[1])),_B(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[uu(this.axes,e.length),uu(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Re("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};yb.className="Dot";ne.registerClass(yb);var bb=class extends Ve{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);return Ap(()=>J(Oc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};bb.className="GaussianNoise";ne.registerClass(bb);var xb=class extends Ve{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return W(()=>{this.invokeCallHook(e,t);let n=Ce(e);return this.rate>0&&this.rate<1?Ap(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return z(n,Oc(n.shape,1,r))},()=>n,t.training||!1):n})}};xb.className="GaussianDropout";ne.registerClass(xb);var wb=class extends Ve{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ce(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return W(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Ap(()=>{let r=Ce(e),a=1.6732632423543772,s=1.0507009873554805,i=-a*s,o=da(Pl(n),this.rate);o=pa(o,"float32");let l=((1-this.rate)*(1+this.rate*i**2))**-.5,p=-l*i*this.rate,u=J(z(r,o),z(J(o,-1),i));return J(z(u,l),p)},()=>Ce(e),t.training||!1)}return e})}};wb.className="AlphaDropout";ne.registerClass(wb);function zu(e,t,n,r,a,s=.001){let i;if(e.rank===2)i=ig(e,t,n,r,a,s);else if(e.rank===3)i=og(e,t,n,r,a,s);else if(e.rank===4)i=lg(e,t,n,r,a,s);else throw new Re(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function EB(e,t,n,r,a=.001){return W(()=>{let s=vp(e,r),i=s.mean,o=s.variance;return[zu(e,i,o,n,t,a),i,o]})}function $B(e,t,n,r,a=.001){return W(()=>{let s=vp(e,r),i=s.mean,o=s.variance,l=[];for(let c of Tr(0,e.rank))r.indexOf(c)!==-1?l.push(1):l.push(e.shape[c]);let p=P(i,l),u=P(o,l),h=t==null?null:P(t,l),d=n==null?null:P(n,l);return[zu(e,p,u,d,h,a),i,o]})}function AB(e,t,n,r,a=.001){return w.arraysEqual(r.slice().sort(),Tr(0,e.rank-1))?EB(e,t,n,r,a):$B(e,t,n,r,a)}var vb=class extends Ve{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ft(e.betaInitializer||"zeros"),this.gammaInitializer=ft(e.gammaInitializer||"ones"),this.movingMeanInitializer=ft(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ft(e.movingVarianceInitializer||"ones"),this.betaConstraint=Pt(e.betaConstraint),this.gammaConstraint=Pt(e.gammaConstraint),this.betaRegularizer=mt(e.betaRegularizer),this.gammaRegularizer=mt(e.gammaRegularizer)}build(e){e=Xe(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new _t({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return W(()=>{let n=t.training==null?!1:t.training,r=Ce(e),a=r.shape,s=a.length,i=Tr(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Ds(1,s);l[o]=a[o];let p=i.slice();p.sort();let u=!w.arraysEqual(p,Tr(0,s).slice(0,s-1)),h=()=>{if(u){let g=P(this.movingMean.read(),l),y=P(this.movingVariance.read(),l),b=this.center?P(this.beta.read(),l):null,x=this.scale?P(this.gamma.read(),l):null;return zu(r,g,y,b,x,this.epsilon)}else return zu(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return h();let[d,c,f]=AB(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,b)=>{W(()=>{let x=1-b,v=g.read(),I=z(de(v,y),x);g.write(de(v,I))})};return m(this.movingMean,c,this.momentum),m(this.movingVariance,f,this.momentum),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xt(this.betaInitializer),gammaInitializer:xt(this.gammaInitializer),movingMeanInitializer:xt(this.movingMeanInitializer),movingVarianceInitializer:xt(this.movingVarianceInitializer),betaRegularizer:at(this.betaRegularizer),gammaRegularizer:at(this.gammaRegularizer),betaConstraint:zt(this.betaConstraint),gammaConstraint:zt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};vb.className="BatchNormalization";ne.registerClass(vb);var kb=class extends Ve{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ft(e.betaInitializer||"zeros"),this.gammaInitializer=ft(e.gammaInitializer||"ones"),this.betaRegularizer=mt(e.betaRegularizer),this.gammaRegularizer=mt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Xe(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==$a(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Ce(e),r=n.shape,a=r.length;return W(()=>{let{mean:s,variance:i}=vp(n,this.axis,!0),o=Ds(1,a);for(let c of this.axis)o[c]=r[c];let l=c=>c!=null&&c.shape.length!==a?P(c,o):c,p=this.scale?l(this.gamma.read()):null,u=this.center?l(this.beta.read()):null,h=[],d=[];for(let c=0;c<a;++c)this.axis.indexOf(c)!==-1?(h.push(r[c]),d.push(1)):(h.push(1),d.push(r[c]));return s=Pn(s,h),i=Pn(i,h),p!=null&&(p=Pn(p,d)),u!=null&&(u=Pn(u,d)),zu(n,s,i,u,p,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:xt(this.betaInitializer),gammaInitializer:xt(this.gammaInitializer),betaRegularizer:at(this.betaRegularizer),gammaRegularizer:at(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};kb.className="LayerNormalization";ne.registerClass(kb);function RB(e,t,n){return W(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Cr()),n!=="channelsLast"&&n!=="channelsFirst")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Er(e,r)})}var Ib=class extends Ve{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Cr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new _t({ndim:4})]}computeOutputShape(e){e=Xe(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return W(()=>RB(Ce(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Ib.className="ZeroPadding2D";ne.registerClass(Ib);function Qc(e,t,n,r,a,s){return W(()=>{Nt(a),mk(s),ar(r),n==null&&(n=[1,1]),r==null&&(r="valid"),a==null&&(a=Cr()),s==null&&(s="max"),e=Gy(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=Wt(e,t,n,o):i=ha(e,t,n,o),a==="channelsFirst"&&(i=Fe(i,[0,3,1,2])),i})}function pI(e,t,n,r,a,s){return W(()=>{Nt(a),mk(s),ar(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),a==null&&(a=Cr()),s==null&&(s="max"),e=sI(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=Fg(e,t,n,o):i=sg(e,t,n,o),a==="channelsFirst"&&(i=Fe(i,[0,4,1,2,3])),i})}var hI=class extends Ve{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ut(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ar(this.padding),this.inputSpec=[new _t({ndim:3})]}computeOutputShape(e){e=Xe(e);let t=Nr(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return W(()=>{this.invokeCallHook(e,t),e=Ep(Ce(e),2);let n=this.poolingFunction(Ce(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ya(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Sb=class extends hI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),Qc(e,t,n,r,a,"max")}};Sb.className="MaxPooling1D";ne.registerClass(Sb);var Nb=class extends hI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),Qc(e,t,n,r,a,"avg")}};Nb.className="AveragePooling1D";ne.registerClass(Nb);var dI=class extends Ve{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ut(this.poolSize,"poolSize"),Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),ar(this.padding),this.inputSpec=[new _t({ndim:4})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Nr(t,this.poolSize[0],this.padding,this.strides[0]),n=Nr(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return W(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ce(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Tb=class extends dI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),Qc(e,t,n,r,a,"max")}};Tb.className="MaxPooling2D";ne.registerClass(Tb);var Cb=class extends dI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),Qc(e,t,n,r,a,"avg")}};Cb.className="AveragePooling2D";ne.registerClass(Cb);var cI=class extends Ve{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ut(this.poolSize,"poolSize"),Ut(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),ar(this.padding),this.inputSpec=[new _t({ndim:5})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Nr(t,this.poolSize[0],this.padding,this.strides[0]),n=Nr(n,this.poolSize[1],this.padding,this.strides[1]),r=Nr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return W(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ce(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},_b=class extends cI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),pI(e,t,n,r,a,"max")}};_b.className="MaxPooling3D";ne.registerClass(_b);var Eb=class extends cI{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),pI(e,t,n,r,a,"avg")}};Eb.className="AveragePooling3D";ne.registerClass(Eb);var fI=class extends Ve{constructor(e){super(e),this.inputSpec=[new _t({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Re}},$b=class extends fI{constructor(e){super(e||{})}call(e,t){return W(()=>{let n=Ce(e);return yt(n,1)})}};$b.className="GlobalAveragePooling1D";ne.registerClass($b);var Ab=class extends fI{constructor(e){super(e||{})}call(e,t){return W(()=>{let n=Ce(e);return er(n,1)})}};Ab.className="GlobalMaxPooling1D";ne.registerClass(Ab);var mI=class extends Ve{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),this.inputSpec=[new _t({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Re}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Rb=class extends mI{call(e,t){return W(()=>{let n=Ce(e);return this.dataFormat==="channelsLast"?yt(n,[1,2]):yt(n,[2,3])})}};Rb.className="GlobalAveragePooling2D";ne.registerClass(Rb);var Fb=class extends mI{call(e,t){return W(()=>{let n=Ce(e);return this.dataFormat==="channelsLast"?er(n,[1,2]):er(n,[2,3])})}};Fb.className="GlobalMaxPooling2D";ne.registerClass(Fb);var gI=class extends Ve{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=Sr(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},Db=class extends gI{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Xe(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Xe(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return W(()=>(e=Ce(e),lI((n,r)=>[Ce(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};Db.className="TimeDistributed";ne.registerClass(Db);function FB(e){Gi(Lz,"BidirectionalMergeMode",e)}var DB="concat",Mb=class extends gI{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Sr(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Sr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?DB:e.mergeMode,FB(this.mergeMode),e.weights)throw new Re("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):Cn(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=oI(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new V("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let p=n.map(u=>new _t({shape:u.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),i.push(...p)}if(r!=null)throw new Re("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof kr;for(let l of s)if(l instanceof kr!==o)throw new V("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),p=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=p;let h=super.apply(l,t);return this.inputSpec=u,h}else return super.apply(e,t)}call(e,t){return W(()=>{let n=t.initialState,r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=rr(a,1));let i;return this.mergeMode==="concat"?i=yy([r,a]):this.mergeMode==="sum"?i=J(r,a):this.mergeMode==="ave"?i=z(.5,J(r,a)):this.mergeMode==="mul"?i=z(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){bs(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),bs(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Sr(t.layer);if(delete t.layer,t.numConstants!=null)throw new Re("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};Mb.className="Bidirectional";ne.registerClass(Mb);var Ob=class extends Ve{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return W(()=>(e=Ce(e),e.dtype!=="float32"&&(e=pa(e,"float32")),J(z(e,this.scale),this.offset)))}};Ob.className="Rescaling";ne.registerClass(Ob);var{resizeBilinear:MB,cropAndResize:OB}=wr,Lb=class extends Ve{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return W(()=>{let l,p=!1,u=t/s,h=n/i,d=(r+t)/s,c=(a+n)/i,f=[u,h,d,c],m=[];e.rank===3?(p=!0,l=Ot([e])):l=e;for(let x=0;x<l.shape[0];x++)m.push(f);let g=dn(m,[m.length,4]),y=Fs(0,m.length,1,"int32"),b=OB(l,g,y,[r,a],"nearest");return pa(p?Ce(St(b)):b,o)})}upsize(e,t,n,r){return W(()=>{let a=MB(e,[t,n]);return pa(a,r)})}call(e,t){return W(()=>{let n=Ce(e),r=n.dtype,a=n.shape,s=a[a.length-3],i=a[a.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Xe(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};Lb.className="CenterCrop";ne.registerClass(Lb);function LB(e,t,n,r){let a=Ce(e);if(a.dtype!=="int32"&&(a=pa(a,"int32")),t==="int")return a;let s=a.shape;if(a.rank===0&&(a=Jt(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=Jt(a,-1)),a.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i=["multiHot","oneHot"].includes(t),o=a,l;if(typeof r<"u"&&t==="count"?l=jh(o,r,n,i):l=jh(o,[],n,i),t!=="tfIdf")return l;if(r)return z(l,r);throw new V("When outputMode is 'tfIdf', weights must be provided.")}var zb=class extends Ve{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Xe(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return W(()=>{e=Ce(e),e.dtype!=="int32"&&(e=pa(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new V(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Ce(t.countWeights)}let r=er(e),a=co(e),s=wn(this.numTokens,r).bufferSync().get(0),i=da(a,0).bufferSync().get(0);if(!(s&&i))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return LB(e,this.outputMode,this.numTokens,n)})}};zb.className="CategoryEncoding";ne.registerClass(zb);var zB=["bilinear","nearest"],qw=new Set(zB),Pb=class extends Ve{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(qw.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=Xe(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return W(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return wr.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return wr.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...qw]} are supported`)})}};Pb.className="Resizing";ne.registerClass(Pb);function PB(e){return new Ul(e)}function BB(e){return new Wy(e)}function WB(e){return new zy(e)}function VB(e){return new Py(e)}function UB(e){return new By(e)}function GB(e){return new Uy(e)}function HB(e){return new Vy(e)}function jB(e){return new qc(e)}function qB(e){return new Mp(e)}function KB(e){return new jy(e)}function XB(e){return new Op(e)}function ZB(e){return new qy(e)}function JB(e){return new Ky(e)}function YB(e){return new Xy(e)}function QB(e){return new Zy(e)}function eW(e){return new Jy(e)}function tW(e){return new sb(e)}function nW(e){return new rb(e)}function rW(e){return new Yc(e)}function aW(e){return new nb(e)}function sW(e){return new ab(e)}function iW(e){return new ib(e)}function oW(e){return new ob(e)}function lW(e){return new lb(e)}function uW(e){return new pb(e)}function pW(e){return new hb(e)}function hW(e){return new cb(e)}function dW(e){return new gb(e)}function cW(e){return new fb(e)}function fW(e){return new mb(e)}function mW(e){return new db(e)}function gW(e){return new yb(e)}function yW(e){return new vb(e)}function bW(e){return new kb(e)}function xW(e){return new Ib(e)}function Bb(e){return new Nb(e)}function wW(e){return Bb(e)}function vW(e){return Bb(e)}function Wb(e){return new Cb(e)}function kW(e){return Wb(e)}function IW(e){return Wb(e)}function Vb(e){return new Eb(e)}function SW(e){return Vb(e)}function NW(e){return Vb(e)}function TW(e){return new $b(e)}function CW(e){return new Rb(e)}function yI(e){return new Ab(e)}function bI(e){return new Fb(e)}function xI(e){return new Sb(e)}function wI(e){return new Tb(e)}function _W(e){return new _b(e)}function EW(e){return new Qy(e)}function $W(e){return new Xc(e)}function AW(e){return new eb(e)}function RW(e){return new zp(e)}function FW(e){return new Yy(e)}function DW(e){return new Kc(e)}function MW(e){return new tb(e)}function OW(e){return new Jc(e)}function LW(e){return new Kr(e)}function zW(e){return new Zc(e)}function PW(e){return new Mb(e)}function BW(e){return new Db(e)}var WW=yI,VW=bI,UW=xI,GW=wI;function HW(e){return new bb(e)}function jW(e){return new xb(e)}function qW(e){return new wb(e)}function KW(e){return new ub(e)}function XW(e){return new Ob(e)}function ZW(e){return new Lb(e)}function JW(e){return new Pb(e)}function YW(e){return new zb(e)}var vI={};Ee(vI,{MAPE:()=>u4,MSE:()=>d4,binaryAccuracy:()=>QW,binaryCrossentropy:()=>e4,categoricalAccuracy:()=>n4,categoricalCrossentropy:()=>r4,cosineProximity:()=>i4,mape:()=>p4,meanAbsoluteError:()=>o4,meanAbsolutePercentageError:()=>l4,meanSquaredError:()=>h4,mse:()=>c4,precision:()=>a4,recall:()=>s4,sparseCategoricalAccuracy:()=>t4});function QW(e,t){return Ry(e,t)}function e4(e,t){return Mk(e,t)}function t4(e,t){return Ok(e,t)}function n4(e,t){return Fy(e,t)}function r4(e,t){return Dy(e,t)}function a4(e,t){return Dk(e,t)}function s4(e,t){return WP(e,t)}function i4(e,t){return Ay(e,t)}function o4(e,t){return Hc(e,t)}function l4(e,t){return Gl(e,t)}function u4(e,t){return Gl(e,t)}function p4(e,t){return Gl(e,t)}function h4(e,t){return Hi(e,t)}function d4(e,t){return Hi(e,t)}function c4(e,t){return Hi(e,t)}var kI={};Ee(kI,{modelFromJSON:()=>mB});var II={};Ee(II,{l1:()=>m4,l1l2:()=>f4,l2:()=>g4});function f4(e){return new Fp(e)}function m4(e){return kB(e)}function g4(e){return IB(e)}var SI=class extends vo{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof sa))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function gh(e,t){return e<t}function Kw(e,t){return e>t}var NI=class extends SI{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Re("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=gh:this.mode==="max"?this.monitorFunc=Kw:this.monitor.indexOf("acc")!==-1?this.monitorFunc=Kw:this.monitorFunc=gh,this.monitorFunc===gh&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===gh?1/0:-1/0}async onEpochEnd(e,t){await va(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function y4(e){return new NI(e)}var b4={earlyStopping:y4},x4=j();x4.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var lr;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(lr||(lr={}));var Xw;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Xw||(Xw={}));var Ub={};function w4(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};Ub[e]=n}function TI(e){return Ub[e]}function v4(e){delete Ub[e]}function k(e,t,n,r,a){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd;if(s.type==="tensor")return pn(t.inputNames[s.inputIndexStart],n,r,a);if(s.type==="tensors")return t.inputNames.slice(o,l).map(h=>pn(h,n,r,a));let p=pn(t.inputNames.slice(o)[0],n,r,a),u=p.dataSync();return s.type==="number"?u[0]:w.toNestedArray(p.shape,u)}let i=t.attrParams[e];return i&&i.value}function pn(e,t,n,r){let[a,s]=Ln(e);if(r!=null){let o=r.getHashTableHandleByName(a);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[nd(a,o)]);return i!==void 0?t[nd(a,i)][s]:void 0}function k4(e,t,n){return t[nd(e,n.currentContextId)]}function ta(e,t){let[n,r,a]=Ln(e);return[nd(n,t&&t.currentContextId),r,a]}function nd(e,t){return t?`${e}-${t}`:e}function Ln(e){let t=e.split(":");if(t.length===1)return[e,0,void 0];let n=t[0],r=t.length===3?t[1]:void 0,a=Number(t[t.length-1]);return[n,a,r]}function _h(e,t,n){let r=k("pad",e,t,n);if(r==="explicit"){r=k("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function na(e){return e.kept?e:Pr(e)}var CI={};Ee(CI,{json:()=>I4});var I4=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],_I={};Ee(_I,{json:()=>S4});var S4=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],EI={};Ee(EI,{json:()=>N4});var N4=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],$I={};Ee($I,{json:()=>T4});var T4=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],AI={};Ee(AI,{json:()=>C4});var C4=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],RI={};Ee(RI,{json:()=>_4});var _4=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FI={};Ee(FI,{json:()=>E4});var E4=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],DI={};Ee(DI,{json:()=>$4});var $4=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],MI={};Ee(MI,{json:()=>A4});var A4=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],OI={};Ee(OI,{json:()=>R4});var R4=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],LI={};Ee(LI,{json:()=>F4});var F4=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zI={};Ee(zI,{json:()=>D4});var D4=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],PI={};Ee(PI,{json:()=>M4});var M4=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],BI={};Ee(BI,{json:()=>O4});var O4=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],WI={};Ee(WI,{json:()=>L4});var L4=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],VI={};Ee(VI,{json:()=>z4});var z4=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],UI={};Ee(UI,{json:()=>P4});var P4=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GI={};Ee(GI,{json:()=>B4});var B4=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],HI={};Ee(HI,{json:()=>W4});var W4=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Zw=class{constructor(){let e=[CI,_I,EI,$I,AI,RI,FI,DI,MI,OI,LI,zI,PI,BI,WI,VI,UI,GI,HI],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?a.push(f[m.name]):(m.input==null||m.input.length===0)&&s.push(f[m.name]),f),{}),o=[],l=[],p={},u={};t!=null&&(p=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let h=Object.keys(i);h.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[b,,x]=ta(g),v=i[b];if(v.outputs!=null){let I=v.outputs.indexOf(x);if(I!==-1){let N=`${b}:${I}`;m.inputNames[y]=N}}m.inputs.push(v),v.children.push(m)})}),Object.keys(u).length===0?h.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(u).forEach(f=>{let[m]=ta(f),g=i[m];g!=null&&(g.signatureKey=u[f],l.push(g))}),Object.keys(p).length>0?Object.keys(p).forEach(f=>{let[m]=ta(f),g=i[m];g&&(g.signatureKey=p[f],o.push(g))}):o=r;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let c={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=TI(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{let s=a.type,i;switch(a.type){case"string":i=im(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=im(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=cm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=cm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=lm(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=lm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=dm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=dm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=om(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=om(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=mm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=mm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=hm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=hm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=fm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=fm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=um(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=um(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=pm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=pm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=Jw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Jw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:s},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};t!=null&&(a=t.reduce((p,u)=>(p[u.name]=this.mapNode(u),u.op==="Const"&&r.push(p[u.name]),p),{}));let s=[],i=[];e.signature.inputArg.forEach(p=>{let[u]=ta(p.name),h={name:u,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Gb(p.type),type:"dtype"}},children:[]};h.signatureKey=p.name,s.push(h),a[u]=h}),Object.keys(a).forEach(p=>{let u=a[p];u.inputNames.forEach((h,d)=>{let[c,,f]=ta(h),m=a[c];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${c}:${g}`;u.inputNames[d]=y}}u.inputs.push(m),m.children.push(u)})});let o=e.ret;e.signature.outputArg.forEach(p=>{let[u,h]=ta(o[p.name]),d=a[u];d!=null&&(d.defaultOutput=h,i.push(d))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function V4(e){let t=j().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function jI(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):V4(e);return t?n:n.toLowerCase()}function im(e,t,n,r=!1){let a=e[t];return a!=null?jI(a.s,r):n}function om(e,t,n){let r=e[t];return r?r.b:n}function lm(e,t,n){let r=e[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function Gb(e){switch(typeof e=="string"&&(e=lr[e]),e){case lr.DT_FLOAT:case lr.DT_HALF:return"float32";case lr.DT_INT32:case lr.DT_INT64:case lr.DT_INT8:case lr.DT_UINT8:return"int32";case lr.DT_BOOL:return"bool";case lr.DT_DOUBLE:return"float32";case lr.DT_STRING:return"string";default:return null}}function Jw(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function um(e,t,n){let r=e[t];return r&&r.type?Gb(r.type):n}function pm(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>Gb(a)):n}function qI(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function hm(e,t,n){let r=e[t];return r&&r.shape?qI(r.shape):n}function dm(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function cm(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(s=>jI(s,r)):n}function fm(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>qI(a)):n}function mm(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var U4=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return pn(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return pn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return lm(this.node.rawAttrs,e,t);if(n.s!=null)return im(this.node.rawAttrs,e,t);if(n.b!=null)return om(this.node.rawAttrs,e,t);if(n.shape!=null)return hm(this.node.rawAttrs,e,t);if(n.type!=null)return um(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return dm(this.node.rawAttrs,e,t);if(n.list.s!=null)return cm(this.node.rawAttrs,e,t);if(n.list.shape!=null)return fm(this.node.rawAttrs,e,t);if(n.list.b!=null)return mm(this.node.rawAttrs,e,t);if(n.list.type!=null)return pm(this.node.rawAttrs,e,t)}return t}},Ht={};Ee(Ht,{OP_SCOPE_SUFFIX:()=>Hm,abs:()=>Ct,acos:()=>Zm,acosh:()=>Jm,add:()=>J,addN:()=>_0,all:()=>ac,any:()=>Ru,argMax:()=>_s,argMin:()=>Ym,asin:()=>Qm,asinh:()=>eg,atan:()=>tg,atan2:()=>ng,atanh:()=>rg,avgPool:()=>ha,avgPool3d:()=>sg,basicLSTMCell:()=>R0,batchNorm:()=>Bi,batchNorm2d:()=>ig,batchNorm3d:()=>og,batchNorm4d:()=>lg,batchToSpaceND:()=>mp,bincount:()=>ug,booleanMaskAsync:()=>b1,broadcastArgs:()=>F0,broadcastTo:()=>ys,buffer:()=>ze,cast:()=>se,ceil:()=>pg,clipByValue:()=>an,clone:()=>Pr,complex:()=>la,concat:()=>nt,concat1d:()=>hg,concat2d:()=>dg,concat3d:()=>cg,concat4d:()=>fg,conv1d:()=>sc,conv2d:()=>cn,conv2dTranspose:()=>ic,conv3d:()=>gg,conv3dTranspose:()=>yg,cos:()=>gp,cosh:()=>oc,cosineWindow:()=>Ec,cumprod:()=>Mu,cumsum:()=>lc,denseBincount:()=>jh,depthToSpace:()=>bg,depthwiseConv2d:()=>Wi,diag:()=>M0,dilation2d:()=>xg,div:()=>me,divNoNan:()=>wg,dot:()=>vg,dropout:()=>Qg,einsum:()=>L0,elu:()=>Dl,enclosingPowerOfTwo:()=>ey,equal:()=>Vn,erf:()=>kg,euclideanNorm:()=>Ng,exp:()=>fn,expandDims:()=>Jt,expm1:()=>Tg,eye:()=>uc,fft:()=>Np,fill:()=>Wn,floor:()=>Ol,floorDiv:()=>rc,fused:()=>bo,gather:()=>Ll,gatherND:()=>I1,greater:()=>wn,greaterEqual:()=>da,ifft:()=>yo,imag:()=>yp,image:()=>wr,inTopKAsync:()=>S1,irfft:()=>Sc,isFinite:()=>Cg,isInf:()=>_g,isNaN:()=>Eg,leakyRelu:()=>bp,less:()=>pc,lessEqual:()=>Za,linalg:()=>ry,linspace:()=>V0,localResponseNormalization:()=>$g,log:()=>Un,log1p:()=>xp,logSigmoid:()=>Ag,logSoftmax:()=>dc,logSumExp:()=>cc,logicalAnd:()=>cr,logicalNot:()=>wp,logicalOr:()=>fc,logicalXor:()=>Rg,losses:()=>O1,lowerBound:()=>G0,matMul:()=>Le,max:()=>er,maxPool:()=>Wt,maxPool3d:()=>Fg,maxPoolWithArgmax:()=>H0,maximum:()=>jr,mean:()=>yt,meshgrid:()=>j0,min:()=>co,minimum:()=>zl,mirrorPad:()=>Dg,mod:()=>Mg,moments:()=>vp,movingAverage:()=>x1,mul:()=>z,multiRNNCell:()=>q0,multinomial:()=>K0,neg:()=>dt,norm:()=>Ml,notEqual:()=>Rs,oneHot:()=>fo,ones:()=>Bn,onesLike:()=>Gn,op:()=>L,outerProduct:()=>X0,pad:()=>Er,pad1d:()=>Z0,pad2d:()=>J0,pad3d:()=>Y0,pad4d:()=>Q0,pool:()=>Og,pow:()=>ua,prelu:()=>Ip,print:()=>Xm,prod:()=>Lg,raggedGather:()=>e1,raggedRange:()=>t1,raggedTensorToTensor:()=>n1,rand:()=>r1,randomGamma:()=>o1,randomNormal:()=>gc,randomStandardNormal:()=>l1,randomUniform:()=>Pl,range:()=>Fs,real:()=>mo,reciprocal:()=>Vg,relu:()=>Ye,relu6:()=>yc,reshape:()=>P,reverse:()=>rr,reverse1d:()=>u1,reverse2d:()=>p1,reverse3d:()=>h1,reverse4d:()=>d1,rfft:()=>Tp,round:()=>bc,rsqrt:()=>xc,scalar:()=>ve,scatterND:()=>v1,searchSorted:()=>mc,selu:()=>wc,separableConv2d:()=>Bl,setdiff1dAsync:()=>c1,sigmoid:()=>dr,sign:()=>Ug,signal:()=>M1,sin:()=>vc,sinh:()=>kc,slice:()=>Ue,slice1d:()=>Sp,slice2d:()=>Ic,slice3d:()=>Wl,slice4d:()=>go,softmax:()=>Ja,softplus:()=>Vi,spaceToBatchND:()=>kp,sparse:()=>L1,sparseToDense:()=>k1,spectral:()=>D1,split:()=>_n,sqrt:()=>en,square:()=>tt,squaredDifference:()=>Nc,squeeze:()=>Ya,stack:()=>Ot,step:()=>Ui,stridedSlice:()=>Gg,string:()=>z1,sub:()=>de,sum:()=>ge,tan:()=>Hg,tanh:()=>$s,tensor:()=>dn,tensor1d:()=>Je,tensor2d:()=>Br,tensor3d:()=>Tc,tensor4d:()=>Ma,tensor5d:()=>f1,tensor6d:()=>m1,tile:()=>Pn,topk:()=>jg,transpose:()=>Fe,truncatedNormal:()=>Cc,unique:()=>qg,unsortedSegmentSum:()=>_c,unstack:()=>St,upperBound:()=>g1,variable:()=>Kg,where:()=>sn,whereAsync:()=>Xg,zeros:()=>bt,zerosLike:()=>He});var G4=(e,t,n,r=Ht)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(k("a",e,t,n),k("b",e,t,n))];case"AddN":return[r.addN(k("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(k("a",e,t,n),k("b",e,t,n))];case"Mul":return[r.mul(k("a",e,t,n),k("b",e,t,n))];case"RealDiv":case"Div":return[r.div(k("a",e,t,n),k("b",e,t,n))];case"DivNoNan":return[r.divNoNan(k("a",e,t,n),k("b",e,t,n))];case"FloorDiv":return[r.floorDiv(k("a",e,t,n),k("b",e,t,n))];case"Sub":return[r.sub(k("a",e,t,n),k("b",e,t,n))];case"Minimum":return[r.minimum(k("a",e,t,n),k("b",e,t,n))];case"Maximum":return[r.maximum(k("a",e,t,n),k("b",e,t,n))];case"Pow":return[r.pow(k("a",e,t,n),k("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},H4=(e,t,n,r=Ht)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(k("x",e,t,n))];case"Acos":return[r.acos(k("x",e,t,n))];case"Acosh":return[r.acosh(k("x",e,t,n))];case"Asin":return[r.asin(k("x",e,t,n))];case"Asinh":return[r.asinh(k("x",e,t,n))];case"Atan":return[r.atan(k("x",e,t,n))];case"Atan2":return[r.atan2(k("x",e,t,n),k("y",e,t,n))];case"Atanh":return[r.atanh(k("x",e,t,n))];case"Ceil":return[r.ceil(k("x",e,t,n))];case"Complex":return[r.complex(k("real",e,t,n),k("imag",e,t,n))];case"Cos":return[r.cos(k("x",e,t,n))];case"Cosh":return[r.cosh(k("x",e,t,n))];case"Elu":return[r.elu(k("x",e,t,n))];case"Erf":return[r.erf(k("x",e,t,n))];case"Exp":return[r.exp(k("x",e,t,n))];case"Expm1":return[r.expm1(k("x",e,t,n))];case"Floor":return[r.floor(k("x",e,t,n))];case"Log":return[r.log(k("x",e,t,n))];case"Log1p":return[r.log1p(k("x",e,t,n))];case"Imag":return[r.imag(k("x",e,t,n))];case"Neg":return[r.neg(k("x",e,t,n))];case"Reciprocal":return[r.reciprocal(k("x",e,t,n))];case"Real":return[r.real(k("x",e,t,n))];case"Relu":return[r.relu(k("x",e,t,n))];case"Round":return[r.round(k("x",e,t,n))];case"Selu":return[r.selu(k("x",e,t,n))];case"Sigmoid":return[r.sigmoid(k("x",e,t,n))];case"Sin":return[r.sin(k("x",e,t,n))];case"Sign":return[r.sign(k("x",e,t,n))];case"Sinh":return[r.sinh(k("x",e,t,n))];case"Softplus":return[r.softplus(k("x",e,t,n))];case"Sqrt":return[r.sqrt(k("x",e,t,n))];case"Square":return[r.square(k("x",e,t,n))];case"Tanh":return[r.tanh(k("x",e,t,n))];case"Tan":return[r.tan(k("x",e,t,n))];case"ClipByValue":return[r.clipByValue(k("x",e,t,n),k("clipValueMin",e,t,n),k("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(k("x",e,t,n))];case"Rsqrt":return[r.rsqrt(pn(e.inputNames[0],t,n))];case"Prod":return[r.prod(k("x",e,t,n),k("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(k("x",e,t,n),k("alpha",e,t,n))];case"Prelu":return[r.prelu(k("x",e,t,n),k("alpha",e,t,n))];case"IsNan":return[r.isNaN(pn(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function hr(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],s=t[r];w.assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function Yw(e){return!(typeof e=="number"||e.some(t=>t<0))}function pu(e,t,n){let r=gm(e,n),a=!Yw(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=gm(s.shape,r)}),!Yw(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function gm(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var j4=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=ve(0),Ft(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),hr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ft(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return dn([],[0].concat(this.elementShape));let n=this.readMany(e);return hr(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ot(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return dn([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return hr(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),nt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,St(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=n===0?0:t.size/n,s=[];W(()=>{t=P(t,[1,n,a]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],p=[1,e[o],a];s[o]=P(Ue(t,l,p),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Io=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(a=>{if(n!==a.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${a.dtype}`);hr(t,a.shape,"TensorList shape mismatch: "),Ft(a)}),this.idTensor=ve(0),this.maxNumElements=r,Ft(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Io([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);hr(e,this.elementShape,"TensorList shape mismatch: ");let r=pu(this.elementShape,this.tensors,e);return W(()=>{let a=this.tensors.map(s=>P(s,r));return Ot(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=pu(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,hr(r.shape,e,"TensorList shape mismatch: "),P(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(hr(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ft(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new Io([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);hr(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=pu(this.elementShape,this.tensors,t);return P(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);hr(this.elementShape,t.shape,"TensorList shape mismatch: "),Ft(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);hr(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=pu(this.elementShape,this.tensors,n);return e.length===0?dn([],[0].concat(r)):W(()=>{let a=e.map(s=>P(this.tensors[s],r));return Ot(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);hr(this.elementShape,t,"TensorList shape mismatch: ");let n=pu(this.elementShape,this.tensors,t);return this.size()===0?dn([],[0].concat(n)):W(()=>{let r=this.tensors.map(a=>P(a,n));return nt(r,0)})}};function q4(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);hr(a,t,"TensorList shape mismatch: ");let s=St(e);return new Io(s,t,r)}function K4(e,t,n,r){return new Io([],e,t,r)}function X4(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new Io([],n,e.dtype,r),i=St(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Z4(e,t,n){let r=0,a=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=gm(s,n),o=r===0?0:e.size/r,l=W(()=>{let u=[];e=P(e,[1,r,o]);for(let h=0;h<t.length;++h){let d=[0,h===0?0:a[h-1],0],c=[1,t[h],o];u[h]=P(Ue(e,d,c),i)}return e.dispose(),u}),p=new Io([],n,e.dtype,t.length);for(let u=0;u<l.length;u++)p.setItem(u,l[u]);return p}var J4=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=k("thenBranch",e,t,n),a=k("elseBranch",e,t,n),s=k("cond",e,t,n),i=k("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=k("body",e,t,n),a=k("cond",e,t,n),s=k("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(u=>u.id),l=await i[0].data();i.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let p=s;for(;l[0];){let u=p;p=await n.functionMap[r].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap);let h=p.map(c=>c.id);u.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&h.indexOf(c.id)===-1&&c.dispose()});let d=await n.functionMap[a].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap);l=await d[0].data(),d.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&h.indexOf(c.id)===-1&&c.dispose()})}return p}case"LoopCond":{let r=k("pred",e,t,n);return[na(r)]}case"Switch":{let r=k("pred",e,t,n),a=k("data",e,t,n);return a.kept||(a=na(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find(a=>pn(a,t,n)!==void 0);if(r){let a=pn(r,t,n);return[na(a)]}return}case"Enter":{let r=k("frameName",e,t,n),a=k("tensor",e,t,n);return n.enterFrame(r),[na(a)]}case"Exit":{let r=k("tensor",e,t,n);return n.exitFrame(),[na(r)]}case"NextIteration":{let r=k("tensor",e,t,n);return n.nextIteration(),[na(r)]}case"TensorArrayV3":{let r=k("size",e,t,n),a=k("dtype",e,t,n),s=k("elementShape",e,t,n),i=k("dynamicSize",e,t,n),o=k("clearAfterRead",e,t,n),l=k("identicalElementShapes",e,t,n),p=k("name",e,t,n),u=new j4(p,a,r,s,l,i,o);return n.addTensorArray(u),[u.idTensor,ve(1)]}case"TensorArrayWriteV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=k("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=k("tensorArrayId",e,t,n),a=k("tensor",e,t,n),s=k("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[ve(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=k("indices",e,t,n),a=k("tensor",e,t,n),s=k("elementShape",e,t,n),i=k("numElements",e,t,n),o=X4(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=k("elementShape",e,t,n),a=k("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=k(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=K4(r,a,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=k("tensorListId",e,t,n),a=k("indices",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=k("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=q4(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id),s=k("dtype",e,t,n),i=k("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=k("tensorListId",e,t,n),a=k("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("lengths",e,t,n),i=Z4(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id);return[ve(a.size(),"int32")]}case"TensorListResize":{let r=k("tensorListId",e,t,n),a=k("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Qw(e,t,n){let[r,a]=k("fusedOps",e,t,n),s=r==="biasadd",i=!s,o=a==="prelu",l=r==="fusedbatchnorm",p=k("numArgs",e,t,n);if(s){if(o&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=k("strides",e,t,n),h=_h(e,t,n),d=k("dataFormat",e,t,n).toUpperCase(),c=k("dilations",e,t,n),[f,m]=k("args",e,t,n);i&&(m=f,f=void 0);let g=k("leakyreluAlpha",e,t,n);return{stride:u,pad:h,dataFormat:d,dilations:c,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var Y4=(e,t,n,r=Ht)=>{switch(e.op){case"Conv1D":{let a=k("stride",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilation",e,t,n);return[r.conv1d(k("x",e,t,n),k("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=k("strides",e,t,n),s=_h(e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv2d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:p,activationFunc:u,leakyreluAlpha:h}=Qw(e,t,n);return[r.fused.conv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:p,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:p,activationFunc:u,leakyreluAlpha:h}=Qw(e,t,n);return[r.fused.depthwiseConv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:p,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=k("outputShape",e,t,n),s=k("strides",e,t,n),i=_h(e,t,n);return[r.conv2dTranspose(k("x",e,t,n),k("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=k("strides",e,t,n),s=_h(e,t,n),i=k("dilations",e,t,n),o=k("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(k("input",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv3d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n),o=k("includeBatchInIndex",e,t,n),{result:l,indexes:p}=r.maxPoolWithArgmax(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,p]}case"AvgPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dilations",e,t,n),o=a[1],l=a[2],p=i[1],u=i[2];return[r.dilation2d(k("x",e,t,n),k("filter",e,t,n),[o,l],s,[p,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Q4=(e,t,n,r=Ht)=>{switch(e.op){case"Fill":{let a=k("shape",e,t,n),s=k("dtype",e,t,n),i=k("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=k("logits",e,t,n),s=k("numSamples",e,t,n),i=k("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=k("indices",e,t,n),s=k("depth",e,t,n),i=k("onValue",e,t,n),o=k("offValue",e,t,n),l=k("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(k("shape",e,t,n),k("dtype",e,t,n))];case"OnesLike":return[r.onesLike(k("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(k("shape",e,t,n),k("dtype",e,t,n),k("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(k("shape",e,t,n),k("minval",e,t,n),k("maxval",e,t,n),k("dtype",e,t,n))];case"Range":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("step",e,t,n);return[r.range(a,s,i,k("dtype",e,t,n))]}case"TruncatedNormal":{let a=k("shape",e,t,n),s=k("mean",e,t,n),i=k("stdDev",e,t,n),o=k("seed",e,t,n);return[r.truncatedNormal(a,s,i,k("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(k("shape",e,t,n),k("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function _f(e,t,n){let r=k("boxes",e,t,n),a=k("scores",e,t,n),s=k("maxOutputSize",e,t,n),i=k("iouThreshold",e,t,n),o=k("scoreThreshold",e,t,n),l=k("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var eV=async(e,t,n,r,a=Ht)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p,softNmsSigma:u}=_f(e,t,n),h=await a.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,p,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=_f(e,t,n),u=k("padToMaxOutputSize",e,t,n),h=await a.image.nonMaxSuppressionPaddedAsync(s,i,o,l,p,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=_f(e,t,n);return[await a.image.nonMaxSuppressionAsync(s,i,o,l,p)]}case"Where":{let s=a.cast(k("condition",e,t,n),"bool"),i=[await a.whereAsync(s)];return s.dispose(),i}case"ListDiff":return a.setdiff1dAsync(k("x",e,t,n),k("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},tV=(e,t,n,r=Ht)=>{switch(e.op){case"LowerBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=k("x",e,t,n),s=k("k",e,t,n),i=k("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=k("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=k("x",e,t,n),s=k("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},nV=(e,t,n,r=Ht)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=k("default",e,t,n);return[pn(e.name,t,n)||a];case"Placeholder":return[pn(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=k("x",e,t,n);return[na(u)]}case"IdentityN":return k("x",e,t,n).map(u=>na(u));case"Snapshot":let s=k("x",e,t,n);return[na(s)];case"Shape":return[r.tensor1d(k("x",e,t,n).shape,"int32")];case"ShapeN":return k("x",e,t,n).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(k("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(k("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=k("x",e,t,n),o=k("data",e,t,n),l=k("message",e,t,n),p=k("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,p));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},rV=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ve(0),this.tensorMap=new Map,Ft(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ve(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),W(()=>{let r=St(t),a=n.length,s=r.length;w.assert(a===s,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${s} elements.`);for(let i=0;i<a;i++){let o=n[i],l=r[i];Ft(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return W(()=>{let r=[];for(let a=0;a<n.length;a++){let s=n[a],i=this.findWithDefault(s,t);r.push(i)}return Ot(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},aV=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(a!=null)return[a];{let s=k("keyDType",e,t,n),i=k("valueDType",e,t,n),o=new rV(s,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=k("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},sV=(e,t,n,r=Ht)=>{switch(e.op){case"ResizeBilinear":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=k("image",e,t,n),s=k("boxes",e,t,n),i=k("boxInd",e,t,n),o=k("cropSize",e,t,n),l=k("method",e,t,n),p=k("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,p)]}case"ImageProjectiveTransformV3":{let a=k("images",e,t,n),s=k("transforms",e,t,n),i=k("outputShape",e,t,n),o=k("fillValue",e,t,n),l=k("interpolation",e,t,n),p=k("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),p.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},iV=(e,t,n,r=Ht)=>{switch(e.op){case"Equal":return[r.equal(k("a",e,t,n),k("b",e,t,n))];case"NotEqual":return[r.notEqual(k("a",e,t,n),k("b",e,t,n))];case"Greater":return[r.greater(k("a",e,t,n),k("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(k("a",e,t,n),k("b",e,t,n))];case"Less":return[r.less(k("a",e,t,n),k("b",e,t,n))];case"LessEqual":return[r.lessEqual(k("a",e,t,n),k("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(k("a",e,t,n),k("b",e,t,n))];case"LogicalNot":return[r.logicalNot(k("a",e,t,n))];case"LogicalOr":return[r.logicalOr(k("a",e,t,n),k("b",e,t,n))];case"Select":case"SelectV2":return[r.where(k("condition",e,t,n),k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},oV=(e,t,n,r=Ht)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(k("a",e,t,n),k("b",e,t,n),k("transposeA",e,t,n),k("transposeB",e,t,n))];case"Einsum":return[r.einsum(k("equation",e,t,n),...k("tensors",e,t,n))];case"Transpose":return[r.transpose(k("x",e,t,n),k("perm",e,t,n))];case"_FusedMatMul":let[a,s]=k("fusedOps",e,t,n),i=a==="biasadd",o=s==="prelu",l=k("numArgs",e,t,n),p=k("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,h]=k("args",e,t,n);return[r.fused.matMul({a:k("a",e,t,n),b:k("b",e,t,n),transposeA:k("transposeA",e,t,n),transposeB:k("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:p})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lV=(e,t,n,r=Ht)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(k("x",e,t,n),k("axis",e,t,n),k("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(k("x",e,t,n),k("radius",e,t,n),k("bias",e,t,n),k("alpha",e,t,n),k("beta",e,t,n))];case"Softmax":return[r.softmax(k("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(k("x",e,t,n))];case"SparseToDense":return[r.sparseToDense(k("sparseIndices",e,t,n),k("outputShape",e,t,n),k("sparseValues",e,t,n),k("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},uV=(e,t,n,r=Ht)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(k("paramsNestedSplits",e,t,n),k("paramsDenseValues",e,t,n),k("indices",e,t,n),k("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(k("starts",e,t,n),k("limits",e,t,n),k("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(k("shape",e,t,n),k("values",e,t,n),k("defaultValue",e,t,n),k("rowPartitionTensors",e,t,n),k("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},pV=(e,t,n,r=Ht)=>{switch(e.op){case"Max":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.max(k("x",e,t,n),o,l)]}case"Mean":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.mean(k("x",e,t,n),o,l)]}case"Min":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.min(k("x",e,t,n),o,l)]}case"Sum":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.sum(k("x",e,t,n),o,l)]}case"All":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.all(k("x",e,t,n),o,l)]}case"Any":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.any(k("x",e,t,n),o,l)]}case"ArgMax":{let o=k("axis",e,t,n);return[r.argMax(k("x",e,t,n),o)]}case"ArgMin":{let o=k("axis",e,t,n);return[r.argMin(k("x",e,t,n),o)]}case"Prod":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.prod(k("x",e,t,n),o,l)]}case"Cumprod":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),p=k("reverse",e,t,n);return[r.cumprod(k("x",e,t,n),o,l,p)]}case"Cumsum":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),p=k("reverse",e,t,n);return[r.cumsum(k("x",e,t,n),o,l,p)]}case"Bincount":let a=k("x",e,t,n),s=k("weights",e,t,n),i=k("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let o=k("x",e,t,n),l=k("weights",e,t,n),p=k("size",e,t,n),u=k("binaryOutput",e,t,n);return[r.denseBincount(o,l,p,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},hV=(e,t,n,r=Ht)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=k("n",e,t,n),s=k("axis",e,t,n),i=k("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=k("axis",e,t,n),s=k("batchDims",e,t,n),i=k("x",e,t,n),o=k("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=k("dims",e,t,n),s=[];for(let o=0;o<a.length;o++)a[o]&&s.push(o);let i=k("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=k("axis",e,t,n),s=k("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=k("begin",e,t,n),s=k("size",e,t,n);return[r.slice(k("x",e,t,n),a,s)]}case"StridedSlice":{let a=k("begin",e,t,n),s=k("end",e,t,n),i=k("strides",e,t,n),o=k("beginMask",e,t,n),l=k("endMask",e,t,n),p=k("ellipsisMask",e,t,n),u=k("newAxisMask",e,t,n),h=k("shrinkAxisMask",e,t,n),d=k("x",e,t,n);return[r.stridedSlice(d,a,s,i,o,l,p,u,h)]}case"Pack":return W(()=>{let a=k("axis",e,t,n),s=k("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(p=>{let u=w.arraysEqual(p.shape,i);if(!u&&!w.arraysEqual(r.squeeze(p).shape,o))throw new Error("the input tensors shape does not match");return u?p:r.reshape(p,i)});return[r.stack(l,a)]});case"Unpack":{let a=k("axis",e,t,n),s=k("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=k("reps",e,t,n);return[r.tile(k("x",e,t,n),a)]}case"Split":case"SplitV":{let a=k("axis",e,t,n),s=k("numOrSizeSplits",e,t,n),i=k("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=k("indices",e,t,n),s=k("values",e,t,n),i=k("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=k("sparseIndices",e,t,n),s=k("outputShape",e,t,n),i=k("sparseValues",e,t,n),o=k("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},dV=(e,t,n,r=Ht)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(k("indices",e,t,n),k("values",e,t,n),k("denseShape",e,t,n),k("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(k("inputIndices",e,t,n),k("inputShape",e,t,n),k("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},cV=(e,t,n,r=Ht)=>{switch(e.op){case"FFT":return[r.fft(k("x",e,t,n))];case"IFFT":return[r.ifft(k("x",e,t,n))];case"RFFT":return[r.rfft(k("x",e,t,n))];case"IRFFT":return[r.irfft(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fV=(e,t,n,r=Ht)=>{switch(e.op){case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(k("data",e,t,n),k("dataSplits",e,t,n),k("separator",e,t,n),k("nGramWidths",e,t,n),k("leftPad",e,t,n),k("rightPad",e,t,n),k("padWidth",e,t,n),k("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(k("input",e,t,n),k("delimiter",e,t,n),k("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(k("input",e,t,n),k("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},mV=(e,t,n,r=Ht)=>{switch(e.op){case"Cast":return[r.cast(k("x",e,t,n),k("dtype",e,t,n))];case"ExpandDims":{let a=k("axis",e,t,n);return[r.expandDims(k("x",e,t,n),a)]}case"Squeeze":{let a=k("axis",e,t,n);return[r.squeeze(k("x",e,t,n),a)]}case"Reshape":return[r.reshape(k("x",e,t,n),k("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(k("x",e,t,n),k("padding",e,t,n),k("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(k("x",e,t,n),k("padding",e,t,n),k("constantValue",e,t,n))];case"SpaceToBatchND":{let a=k("blockShape",e,t,n),s=k("paddings",e,t,n);return[r.spaceToBatchND(k("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=k("blockShape",e,t,n),s=k("crops",e,t,n);return[r.batchToSpaceND(k("x",e,t,n),a,s)]}case"DepthToSpace":{let a=k("blockSize",e,t,n),s=k("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(k("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(k("x",e,t,n),k("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(k("s0",e,t,n),k("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ev(e,t,n,r,a=W){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return a(()=>G4(i,o,l));case"basic_math":return a(()=>H4(i,o,l));case"control":return J4(i,o,l);case"convolution":return a(()=>Y4(i,o,l));case"creation":return a(()=>Q4(i,o,l));case"dynamic":return eV(i,o,l);case"evaluation":return a(()=>tV(i,o,l));case"image":return a(()=>sV(i,o,l));case"graph":return a(()=>nV(i,o,l));case"logical":return a(()=>iV(i,o,l));case"matrices":return a(()=>oV(i,o,l));case"normalization":return a(()=>lV(i,o,l));case"ragged":return a(()=>uV(i,o,l));case"reduction":return a(()=>pV(i,o,l));case"slice_join":return a(()=>hV(i,o,l));case"sparse":return a(()=>dV(i,o,l));case"spectral":return a(()=>cV(i,o,l));case"string":return a(()=>fV(i,o,l));case"transformation":return a(()=>mV(i,o,l));case"hash_table":return aV(i,o,l,r);case"custom":let p=TI(i.op);if(p&&p.customExecutor)return p.customExecutor(new U4(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var tv=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function nv(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,p=Object.keys(e).map(d=>Ln(d)[0]),u=[];r!=null&&(u=r.map(d=>Ln(d.name)[0]));let h=[...t];for(;h.length>0;){let d=h.pop();if((KI(d)||wV(d)||vV(d))&&i==null&&(i=d,o=i.children.map(c=>c.name).filter(c=>a.has(c))),a.add(d.name),n[d.name]==null&&p.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){s.push(d.name);continue}d.inputs.forEach(c=>{l.has(c.name)||(l.add(c.name),h.push(c))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function gV(e,t,n){let{usedNodes:r,inputs:a}=n,s=[],i=Object.keys(a).map(u=>Ln(u)[0]).map(u=>e.nodes[u]),o=e.initNodes;i.forEach(u=>{r.has(u.name)&&s.push(u)}),e.weights.forEach(u=>{r.has(u.name)&&s.push(u)}),o!=null&&o.forEach(u=>{r.has(u.name)&&s.push(u)});let l=new Set,p=[];for(;s.length>0;){let u=s.pop();l.add(u.name),t[u.name]||p.push(u),u.children.forEach(h=>{!l.has(h.name)&&r.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&s.push(h)})}return p}var yV=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],bV=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],xV=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function KI(e){return yV.indexOf(e.op)>=0}function wV(e){return bV.indexOf(e.op)>=0}function vV(e){return xV.indexOf(e.op)>=0}var ym=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new ym(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(a=>a.name).sort(),r=t.map(a=>a.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){let n=nv(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let i=t.map(l=>l.name),o=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${o}]. Missing the following inputs: [${r}]`)}return gV(this.graph,this.weightMap,n)}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Ft(t),t}cloneTensorList(e){return e?e.map(t=>this.cloneAndKeepTensor(t)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(u=>this.graph.nodes[Ln(u)[0]]),a=t.map(u=>Ln(u)[0]),s=a.map(u=>this.graph.nodes[u]);s.length===0&&(s=this._outputs);let i=this.getCompilationKey(r,s),o=this.compiledMap.get(i);o==null&&(o=this.compile(e,s),this.compiledMap.set(i,o));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){this.keepIntermediateTensors=!1,console.warn(u.message)}let l={},p={};return W(()=>{let u=new tv(this.weightMap,l,p,this.functionExecutorMap),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(f=>{let[m,g]=Ln(f),y=[];y[g]=e[f],h[m]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(y))});let d=this.getFrozenTensorIds(h),c={};for(let f=0;f<o.length;f++){let m=o[f];if(!h[m.name]){let g=ev(m,h,u,this._resourceManager);if(w.isPromise(g))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);h[m.name]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m.name]=this.cloneTensorList(g)),this.checkTensorForDisposal(m.name,m,h,u,d,a,c)}}return this.parent==null&&u.dispose(d),t.map(f=>pn(f,h,u))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){t.category==="control"||s.indexOf(e)!==-1||(n[e].forEach(o=>{o!=null&&(i[o.id]=(i[o.id]||0)+t.children.length)}),t.inputs.forEach(o=>{if(o.category!=="control"){let l=k4(o.name,n,r);l!=null&&l.forEach(p=>{if(p&&!p.kept&&!a.has(p.id)){let u=i[p.id];u===1?(p.dispose(),delete i[p.id]):u!=null&&i[p.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let s=new tv(this.weightMap,r,a,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map(h=>pn(h,i,s)),l=o.map(h=>h.id),p=Object.keys(e).map(h=>e[h].id),u=new Set([...l,...p,...this.weightIds]);return Object.values(i).forEach(h=>{h.forEach(d=>{d&&!d.isDisposed&&!u.has(d.id)&&d.dispose()})}),this.parent==null&&s.dispose(u),o}async executeFunctionAsync(e,t,n){let r=e.reduce((a,s,i)=>(a[this.inputs[i].name]=s,a),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map(b=>this.graph.nodes[Ln(b)[0]]),i=n.map(b=>Ln(b)[0]),o=i.map(b=>this.graph.nodes[b]);o.length===0&&(o=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:u,syncInputs:h}=nv(e,o,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),c=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{let[x,v]=Ln(b),I=[];I[v]=e[b],c[x]=I});let f={},m=this.getFrozenTensorIds(c),g={};for(;d.length>0;){let b=this.processStack(s,d,t,c,g,m,i,f,l);await Promise.all(b)}u==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=o.filter(b=>!KI(b)&&!pn(b.name,c,t)).map(b=>b.name);if(y.length>0){let b="";throw u!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${a}]. Consider providing the following inputs: [${p}]. ${b}`)}return c}processStack(e,t,n,r,a,s,i,o,l){let p=[];for(;t.length>0;){let u=t.pop();n.currentContext=u.contexts;let h="";if(u.node.op==="Enter"&&k("isConstant",u.node,r,n)&&([h]=ta(u.node.name,n)),r[u.node.name]==null){let d=ev(u.node,r,n,this._resourceManager);h||([h]=ta(u.node.name,n));let c=n.currentContext;w.isPromise(d)?p.push(d.then(f=>(r[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),n.currentContext=c,this.checkTensorForDisposal(h,u.node,r,n,s,i,o),this.processChildNodes(u.node,t,n,r,a,l),f))):(r[h]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(d)),this.checkTensorForDisposal(h,u.node,r,n,s,i,o),this.processChildNodes(u.node,t,n,r,a,l))}else this.processChildNodes(u.node,t,n,r,a,l)}return p}processChildNodes(e,t,n,r,a,s){e.children.forEach(i=>{let[o]=ta(i.name,n);a[o]||!s.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!pn(l,r,n))&&(a[o]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!pn(l,r,n))&&(a[o]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=Ln(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let s=a.attrParams.shape.value,i=s.length===n.shape.length&&n.shape.every((o,l)=>s[l]===-1||s[l]===o);w.assert(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${s}], but was [${n.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&w.assert(n.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;let r={};for(let a in e){let s=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[a];s!=null?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter(n=>{let[r]=Ln(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,r;let a=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[t];return a!=null?a.name:t},{})}checkOutputs(e){e.forEach(t=>{let[n]=Ln(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}},kV=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},IV="?tfjs-format=file",SV="model.json",Hb=class{constructor(e,t={},n=Qt){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new kV}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return w.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let a=this.artifacts.userDefinedMetadata;a.signature!=null&&(n=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ym(Zw.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let a=Zw.Instance.transformGraph(e.modelInitializer);this.initializer=new ym(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Pe?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Pe)&&!Array.isArray(e)){let a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(let s in a){let i=a[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,s)=>{var i,o,l;let p=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return p!=null?a[s]=this.resourceIdToCapturedInput[p]:a[s]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function NV(e,t={},n=Qt){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=CV(e));let r=new Hb(e,t,n);return await r.load(),r}function TV(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=Qt.getWeightSpecs(r.weightsManifest),i=Qt.getModelArtifactsForJSONSync(r,s,a);t=Qt.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Qt.fromMemorySync(e);else throw new Error("Unknown model format");let n=new Hb(t);return n.load(),n}function CV(e){return e.endsWith("/")||(e=e+"/"),`${e}${SV}${IV}`}var _V="4.2.0",XI={};Ee(XI,{CSVDataset:()=>aS,Dataset:()=>Hl,FileDataSource:()=>hS,TextLineDataset:()=>rS,URLDataSource:()=>dS,array:()=>JV,csv:()=>lU,func:()=>uU,generator:()=>pU,microphone:()=>dU,version_data:()=>cU,webcam:()=>hU,zip:()=>YV});var EV=Ua(yd()),$V=Ua(yd());function AV(e,t){return rd(e,t)}function rd(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse)if(So(e)){let s=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=rd(o,t,n,r);s[i]=l}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,a.value),a.value}function RV(e,t=JI){return ZI(e,t)}function ZI(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse)if(So(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(p=>p[i]),l=ZI(o,t,n);s[i]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return a.value}function JI(e){return e===null?null:So(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function YI(e,t){let n=new Map;rd(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(w.isPromise(a)){let s=await a;n.set(r,s)}}return rd(e,t,n)}function So(e){let t=!1;if(j().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=Uv();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Pe)&&!(e instanceof Promise)&&!t)}function FV(e){return e==null||DV(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Pe||w.isTypedArray(e)}function DV(e){return e===null||typeof e!="object"&&typeof e!="function"}function MV(e){return AV(e,OV)}function OV(e){return e instanceof Pe?{value:e.clone(),recurse:!1}:So(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var QI=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},jb=class extends QI{constructor(){super(jb.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};jb.INITIAL_CAPACITY=32;function eS(e){return new PV(e)}function qb(e){return new BV(e)}function LV(e,t){return new tS(e,t)}function zV(e,t=Ca.FAIL){return new XV(e,t)}var Gt=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new qV(this,e)}filter(e){return new HV(this,e)}map(e){return new jV(this,e)}mapAsync(e){return new rv(this,e)}serialMapAsync(e){return new rv(this,e).serial()}flatmap(e){return new KV(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new GV(this,e,t)}columnMajorBatch(e,t=!0,n=JI){return this.rowMajorBatch(e,t).map(r=>RV(r,n))}concatenate(e,t){return new tS(eS([this,e]),t)}take(e){return e<0||e==null?this:new UV(this,e)}skip(e){return e<0||e==null?this:new VV(this,e)}prefetch(e){return new nS(this,e)}shuffle(e,t){return new ZV(this,e,t)}serial(){return new WV(this)}},PV=class extends Gt{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:MV(e),done:!1}}},BV=class extends Gt{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},WV=class extends Gt{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},VV=class extends Gt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;_e(e.value)}return this.upstream.next()}},UV=class extends Gt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},GV=class extends Gt{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},HV=class extends Gt{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;_e(e.value)}}},jV=class extends Gt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ir.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ir.getTensorsInContainer(n);for(let a of t)Ir.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},qV=class extends Gt{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},rv=class extends Gt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ir.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Ir.getTensorsInContainer(n);for(let a of t)Ir.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},Kb=class extends Gt{constructor(){super(),this.outputQueue=new jb,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},KV=class extends Kb{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Ir.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ir.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Ir.isTensorInList(a,r)||a.dispose();return!0}},tS=class extends Gt{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Ca;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(Ca||(Ca={}));var XV=class extends Gt{constructor(e,t=Ca.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(s){return s instanceof Gt?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let a=await YI(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Ca.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Ca.SHORTEST:return{value:null,done:!0};case Ca.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},nS=class extends Gt{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new QI(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},ZV=class extends nS{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=$V.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Hl=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),On(async()=>(await n.iterator()).columnMajorBatch(e,t,QV),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,On(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,On(async()=>(await t.iterator()).filter(r=>W(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return On(async()=>(await t.iterator()).map(n=>W(()=>e(n))),this.size)}mapAsync(e){let t=this;return On(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return On(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,On(async()=>{let r=qb(async()=>({value:await t.iterator(),done:!1}));return LV(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,On(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=EV.alea(t||w.now().toString());return On(async()=>{let s=a.int32();return n&&(s+=a.int32()),(await r.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,On(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Hl.MAX_BUFFER_SIZE=1e4;function On(e,t=null){return new class extends Hl{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function JV(e){return On(async()=>eS(e),e.length)}function YV(e){if(!So(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return On(async()=>{let n=await YI(e,r=>{if(r instanceof Hl)return{value:r.iterator(),recurse:!1};if(So(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return zV(n,Ca.SHORTEST)},t)}function QV(e){if(e===null)return null;let t=e[0];return FV(t)?{value:eU(e),recurse:!1}:{value:null,recurse:!0}}function eU(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Pe?Ot(e):dn(e)}var rS=class extends Hl{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},yh='"',hu=Symbol("out"),av=Symbol("field"),bh=Symbol("quote"),Ef=Symbol("quoteafterquote"),sv=Symbol("quoteinquote"),aS=class extends Hl{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new rS(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(w.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[a],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let p=Number(o);if(isNaN(p))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=p;else switch(i.dtype){case"float32":l=p;break;case"int32":l=Math.floor(p);break;case"bool":l=this.getBoolean(o);break;default:l=p}}i&&i.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=hu;for(let i=0;i<a;i++)switch(s){case hu:switch(e.charAt(i)){case yh:r=i+1,s=bh;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=hu;break;default:s=av,r=i;break}break;case av:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=hu,r=i+1;break}break;case bh:switch(e.charAt(i)){case yh:s=Ef;break}break;case Ef:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=hu,r=i+1;break;case yh:s=bh;break;default:s=sv;break}break;case sv:switch(e.charAt(i)){case yh:s=bh;break}break}if(s===Ef?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},sS=class extends Gt{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!j().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new sS(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((r,a)=>n.set(r,a*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(w.sizeFromShape(t));return n.set(e,n.length-e.length),dn(n,t)}},iS=class extends Gt{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Je([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-n)/2,s=(1-r)/2,i=a+n,o=r+s;this.cropBox=Br([s,a,o,i],[1,4])}else this.cropBox=Br([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!j().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new iS(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Cp.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return W(()=>{let t=Jt(se(e,"float32"),0),n;n=wr.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return P(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},oS=class{},lS=class extends Gt{split(e){return new tU(this,e)}},tU=class extends lS{constructor(e,t){super(),this.upstream=e,this.impl=new nU(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},nU=class extends Kb{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},rU=class extends Gt{decodeUTF8(){return new aU(this)}},aU=class extends lS{constructor(e){super(),this.upstream=e,this.impl=new sU(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},sU=class extends Kb{constructor(e){if(super(),this.upstream=e,j().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=Uv();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return j().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},uS=class extends rU{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(j().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=s=>t(new Error("Aborted")),r.onerror=s=>t(new Error(s.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}),done:!1}}};async function iU(e,t={},n){let r,a;typeof e=="string"?r=e:(r=e.url,a=oU(e));let s=await(n||w.fetch)(r,a);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new uS(i,t)}else throw new Error(s.statusText)}var oU=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function pS(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var hS=class extends oS{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(pS(this.input)&&j().get("IS_NODE")){let e=Pm();this.input=e.readFileSync(this.input.slice(7))}return new uS(this.input,this.options)}},dS=class extends oS{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return pS(this.url)?new hS(this.url,this.fileOptions).iterator():iU(this.url,this.fileOptions)}};function lU(e,t={}){return new aS(new dS(e),t)}function uU(e){let t=qb(e);return On(async()=>t)}function pU(e){return On(async()=>{let t=await e();return qb(()=>t.next())})}async function hU(e,t){return iS.create(e,t)}async function dU(e){return sS.create(e)}var cU="4.2.0";function ye(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var fU=qr.whereImpl,Xb=class extends Hu{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new bd(this,pr())}nextDataId(){return Xb.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,j().get("IS_NODE")&&T.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let a=n.map(s=>w.encodeString(s));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let r=this.readSync(n.real.dataId),a=this.readSync(n.imag.dataId);return T.mergeRealAndImagArrays(r,a)}return w.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>w.decodeString(r));return ze(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(e.shape,e.dtype,t)}makeOutput(e,t,n){return pr().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ye([e],"where");let t=this.readSync(e.dataId);return fU(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Xb.nextDataId=0;var cS={};Ee(cS,{addImpl:()=>gS,bincountImpl:()=>Jb,bincountReduceImpl:()=>yS,castImpl:()=>mS,ceilImpl:()=>bS,concatImpl:()=>Yb,equalImpl:()=>xS,expImpl:()=>vS,expm1Impl:()=>IS,floorImpl:()=>SS,gatherNdImpl:()=>NS,gatherV2Impl:()=>TS,greaterEqualImpl:()=>_S,greaterImpl:()=>CS,lessEqualImpl:()=>$S,lessImpl:()=>ES,linSpaceImpl:()=>AS,logImpl:()=>RS,maxImpl:()=>FS,maximumImpl:()=>DS,minimumImpl:()=>MS,multiplyImpl:()=>Qb,negImpl:()=>OS,notEqualImpl:()=>LS,prodImpl:()=>zS,raggedGatherImpl:()=>PS,raggedRangeImpl:()=>BS,raggedTensorToTensorImpl:()=>WS,rangeImpl:()=>tx,rsqrtImpl:()=>VS,scatterImpl:()=>so,sigmoidImpl:()=>lG,simpleAbsImpl:()=>fS,sliceImpl:()=>sd,sparseFillEmptyRowsImpl:()=>GS,sparseReshapeImpl:()=>HS,sparseSegmentReductionImpl:()=>nx,sqrtImpl:()=>hG,squaredDifferenceImpl:()=>jS,stridedSliceImpl:()=>qS,stringNGramsImpl:()=>rx,stringSplitImpl:()=>ax,stringToHashBucketFastImpl:()=>sx,subImpl:()=>KS,tileImpl:()=>XS,topKImpl:()=>JS,transposeImpl:()=>ex,uniqueImpl:()=>YS});function fS(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var mU=e=>{let{x:t}=e.inputs,n=e.backend;ye(t,"abs");let r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=fS(a),n.makeOutput(r,t.shape,t.dtype)},gU={kernelName:Ao,backendName:"cpu",kernelFunc:mU};function At(e){return(t,n,r,a,s)=>{let i=T.assertAndGetBroadcastShape(t,n),o=i.length,l=w.computeStrides(i),p=w.sizeFromShape(i),u=w.getTypedArrayFromDType(s,p),h=t.length,d=n.length,c=w.computeStrides(t),f=w.computeStrides(n),m=T.getBroadcastDims(t,i),g=T.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<u.length;++y){let b=w.indexToLoc(y,o,l),x=b.slice(-h);m.forEach(C=>x[C]=0);let v=w.locToIndex(x,h,c),I=b.slice(-d);g.forEach(C=>I[C]=0);let N=w.locToIndex(I,d,f);u[y]=e(r[v],a[N])}return[u,i]}}function zn(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var yU={kernelName:Td,backendName:"cpu",kernelFunc:zn};function ad(e,t,n="float32"){if(n==="complex64"){let a=ad(e,t,"float32"),s=ad(e,t,"float32");return zn({inputs:{real:a,imag:s},backend:e})}let r=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Gr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var bU={kernelName:ii,backendName:"cpu",kernelFunc:Gr};function Ms(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var xU={kernelName:Kd,backendName:"cpu",kernelFunc:Ms};function mS(e,t,n,r){if(r==="int32"){let a=Int32Array.from(e);return[t,"int32",a]}if(r==="bool"){let a=w.toTypedArray([0],n),[s,i]=At((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Ba(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Gr({inputs:{x:a},backend:n});let u=ad(n,a.shape,a.dtype),h=Ba({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),d=zn({inputs:{real:h,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),d}if(a.dtype==="complex64"){let u=Ms({inputs:{input:a},backend:n}),h=Ba({inputs:{x:u},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(u),h}if(!w.hasEncodingLoss(a.dtype,s)){let u=Gr({inputs:{x:a},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,p]=mS(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,p)}var wU={kernelName:Hs,backendName:"cpu",kernelFunc:Ba};function jt(e,t,n,r){return n==null?({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;ye([i,o],e);let p=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=i.dtype==="string"?T.fromUint8ToStringArray(p):p,d=i.dtype==="string"?T.fromUint8ToStringArray(u):u,c=r||i.dtype,[f,m]=t(i.shape,o.shape,h,d,c);return l.makeTensorInfo(m,c,f)}:({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let p=Ba({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(p.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,c=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,m=Ba({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,v=l.data.get(b.dataId).values,[I,N,C]=n(i.shape,o.shape,c,f,x,v),E=l.makeTensorInfo(C,"float32",I),A=l.makeTensorInfo(C,"float32",N),F=zn({inputs:{real:E,imag:A},backend:l});return l.disposeIntermediateTensorInfo(p),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(E),l.disposeIntermediateTensorInfo(A),F}else{let p=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,h=r||i.dtype,[d,c]=t(i.shape,o.shape,p,u,h);return l.makeTensorInfo(c,h,d)}}}function Zb(e){return(t,n,r,a,s,i)=>{let o=T.assertAndGetBroadcastShape(t,n),l=w.sizeFromShape(o),p=o.length,u=w.computeStrides(o),h=w.getTypedArrayFromDType("float32",l),d=w.getTypedArrayFromDType("float32",l),c=T.getBroadcastDims(t,o),f=T.getBroadcastDims(n,o),m=T.mergeRealAndImagArrays(r,a),g=T.mergeRealAndImagArrays(s,i),y=t.length,b=w.computeStrides(t),x=n.length,v=w.computeStrides(n);if(c.length+f.length===0)for(let I=0;I<h.length;I++){let N=I%m.length,C=I%g.length,E=e(m[N*2],m[N*2+1],g[C*2],g[C*2+1]);h[I]=E.real,d[I]=E.imag}else for(let I=0;I<h.length;I++){let N=w.indexToLoc(I,p,u),C=N.slice(-y);c.forEach(S=>C[S]=0);let E=w.locToIndex(C,y,b),A=N.slice(-x);f.forEach(S=>A[S]=0);let F=w.locToIndex(A,x,v),R=e(m[E*2],m[E*2+1],g[F*2],g[F*2+1]);h[I]=R.real,d[I]=R.imag}return[h,d,o]}}var gS=At((e,t)=>e+t),vU=Zb((e,t,n,r)=>({real:e+n,imag:t+r})),No=jt(Ha,gS,vU),kU={kernelName:Ha,backendName:"cpu",kernelFunc:No};function Jb(e,t,n,r,a){let s=w.sizeFromShape(r),i=w.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function yS(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=ze([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<s;l++){let p=e.get(o,l);if(p<0)throw new Error("Input x must be non-negative!");p>=n||(r?i.set(1,o,p):t.size>0?i.set(i.get(o,p)+t.get(o,l),o,p):i.set(i.get(o,p)+1,o,p))}return i}function Qa(e){return(t,n,r)=>{let a=w.getTypedArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function Qe(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(ye(i,e),i.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,p=w.sizeFromShape(i.shape),u=n||i.dtype,h=w.getArrayFromDType(u,p);for(let d=0;d<p;++d)h[d]=t(l[d],a);return o.makeTensorInfo(i.shape,u,h)}}function jl(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(ye(i,e),i.dtype==="string"||n==="string")throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,p=n||i.dtype,u=t(l,p,a);return o.makeTensorInfo(i.shape,p,u)}}var bS=Qa(e=>Math.ceil(e)),IU=jl(js,bS),SU={kernelName:js,backendName:"cpu",kernelFunc:IU};function Yb(e,t,n,r){let a=w.getArrayFromDType(n,w.sizeFromShape(t));if(r&&n!=="string"){let s=0;e.forEach(i=>{let o=w.sizeFromShape(i.shape);a.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?T.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let p=0;p<i.shape[0];++p){let u=p*t[1]+s;for(let h=0;h<i.shape[1];++h)a[u+h]=o[l++]}s+=i.shape[1]})}return a}var xS=At((e,t)=>e===t?1:0),wS=jt(qo,xS,null,"bool"),NU={kernelName:qo,backendName:"cpu",kernelFunc:wS},vS=Qa(e=>Math.exp(e)),kS=jl(ti,vS,"float32"),TU={kernelName:ti,backendName:"cpu",kernelFunc:kS},IS=Qa(e=>Math.expm1(e)),CU=jl(Xo,IS),_U={kernelName:Xo,backendName:"cpu",kernelFunc:CU},SS=Qa(e=>Math.floor(e)),EU=jl(ni,SS),$U={kernelName:ni,backendName:"cpu",kernelFunc:EU};function NS(e,t,n,r,a,s,i,o,l){let p=ze([r,s],n);for(let u=0;u<r;u++){let h=[],d=0;for(let c=0;c<a;c++){let f=e[u*a+c];d+=f*i[c],h.push(f)}if(d<0||d>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let c=0;c<s;c++)p.values[u*s+c]=t.get(...t.indexToLoc(d*s+c))}return p}function TS(e,t,n){let r=ze(n,e.dtype);for(let a=0;a<r.size;++a){let s=r.indexToLoc(a).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let p=e.locToIndex(s);0<=p&&p<e.values.length&&(r.values[a]=e.values[p])}return r}var CS=At((e,t)=>e>t?1:0),AU=jt(Qo,CS,null,"bool"),RU={kernelName:Qo,backendName:"cpu",kernelFunc:AU},_S=At((e,t)=>e>=t?1:0),FU=jt(si,_S,null,"bool"),DU={kernelName:si,backendName:"cpu",kernelFunc:FU},ES=At((e,t)=>e<t?1:0),MU=jt(nl,ES,null,"bool"),OU={kernelName:nl,backendName:"cpu",kernelFunc:MU},$S=At((e,t)=>e<=t?1:0),LU=jt(rl,$S,null,"bool"),zU={kernelName:rl,backendName:"cpu",kernelFunc:LU};function AS(e,t,n){let r=(t-e)/(n-1),a=w.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var RS=Qa(e=>Math.log(e)),PU=jl(ui,RS),BU={kernelName:ui,backendName:"cpu",kernelFunc:PU};function FS(e,t,n,r){let a=w.getTypedArrayFromDType(r,w.sizeFromShape(n));for(let s=0;s<a.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let p=e[i+l];(Number.isNaN(p)||p>o)&&(o=p)}a[s]=o}return a}var DS=At((e,t)=>Math.max(e,t)),WU=jt(hi,DS),VU={kernelName:hi,backendName:"cpu",kernelFunc:WU},MS=At((e,t)=>Math.min(e,t)),UU=jt(mi,MS),GU={kernelName:mi,backendName:"cpu",kernelFunc:UU},Qb=At((e,t)=>e*t),HU=Zb((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),ef=jt(yi,Qb,HU),jU={kernelName:yi,backendName:"cpu",kernelFunc:ef};function OS(e,t,n){let r=w.createScalarValue(-1,n);return Qb([],t,r,e,n)}function qU(e){let{inputs:t,backend:n}=e,{x:r}=t;ye(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=OS(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var KU={kernelName:ul,backendName:"cpu",kernelFunc:qU},LS=At((e,t)=>e!==t?1:0),XU=jt(pl,LS,null,"bool"),ZU={kernelName:pl,backendName:"cpu",kernelFunc:XU};function ex(e,t,n,r,a){let s=t.length,i=w.sizeFromShape(t),o=w.computeStrides(t),l=w.computeStrides(a),p=w.getTypedArrayFromDType(n,w.sizeFromShape(a));for(let u=0;u<i;++u){let h=w.indexToLoc(u,s,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[r[f]];let c=w.locToIndex(d,s,l);p[c]=e[u]}return p}function An(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;ye(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=r.data.get(a.dataId).values,p=ex(l,a.shape,a.dtype,s,o);return{dataId:r.write(p,o,a.dtype),shape:o,dtype:a.dtype}}var JU={kernelName:aa,backendName:"cpu",kernelFunc:An};function zS(e,t,n,r){let[a,s]=T.computeOutAndReduceShapes(e,r),i=tr(t,"int32"),o=w.makeZerosTypedArray(w.sizeFromShape(a),i),l=w.sizeFromShape(s);for(let p=0;p<o.length;++p){let u=p*l,h=1;for(let d=0;d<l;++d)h*=n[u+d];o[p]=h}return{outVals:o,outShape:a,outDtype:i}}function YU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"prod");let o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=T.getAxesPermutation(l,o),u=l,h=a,d=[];p!=null&&(h=An({inputs:{x:a},backend:n,attrs:{perm:p}}),d.push(h),u=T.getInnerMostAxes(u.length,o));let c=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=zS(h.shape,h.dtype,c,u),y=m;return i&&(y=T.expandShapeToKeepDim(m,l)),d.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}var QU={kernelName:ki,backendName:"cpu",kernelFunc:YU};function eG(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let s=w.indexToLoc(a,t.length,w.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function tG(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function nG(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);tG(n,r);let l=1;for(let p=0;p<t.length-1;++p){l*=t[p];let u=t[p+1];for(let h=1;h<l+1;++h)o[p].push(h*u)}for(let p=0;p<e.length;++p){let u=e[p],h=e[p]+1;for(let d=0;d<n.length;++d){let c=n[d],f=d+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-c[u];for(let y=u;y<h;++y)o[f].push(c[y+1]+g)}u=c[u],h=c[h]}h!==u&&(a.push([u,h]),s+=h-u)}return{outSplits:o,valueSlices:a,numValues:s}}function rG(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=w.getArrayFromDType("int32",r);t.push(a),e[n].forEach((s,i)=>a[i]=s)}return t}function iv(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function aG(e,t,n,r,a,s){let i=iv(t,2)[1],o=iv(s,2)[1],l=0;for(let p of n)for(let u=p[0];u<p[1];++u){for(let h=0;h<r;++h)a[l*o+h]=e[u*i+h];++l}}function sG(e,t,n,r,a){let s=t.slice();s[0]=a;let i=w.getArrayFromDType(n,w.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return aG(e,t,r,l,i,s),[i,s]}function PS(e,t,n,r,a,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(eG(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let p=r[0],{outSplits:u,valueSlices:h,numValues:d}=nG(s,i,e,p),c=rG(u),f=sG(n,r,a,h,d);return[c,f[0],f[1]]}var ov=2147483647;function BS(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=a.length===0,p=i.length===0,u=[];o||u.push(t[0]),l||u.push(a[0]),p||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let h=u.length===0?1:u[0],d=w.getArrayFromDType("int32",h+1);d[0]=0;for(let g=0;g<h;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],x=p?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<y||x<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/x)),v>ov)throw new Error(`Requires ((limit - start) / delta) <= ${ov}`);d[g+1]=d[g]+v}let c=d[h],f=w.getArrayFromDType(n,c),m=0;for(let g=0;g<h;++g){let y=d[g+1]-d[g],b=o?e[0]:e[g],x=p?s[0]:s[g];for(let v=0;v<y;++v)f[m++]=b,b+=x}return[d,f]}var or=T.RowPartitionType,bm=class{constructor(e,t,n,r,a,s,i,o,l,p){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=T.getRowPartitionTypesHelper(p),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===or.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===or.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case or.VALUE_ROWIDS:return bm.getMaxWidthValueRowID(t);case or.ROW_SPLITS:return bm.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${or[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let r=0;r<t-1;++r){let a=e[r+1]-e[r];a>n&&(n=a)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let i=e[s];i!==r&&(r=i,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return uv(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;T.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=T.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return w.assert(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let o=e[i+1]-e[i],l=Math.min(r,o),p=t[i];p===-1&&(l=0);for(let u=0;u<l;++u)s.push(p),p+=n;for(let u=0;u<o-l;++u)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(a===0)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let p=1;p<a;++p){let u=e[p];if(u===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=u,u>=t.length)throw new Error(`Got nextValueRowId=${u} which is not less than ${t.length}`);l=t[u]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case or.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case or.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${or[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case or.FIRST_DIM_SIZE:return e[0];case or.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case or.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${or[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let r=uv(t,!1),a=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let i=1;i<=this.raggedRank;++i)s=this.calculateOutputIndex(i-1,s,n[i],t[i]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(n.length===0)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=w.sizeFromShape(i),l=t.length,p=this.defaultValue;if(p.length!==o&&p.length!==1){let c=this.defaultValueShape;W(()=>{let f=P(p,c);p=ys(f,i).dataSync()})}let u=0,h=0,d=0;for(let c=0;c<=l;++c){let f=c<l?t[c]:-1;if(f===d){++d;continue}if(h<d){let m=a.subarray(u*o),g=s.subarray(h*o),y=(d-h)*o;lv(g,m,y)}if(c>=l){let m=n.length;f=Math.floor(m/o)}if(f>d)if(this.defaultValue.length===1)s.subarray(d*o,f*o).fill(this.defaultValue[0]),d=f;else for(;f>d;){let m=s.slice(d*o);lv(m,p,o),++d}f<0?(u=c+1,h=d):(u=c,h=d,d=h+1)}}};function lv(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function uv(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function WS(e,t,n,r,a,s,i,o,l,p){return new bm(e,t,n,r,a,s,i,o,l,p).compute()}function tx(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return w.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=w.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let p=1;p<l.length;p++)l[p]=l[p-1]+n;return l}var VS=Qa(e=>1/Math.sqrt(e)),iG=jl($i,VS),oG={kernelName:$i,backendName:"cpu",kernelFunc:iG};function so(e,t,n,r,a,s,i,o,l,p){let u=[r/a,a],h=e.values,d=t.values;if(r===0)return ze(n,t.dtype);let c=ze(u,t.dtype);typeof l=="string"||typeof l=="number"?c.values.fill(l):typeof l=="boolean"&&c.values.fill(+l);for(let f=0;f<s;f++){let m=[],g=0;for(let y=0;y<i;y++){let b=h[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/a)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<a;y++)p?c.values[g*a+y]+=d[f*a+y]:c.values[g*a+y]=t.rank===0?d[0]:d[f*a+y]}return c}var lG=Qa(e=>1/(1+Math.exp(-e))),US=Qe(Ri,e=>1/(1+Math.exp(-e))),uG={kernelName:Ri,backendName:"cpu",kernelFunc:US};function sd(e,t,n,r,a){let s=Lt.isSliceContinous(r,t,n),i=w.sizeFromShape(n),o=w.computeStrides(r);if(s){let h=Lt.computeFlatOffset(t,o);return a==="string"?e.slice(h,h+i):e.subarray(h,h+i)}let l=a==="string"?T.fromUint8ToStringArray(e):e,p=ze(r,a,l),u=ze(n,a);for(let h=0;h<u.size;++h){let d=u.indexToLoc(h),c=d.map((f,m)=>f+t[m]);u.set(p.get(...c),...d)}return a==="string"?T.fromStringArrayToUint8(u.values):u.values}function Os(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;ye(a,"slice");let[o,l]=Lt.parseSliceParams(a,s,i);Lt.assertParamsValid(a,o,l);let p=n.data.get(a.dataId).values,u=sd(p,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var pG={kernelName:wl,backendName:"cpu",kernelFunc:Os};function GS(e,t,n,r,a,s,i){let o=t[0],l=s[0],p=new Array(l),u=new Array(o),h=t[1];if(l===0){if(o!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=w.getArrayFromDType(n,0),y=w.getArrayFromDType(a,0);return[g,[0,h],y,p,u]}let d=!0,c=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*h];if(y<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],d=d&&y>=c,c=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;p[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){let g=e,y=r;for(let b=0;b<o;++b)u[b]=b;return[g,[o,h],y,p,u]}else{let g=f[l-1],y=w.getArrayFromDType(n,g*h),b=w.getArrayFromDType(a,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let I=e[v*h],N=x[I],C=(I===0?0:f[I-1])+N;x[I]++;for(let E=0;E<h;++E)y[C*h+E]=e[v*h+E];b[C]=r[v],u[v]=C}for(let v=0;v<l;++v)if(x[v]===0){let I=v===0?0:f[v-1];y[I*h+0]=v;for(let N=1;N<h;++N)y[I*h+N]=0;b[I]=i}return[y,[g,h],b,p,u]}}function HS(e,t,n,r,a){let s=w.sizeFromShape(r),i=t[0],o=a.length,l=[],p=1,u=-1;for(let m=0;m<o;++m){let g=a[m];if(g===-1){if(u!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(g<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(m,g));p*=g,l.push(g)}}if(u!==-1){if(p<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/p);if(p*m!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=m}if(w.sizeFromShape(l)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let h=r.length,d=[];if(h>0){d[h-1]=1;for(let m=h-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let c=[];if(o>0){c[o-1]=1;for(let m=o-2;m>=0;--m)c[m]=c[m+1]*l[m+1]}let f=w.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<h;++y)g+=e[m*h+y]*d[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/c[y]),g%=c[y]}return[f,[i,o],l]}function nx(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],p=l[1],u=o>0?a[o-1]+1:0;if(u<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=t.slice();h[0]=u;let d=h.reduce((b,x)=>b*x,1),c=w.getArrayFromDType(n,d);if(o===0)return u>0&&c.fill(i),[c,h];if(u<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let b=0;if(m<o){if(b=a[m],y===b){++m;continue}if(y>=b)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=u)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,u));y>g&&c.fill(i,g*p,y*p);for(let x=f;x<m;++x){let v=r[x];if(v<0||v>=l[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],l[0]));for(let I=0;I<p;I++)c[y*p+I]+=e[v*p+I]}if(s)for(let x=0;x<p;x++)c[y*p+x]/=m-f;if(f=m,++m,g=y+1,y=b,m>o)break}return g<u&&c.fill(i,g*p,u*p),[c,h]}var hG=Qa(e=>Math.sqrt(e)),dG=Qe(Fi,e=>Math.sqrt(e)),cG={kernelName:Fi,backendName:"cpu",kernelFunc:dG},jS=At((e,t)=>{let n=e-t;return n*n}),fG=jt(Oi,jS),mG={kernelName:Oi,backendName:"cpu",kernelFunc:fG};function qS(e,t,n,r){let a=ze(e,t.dtype);for(let s=0;s<a.size;s++){let i=a.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];a.set(t.get(...o),...i)}return a}var gG=class{constructor(e,t,n,r,a,s){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),p=Math.max(0,o-(a-(i+1))),u=s-(l+p),h=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let y=0;y<u;++y)d+=e[h+y].length;d+=p*this.rightPad.length;let c=l+p+u-1;d+=c*this.separator.length,n[r+i]=new Uint8Array(d);let f=n[r+i],m=0,g=y=>y.forEach(b=>f[m++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<u-1;++y)g(e[h+y]),g(this.separator);if(u>0){g(e[h+u-1]);for(let y=0;y<p;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<p-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let p=t[l]>=o;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,s=w.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=a;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],p=0;this.nGramWidths.forEach(u=>{p+=this.getNumNGrams(l,u)}),this.preserveShort&&l>0&&p===0&&(p=1),s[o]=s[o-1]+p}let i=new Array(s[a]);for(let o=0;o<a;++o){let l=t[o],p=s[o];if(this.nGramWidths.forEach(u=>{let h=t[o+1]-t[o],d=this.getNumNGrams(h,u);this.createNGrams(e,l,i,p,d,u),p+=d}),this.preserveShort&&p===s[o]){let u=t[o+1]-t[o];if(u===0)continue;let h=u+2*this.padWidth,d=1;this.createNGrams(e,l,i,p,d,h)}}return[i,s]}};function rx(e,t,n,r,a,s,i,o){return new gG(n,r,a,s,i,o).compute(e,t)}function yG(e,t,n,r){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(a,s);(!n||i.length!==0)&&r.push(i),a=s+1}}function ax(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let d=0;d<r;++d){let c=a.length;yG(e[d],t,n,a);let f=a.length-c;o[d]=f,s+=f,i=Math.max(i,f)}let l=w.getArrayFromDType("int32",s*2),p=new Array(s),u=[r,i],h=0;for(let d=0;d<r;++d)for(let c=0;c<o[d];++c)l[h*2]=d,l[h*2+1]=c,p[h]=a[h],++h;return[l,p,u]}function sx(e,t){let n=w.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=w.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var KS=At((e,t)=>e-t),bG=Zb((e,t,n,r)=>({real:e-n,imag:t-r})),ix=jt(Li,KS,bG),xG={kernelName:Li,backendName:"cpu",kernelFunc:ix};function XS(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=ze(n,e.dtype);for(let a=0;a<r.values.length;++a){let s=r.indexToLoc(a),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);r.values[a]=e.values[o]}return r}var mu=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function ZS(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,p=Math.log(o),u=.5*Math.exp(2*p/3),h=.5*Math.sqrt(p*u*(o-u)/o)*Math.sign(l-o/2),d=Math.max(n,Math.floor(t-l*u/o+h)),c=Math.min(r,Math.floor(t+(o-l)*u/o+h));ZS(e,t,d,c)}let a=e[t],s=n,i=r;for(w.swap(e,n,t),mu(e[r],a)>0&&w.swap(e,n,r);s<i;){for(w.swap(e,s,i),s++,i--;mu(e[s],a)<0;)s=s+1;for(;mu(e[i],a)>0;)i=i-1}mu(e[n],a)===0?w.swap(e,n,i):(i=i+1,w.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function JS(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=w.getTypedArrayFromDType(n,i*r),p=w.getTypedArrayFromDType("int32",i*r);for(let h=0;h<i;h++){let d=h*o,c=e.subarray(d,d+o),f=new Array(c.length);c.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(ZS(f,r),f=f.slice(0,r)),a&&f.sort(mu);let m=h*r,g=l.subarray(m,m+r),y=p.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}let u=t.slice();return u[u.length-1]=r,[ze(u,n,l),ze(u,"int32",p)]}function YS(e,t,n,r){let a=w.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i={},o=new Int32Array(n[a]),l=new Mt(s,r,e),p=[],u=s[0]===1&&s[2]===1;for(let f=0;f<n[a];f++){let m;if(u)m=e[f].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(l.get(y,f,b));m=g.join(",")}if(i[m]!==void 0)o[f]=i[m];else{let g=Object.keys(i).length;i[m]=g,o[f]=g,p.push(f)}}let h=s.slice();h[1]=Object.keys(i).length;let d=new Mt(h,r);p.forEach((f,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)d.set(l.get(g,f,y),g,m,y)});let c=n.slice();return c[a]=h[1],{outputValues:d.values,outputShape:c,indices:o}}nc("cpu",()=>new Xb,1);var QS=Qe(ei,e=>e>=0?e:Math.exp(e)-1),wG={kernelName:ei,backendName:"cpu",kernelFunc:QS};function eN(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;ye([a],"leakyRelu");let i=w.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=w.getTypedArrayFromDType("float32",i);for(let p=0;p<o.length;p++)l[p]=o[p]<0?s*o[p]:o[p];return n.makeTensorInfo(a.shape,"float32",l)}var vG={kernelName:li,backendName:"cpu",kernelFunc:eN},kG=At((e,t)=>e<0?t*e:e);function tN(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;ye([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=kG(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var IG={kernelName:vi,backendName:"cpu",kernelFunc:tN},nN=Qe(Si,e=>Math.max(0,e)),SG={kernelName:Si,backendName:"cpu",kernelFunc:nN},rN=Qe(Ci,e=>Math.min(Math.max(0,e),6)),NG={kernelName:Ci,backendName:"cpu",kernelFunc:rN};function id(e,t,n,r,a){if(n==="linear")return Gr({inputs:{x:t},backend:e});if(n==="relu")return nN({inputs:{x:t},backend:e});if(n==="elu")return QS({inputs:{x:t},backend:e});if(n==="relu6")return rN({inputs:{x:t},backend:e});if(n==="prelu")return tN({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return eN({inputs:{x:t},backend:e,attrs:{alpha:a}});if(n==="sigmoid")return US({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function ut(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=w.sizeFromShape(a.shape),o=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(o);w.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let p=n.data.get(a.dataId);if(p.complexTensorInfos!=null){let u=p.complexTensorInfos.real,h=p.complexTensorInfos.imag;u.shape=o,h.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var TG={kernelName:gl,backendName:"cpu",kernelFunc:ut};function aN(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;ye([a,s],"matMul");let l=a.shape.length,p=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[p-1]:s.shape[p-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[p-2]:s.shape[p-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=w.sizeFromShape(f),y=w.sizeFromShape(m),b=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);w.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,d]:[g,d,u],v=o?[y,c,h]:[y,h,c],I=ut({inputs:{x:a},backend:n,attrs:{shape:x}}),N=ut({inputs:{x:s},backend:n,attrs:{shape:v}}),C=i?I.shape[1]:I.shape[2],E=i?I.shape[2]:I.shape[1],A=o?N.shape[1]:N.shape[2],F=Math.max(g,y),R=n.data.get(I.dataId).values,S=n.data.get(N.dataId).values,M=w.computeStrides(I.shape),B=w.computeStrides(N.shape),[U,G,K]=i?[M[0],1,M[1]]:[M[0],M[1],1],[H,X,ee]=o?[1,B[1],B[0]]:[B[1],1,B[0]],Z=E*A,re=ze([F,E,A],I.dtype),te=re.values,ae=n.blockSize;for(let ie=0;ie<F;ie++){let we=ie%g,be=ie%y;for(let pe=0;pe<E;pe+=ae){let Ie=Math.min(pe+ae,E);for(let Te=0;Te<A;Te+=ae){let De=Math.min(Te+ae,A);for(let Be=0;Be<C;Be+=ae){let et=Math.min(Be+ae,C);for(let Ge=pe;Ge<Ie;Ge++)for(let je=Te;je<De;je++){let $e=0;for(let Ze=Be;Ze<et;Ze++){let st=R[we*U+Ge*G+Ze*K],Fn=S[Ze*H+je*X+be*ee];$e+=st*Fn}te[ie*Z+(Ge*A+je)]+=$e}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(b,re.dtype,re.values)}var CG={kernelName:Gs,backendName:"cpu",kernelFunc:aN};function _G(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:h}=r,d,c,f,m=[];d=aN({inputs:{a,b:s},attrs:{transposeA:l,transposeB:p},backend:n}),i&&(c=No({inputs:{a:d,b:i},backend:n}),m.push(d),d=c),u&&(f=id(n,d,u,o,h),m.push(d),d=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return d}var EG={kernelName:ks,backendName:"cpu",kernelFunc:_G},$G=Qe(Ro,e=>Math.acos(e)),AG={kernelName:Ro,backendName:"cpu",kernelFunc:$G},RG=Qe(Fo,e=>Math.acosh(e)),FG={kernelName:Fo,backendName:"cpu",kernelFunc:RG};function DG(e){let{inputs:t,backend:n}=e,r=t;ye(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),s=ze(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let l=a[o];for(let p=0;p<i.length;p++)i[p]+=l[p]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var MG={kernelName:Ws,backendName:"cpu",kernelFunc:DG};function OG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"all");let o=w.parseAxisParam(s,a.shape),l=o,p=T.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=An({inputs:{x:a},backend:n,attrs:{perm:p}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("all",l,u.shape.length);let[h,d]=T.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];x=x&&I}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=T.expandShapeToKeepDim(h,o),b=ut({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var LG={kernelName:Do,backendName:"cpu",kernelFunc:OG};function zG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"any");let o=w.parseAxisParam(s,a.shape),l=o,p=T.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=An({inputs:{x:a},backend:n,attrs:{perm:p}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("any",l,u.shape.length);let[h,d]=T.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];x=x||I}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=T.expandShapeToKeepDim(h,o),b=ut({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var PG={kernelName:Mo,backendName:"cpu",kernelFunc:zG};function BG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ye(a,"argMax");let i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=An({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,h]=T.computeOutAndReduceShapes(l.shape,i),d=w.sizeFromShape(u),c=w.makeZerosTypedArray(d,"int32"),f=w.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let I=m[y+v];I>b&&(b=I,x=v)}c[g]=x}return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",c)}var WG={kernelName:Vs,backendName:"cpu",kernelFunc:BG};function VG(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ye(a,"argMin");let i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=An({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,h]=T.computeOutAndReduceShapes(l.shape,i),d=w.sizeFromShape(u),c=w.makeZerosTypedArray(d,"int32"),f=w.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let I=m[y+v];I<b&&(b=I,x=v)}c[g]=x}return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",c)}var UG={kernelName:ju,backendName:"cpu",kernelFunc:VG},GG=Qe(Oo,e=>Math.asin(e)),HG={kernelName:Oo,backendName:"cpu",kernelFunc:GG},jG=Qe(Lo,e=>Math.asinh(e)),qG={kernelName:Lo,backendName:"cpu",kernelFunc:jG},KG=Qe(zo,e=>Math.atan(e)),XG={kernelName:zo,backendName:"cpu",kernelFunc:KG},ZG=At((e,t)=>Math.atan2(e,t)),JG=jt(Bo,ZG),YG={kernelName:Bo,backendName:"cpu",kernelFunc:JG},QG=Qe(Po,e=>Math.atanh(e)),eH={kernelName:Po,backendName:"cpu",kernelFunc:QG};function ox(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,p=a.dilationWidth,u=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,c=a.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ze(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let v=0;v<a.batchSize;++v){let I=v*y,N=v*r[0];for(let C=0;C<a.inChannels;++C)for(let E=0;E<a.outHeight;++E){let A=E*i-d,F=Math.max(0,A),R=Math.min(a.inHeight,u+A),S=I+E*b;for(let M=0;M<a.outWidth;++M){let B=M*o-c,U=Math.max(0,B),G=Math.min(a.inWidth,h+B),K=f,H=0,X=0;for(let Z=F;Z<R;Z+=l){let re=N+Z*r[1];for(let te=U;te<G;te+=p){let ae=re+te*r[2],ie=e[ae+C];s==="max"&&ie>K?K=ie:s==="avg"&&(H+=ie,X++)}if(isNaN(K))break}let ee=S+M*x+C;g[ee]=s==="avg"?H/X:K}}}return m}function sN(e,t,n,r,a=!1,s=!1){let i=ze(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,p=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,c=r.padInfo.top,f=r.padInfo.left,m=ze(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let x=b*o-c,v=x;for(;v<0;)v+=p;let I=Math.min(r.inHeight,h+x);for(let N=0;N<r.outWidth;++N){let C=N*l-f,E=C;for(;E<0;)E+=u;let A=Math.min(r.inWidth,d+C),F=Number.NEGATIVE_INFINITY,R=-1;for(let S=v;S<I;S+=p){let M=S-x;for(let B=E;B<A;B+=u){let U=B-C,G=m.get(g,S,B,y);G>F&&(F=G,a?R=s?((g*r.inHeight+S)*r.inWidth+B)*r.inChannels+y:(S*r.inWidth+B)*r.inChannels+y:R=M*d+U)}}i.set(R,g,b,N,y)}}return i}function iN(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,p=a.dilationDepth,u=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,c=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ze(a.outShape,n),v=x.values,I=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[2]*a.outShape[3]*a.outShape[4],C=a.outShape[3]*a.outShape[4],E=a.outShape[4];for(let A=0;A<a.batchSize;++A){let F=A*I,R=A*r[0];for(let S=0;S<a.inChannels;++S)for(let M=0;M<a.outDepth;++M){let B=M*i-m,U=B;for(;U<0;)U+=p;let G=Math.min(a.inDepth,d+B),K=F+M*N;for(let H=0;H<a.outHeight;++H){let X=H*o-g,ee=X;for(;ee<0;)ee+=u;let Z=Math.min(a.inHeight,c+X),re=K+H*C;for(let te=0;te<a.outWidth;++te){let ae=te*l-y,ie=ae;for(;ie<0;)ie+=h;let we=Math.min(a.inWidth,f+ae),be=re+te*E,pe=b,Ie=0,Te=0;for(let Be=U;Be<G;Be+=p){let et=R+Be*r[1];for(let Ge=ee;Ge<Z;Ge+=u){let je=et+Ge*r[2];for(let $e=ie;$e<we;$e+=h){let Ze=je+$e*r[3],st=e[Ze+S];if(s==="max"&&st>pe?pe=st:s==="avg"&&(Ie+=st,Te++),isNaN(pe))break}if(isNaN(pe))break}if(isNaN(pe))break}let De=be+S;v[De]=s==="avg"?Ie/Math.max(Te,1):pe}}}}return x}function tH(e,t){let n=ze(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,p=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,c=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-d,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,p+b);for(let I=0;I<t.outHeight;++I){let N=I*a-c,C=N;for(;C<0;)C+=o;let E=Math.min(t.inHeight,u+N);for(let A=0;A<t.outWidth;++A){let F=A*s-f,R=F;for(;R<0;)R+=l;let S=Math.min(t.inWidth,h+F),M=Number.NEGATIVE_INFINITY,B=-1;for(let U=x;U<v;U+=i){let G=U-b;for(let K=C;K<E;K+=o){let H=K-N;for(let X=R;X<S;X+=l){let ee=X-F,Z=e.get(m,U,K,X,g);Z>=M&&(M=Z,B=G*u*h+H*u+ee)}}}n.set(B,m,y,I,A,g)}}}return n}function nH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ye(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=T.computePool2DInfo(a.shape,s,i,p,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))h=Gr({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),f=ox(d,a.shape,a.dtype,c,u,"avg");h=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return h}var rH={kernelName:Us,backendName:"cpu",kernelFunc:nH};function aH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r;ye(a,"avgPool3d");let u=T.computePool3DInfo(a.shape,s,i,1,o,l,p),h=n.data.get(a.dataId).values,d=iN(h,a.shape,a.dtype,w.computeStrides(a.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var sH={kernelName:qu,backendName:"cpu",kernelFunc:aH};function iH(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r;ye([a,s],"avgPool3DGrad");let u=T.computePool3DInfo(s.shape,i,o,1,l,p),h=u.strideDepth,d=u.strideHeight,c=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,I=u.effectiveFilterHeight,N=u.effectiveFilterWidth,C=v-1-u.padInfo.front,E=N-1-u.padInfo.left,A=I-1-u.padInfo.top,F=ze(s.shape,"float32"),R=1/(f*m*g),S=n.bufferSync(a);for(let M=0;M<u.batchSize;++M)for(let B=0;B<u.inChannels;++B)for(let U=0;U<u.inDepth;++U)for(let G=0;G<u.inHeight;++G)for(let K=0;K<u.inWidth;++K){let H=U-C,X=G-A,ee=K-E,Z=0;for(let re=0;re<v;re+=y){let te=(H+re)/h;if(!(te<0||te>=u.outDepth||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let ie=(X+ae)/d;if(!(ie<0||ie>=u.outHeight||Math.floor(ie)!==ie))for(let we=0;we<N;we+=x){let be=(ee+we)/c;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;let pe=S.get(M,te,ie,be,B);Z+=pe}}}F.set(Z*R,M,U,G,K,B)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}var oH={kernelName:Id,backendName:"cpu",kernelFunc:iH};function lH(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;ye([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:p}=r,u=T.computePool2DInfo(i.shape,o,l,1,p),h=u.strideHeight,d=u.strideWidth,c=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,v=y-1-u.padInfo.top,I=ze(i.shape,"float32"),N=1/(c*f),C=n.data.get(a.dataId).values,E=ze(a.shape,"float32",C);for(let A=0;A<u.batchSize;++A)for(let F=0;F<u.inChannels;++F)for(let R=0;R<u.inHeight;++R)for(let S=0;S<u.inWidth;++S){let M=R-v,B=S-x,U=0;for(let G=0;G<y;G+=m){let K=(M+G)/h;if(!(K<0||K>=u.outHeight||Math.floor(K)!==K))for(let H=0;H<b;H+=g){let X=(B+H)/d;if(X<0||X>=u.outWidth||Math.floor(X)!==X)continue;let ee=E.get(A,K,X,F);U+=ee}}I.set(U*N,A,R,S,F)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var uH={kernelName:kd,backendName:"cpu",kernelFunc:lH};function pH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;w.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ye([a,o,l,s,i],"batchNorm");let{varianceEpsilon:p}=r;p==null&&(p=.001);let u=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,c=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=c.length,b=d.length,x=h.length,v=0,I=0,N=0,C=0;for(let E=0;E<u.length;++E)m[E]=f[v++]+(u[E]-h[I++])*c[N++]/Math.sqrt(d[C++]+p),v>=g&&(v=0),I>=x&&(I=0),N>=y&&(N=0),C>=b&&(C=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var hH={kernelName:ai,backendName:"cpu",kernelFunc:pH};function dH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ye([a],"batchToSpaceND");let o=s.reduce((y,b)=>y*b),l=T.getReshaped(a.shape,s,o),p=T.getPermuted(l.length,s.length),u=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(u,i,s.length),c=ut({inputs:{x:a},backend:n,attrs:{shape:l}}),f=An({inputs:{x:c},backend:n,attrs:{perm:p}}),m=ut({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Os({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var cH={kernelName:Wo,backendName:"cpu",kernelFunc:dH};function fH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,p=Jb(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}var mH={kernelName:Sd,backendName:"cpu",kernelFunc:fH};function gH(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var yH={kernelName:Nd,backendName:"cpu",kernelFunc:gH},bH=Qe(ja,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),xH={kernelName:ja,backendName:"cpu",kernelFunc:bH},wH=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let p=0;p<o.length;p++){let u=o[p],h=l[p];r[p]=Math.hypot(u,h)}return n.makeOutput(r,t.shape,"float32")},vH={kernelName:Ku,backendName:"cpu",kernelFunc:wH};function To(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var kH={kernelName:zd,backendName:"cpu",kernelFunc:To};function Co(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(m=>m.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(m=>m.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>w.sizeFromShape(m.shape)>0);if(l.length===1)return Gr({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(v=>Ms({inputs:{input:v},backend:n})),g=l.map(v=>To({inputs:{input:v},backend:n})),y=Co({inputs:m,backend:n,attrs:{axis:s}}),b=Co({inputs:g,backend:n,attrs:{axis:s}}),x=zn({inputs:{real:y,imag:b},backend:n});return m.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}let p=l.map(m=>{let g=[-1,w.sizeFromShape(m.shape.slice(s))];return ut({inputs:{x:m},backend:n,attrs:{shape:g}})}),u=p.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=T.computeOutShape(p.map(m=>m.shape),1);let h=p[0].shape[0]===1,d=Yb(u,o,t[0].dtype,h),c=T.computeOutShape(l.map(m=>m.shape),s),f=n.makeTensorInfo(c,t[0].dtype,d);return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var IH={kernelName:Vo,backendName:"cpu",kernelFunc:Co};function oN(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:p,dimRoundingMode:u}=r;ye([a,s],"conv2d");let h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!1,h),c=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x=d.dataFormat==="channelsLast",v=new Mt(d.outShape,a.dtype),I=w.computeStrides(a.shape),N=w.computeStrides(s.shape),C=I[0],E=x?I[1]:I[2],A=x?I[2]:1,F=x?1:I[1],R=v.strides[0],S=x?v.strides[1]:v.strides[2],M=x?v.strides[2]:1,B=x?1:v.strides[1],U=n.data.get(a.dataId).values,G=n.data.get(s.dataId).values,K=v.values;for(let H=0;H<d.batchSize;++H){let X=H*C,ee=H*R;for(let Z=0;Z<d.outHeight;++Z){let re=ee+Z*S,te=Z*d.strideHeight-b;for(let ae=0;ae<c;++ae){let ie=te+ae*m;if(ie<0||ie>=d.inHeight)continue;let we=ae*N[0],be=X+ie*E;for(let pe=0;pe<d.outWidth;++pe){let Ie=re+pe*M,Te=pe*d.strideWidth-y;for(let De=0;De<f;++De){let Be=Te+De*g;if(Be<0||Be>=d.inWidth)continue;let et=we+De*N[1],Ge=be+Be*A,je=et;for(let $e=0;$e<d.inChannels;++$e){let Ze=U[Ge+$e*F];for(let st=0;st<d.outChannels;++st)K[Ie+st*B]+=Ze*G[je+st];je+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,K)}var SH={kernelName:qs,backendName:"cpu",kernelFunc:oN};function NH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:u}=r;ye([a,s],"conv2dBackpropFilter");let h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,u,i,1,o,p,!1,h),{strideHeight:c,strideWidth:f,filterHeight:m,filterWidth:g}=d,y=d.dataFormat==="channelsLast",b=new Mt(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,I=n.data.get(a.dataId).values,N=n.data.get(s.dataId).values,C=new Mt(a.shape,a.dtype,I),E=new Mt(s.shape,s.dtype,N);for(let A=0;A<m;++A){let F=Math.max(0,Math.ceil((v-A)/c)),R=Math.min(d.outHeight,(d.inHeight+v-A)/c);for(let S=0;S<g;++S){let M=Math.max(0,Math.ceil((x-S)/f)),B=Math.min(d.outWidth,(d.inWidth+x-S)/f);for(let U=0;U<d.inChannels;++U)for(let G=0;G<d.outChannels;++G){let K=0;for(let H=0;H<d.batchSize;++H)for(let X=F;X<R;++X){let ee=A+X*c-v;for(let Z=M;Z<B;++Z){let re=S+Z*f-x;y?K+=C.get(H,ee,re,U)*E.get(H,X,Z,G):K+=C.get(H,U,ee,re)*E.get(H,G,X,Z)}}b.set(K,A,S,U,G)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var TH={kernelName:Cd,backendName:"cpu",kernelFunc:NH};function CH(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:p,dimRoundingMode:u}=r;ye([a,s],"conv2dBackpropInput");let h=w.computeStrides(s.shape),d=w.computeStrides(a.shape),c=T.convertConv2DDataFormat(p),f=T.computeConv2DInfo(i,s.shape,o,1,l,u,!1,c),m=new Mt(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[x,v,I]=h,{batchSize:N,filterHeight:C,filterWidth:E,inChannels:A,inHeight:F,inWidth:R,outChannels:S,outHeight:M,outWidth:B,strideHeight:U,strideWidth:G}=f;c=f.dataFormat;let K=C-1-f.padInfo.top,H=E-1-f.padInfo.left,X=c==="channelsLast",ee=m.strides[0],Z=X?m.strides[1]:m.strides[2],re=X?m.strides[2]:1,te=X?1:m.strides[1],ae=d[0],ie=X?d[1]:d[2],we=X?d[2]:1,be=X?1:d[1];for(let pe=0;pe<N;++pe)for(let Ie=0;Ie<A;++Ie)for(let Te=0;Te<F;++Te){let De=Te-K,Be=Math.max(0,Math.ceil(De/U)),et=Math.min(M,(C+De)/U);for(let Ge=0;Ge<R;++Ge){let je=Ge-H,$e=Math.max(0,Math.ceil(je/G)),Ze=Math.min(B,(E+je)/G),st=0;for(let kt=Be;kt<et;++kt){let In=kt*U-De;for(let qt=$e;qt<Ze;++qt){let Sn=qt*G-je,sr=ae*pe+ie*kt+we*qt,Dn=x*(C-1-In)+v*(E-1-Sn)+I*Ie;for(let Nn=0;Nn<S;++Nn){let Kt=y[sr+be*Nn],qn=b[Dn+Nn];st+=Kt*qn}}}let Fn=ee*pe+Z*Te+re*Ge+te*Ie;g[Fn]=st}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var _H={kernelName:Ks,backendName:"cpu",kernelFunc:CH};function EH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;ye([a,s],"conv3d");let p=T.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:c,dilationHeight:f,dilationWidth:m,padInfo:g}=p,y=g.front,b=g.left,x=g.top,v=new Mt(p.outShape,a.dtype),I=n.data.get(a.dataId).values,N=n.data.get(s.dataId).values,C=v.values,E=w.computeStrides(a.shape),A=w.computeStrides(s.shape);for(let F=0;F<p.batchSize;++F){let R=F*E[0],S=F*v.strides[0];for(let M=0;M<p.outDepth;++M){let B=S+M*v.strides[1],U=M*p.strideDepth-y;for(let G=0;G<u;++G){let K=U+G*c;if(K<0||K>=p.inDepth)continue;let H=G*A[0],X=R+K*E[1];for(let ee=0;ee<p.outHeight;++ee){let Z=B+ee*v.strides[2],re=ee*p.strideHeight-x;for(let te=0;te<h;++te){let ae=re+te*f;if(ae<0||ae>=p.inHeight)continue;let ie=H+te*A[1],we=X+ae*E[2];for(let be=0;be<p.outWidth;++be){let pe=Z+be*p.outChannels,Ie=be*p.strideWidth-b;for(let Te=0;Te<d;++Te){let De=Ie+Te*m;if(De<0||De>=p.inWidth)continue;let Be=ie+Te*A[2],et=we+De*p.inChannels,Ge=Be;for(let je=0;je<p.inChannels;++je){let $e=I[et+je];for(let Ze=0;Ze<p.outChannels;++Ze)C[pe+Ze]+=$e*N[Ge+Ze];Ge+=p.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var $H={kernelName:Xu,backendName:"cpu",kernelFunc:EH};function AH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;ye([a,s],"conv3dBackpropFilterV2");let p=w.computeStrides(a.shape),u=w.computeStrides(s.shape),h=T.computeConv3DInfo(a.shape,l,i,1,o),d=h.strideDepth,c=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Mt(h.filterShape,"float32"),x=b.values,[v,I,N,C]=b.strides,E=n.data.get(s.dataId).values,[A,F,R,S]=u,M=n.data.get(a.dataId).values,[B,U,G,K]=p,H=h.padInfo.front,X=h.padInfo.left,ee=h.padInfo.top;for(let Z=0;Z<m;++Z){let re=Math.max(0,Math.ceil((H-Z)/d)),te=Math.min(h.outDepth,(h.inDepth+H-Z)/d),ae=Z*v;for(let ie=0;ie<g;++ie){let we=Math.max(0,Math.ceil((ee-ie)/c)),be=Math.min(h.outHeight,(h.inHeight+ee-ie)/c),pe=ie*I+ae;for(let Ie=0;Ie<y;++Ie){let Te=Math.max(0,Math.ceil((X-Ie)/f)),De=Math.min(h.outWidth,(h.inWidth+X-Ie)/f),Be=Ie*N+pe;for(let et=0;et<h.inChannels;++et){let Ge=et*C+Be;for(let je=0;je<h.outChannels;++je){let $e=0;for(let Ze=0;Ze<h.batchSize;++Ze){let st=Ze*B,Fn=Ze*A;for(let kt=re;kt<te;++kt){let In=(Z+kt*d-H)*U+st,qt=kt*F+Fn;for(let Sn=we;Sn<be;++Sn){let sr=(ie+Sn*c-ee)*G+In,Dn=Sn*R+qt;for(let Nn=Te;Nn<De;++Nn){let Kt=(Ie+Nn*f-X)*K+sr,qn=Nn*S+Dn;$e+=M[Kt+et]*E[qn+je]}}}}x[Ge+je]=$e}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var RH={kernelName:_d,backendName:"cpu",kernelFunc:AH};function FH(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;ye([a],"conv3dBackpropInputV2");let p=w.computeStrides(a.shape),u=w.computeStrides(s.shape),h=T.computeConv3DInfo(l,s.shape,o,1,i),d=new Mt(h.inShape,"float32"),c=d.values,[f,m,g,y]=d.strides,b=n.data.get(a.dataId).values,[x,v,I,N]=p,C=n.data.get(s.dataId).values,[E,A,F,R]=u,{batchSize:S,filterDepth:M,filterHeight:B,filterWidth:U,inChannels:G,inDepth:K,inHeight:H,inWidth:X,outChannels:ee,outDepth:Z,outHeight:re,outWidth:te,strideDepth:ae,strideHeight:ie,strideWidth:we}=h,be=M-1-h.padInfo.front,pe=B-1-h.padInfo.top,Ie=U-1-h.padInfo.left;for(let Te=0;Te<S;++Te)for(let De=0;De<G;++De)for(let Be=0;Be<K;++Be){let et=Be-be,Ge=Math.max(0,Math.ceil(et/ae)),je=Math.min(Z,(M+et)/ae);for(let $e=0;$e<H;++$e){let Ze=$e-pe,st=Math.max(0,Math.ceil(Ze/ie)),Fn=Math.min(re,(B+Ze)/ie);for(let kt=0;kt<X;++kt){let In=kt-Ie,qt=Math.max(0,Math.ceil(In/we)),Sn=Math.min(te,(U+In)/we),sr=0;for(let Dn=Ge;Dn<je;++Dn){let Nn=Dn*ae-et;for(let Kt=st;Kt<Fn;++Kt){let qn=Kt*ie-Ze;for(let ga=qt;ga<Sn;++ga){let ru=ga*we-In,Xr=x*Te+v*Dn+I*Kt+N*ga,au=E*(M-1-Nn)+A*(B-1-qn)+F*(U-1-ru)+R*De;for(let Ar=0;Ar<ee;++Ar){let ya=b[Xr+Ar],Xt=C[au+Ar];sr+=ya*Xt}}}}c[f*Te+m*Be+g*$e+y*kt+De]=sr}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var DH={kernelName:Ed,backendName:"cpu",kernelFunc:FH},MH=Qe(Xs,e=>Math.cos(e)),OH={kernelName:Xs,backendName:"cpu",kernelFunc:MH},LH=Qe(Zs,e=>Math.cosh(e)),zH={kernelName:Zs,backendName:"cpu",kernelFunc:LH};function PH(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:p}=r,[u,h,d,c]=a.shape,f=s.shape[0],[m,g]=o,y=ze([f,m,g,c],"float32"),b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,I=w.computeStrides(a.shape),N=w.computeStrides(y.shape);for(let C=0;C<f;C++){let E=C*4,A=b[E],F=b[E+1],R=b[E+2],S=b[E+3],M=x[C];if(M>=u)continue;let B=m>1?(R-A)*(h-1)/(m-1):0,U=g>1?(S-F)*(d-1)/(g-1):0;for(let G=0;G<m;G++){let K=m>1?A*(h-1)+G*B:.5*(A+R)*(h-1);if(K<0||K>h-1){for(let H=0;H<g;H++)for(let X=0;X<c;X++){let ee=X+H*N[2]+G*N[1]+C*N[0];y.values[ee]=p}continue}if(l==="bilinear"){let H=Math.floor(K),X=Math.ceil(K),ee=K-H;for(let Z=0;Z<g;Z++){let re=g>1?F*(d-1)+Z*U:.5*(F+S)*(d-1);if(re<0||re>d-1){for(let we=0;we<c;we++){let be=we+Z*N[2]+G*N[1]+C*N[0];y.values[be]=p}continue}let te=Math.floor(re),ae=Math.ceil(re),ie=re-te;for(let we=0;we<c;we++){let be=we+te*I[2]+H*I[1]+M*I[0],pe=v[be];be=we+ae*I[2]+H*I[1]+M*I[0];let Ie=v[be];be=we+te*I[2]+X*I[1]+M*I[0];let Te=v[be];be=we+ae*I[2]+X*I[1]+M*I[0];let De=v[be],Be=pe+(Ie-pe)*ie,et=Te+(De-Te)*ie;be=we+Z*N[2]+G*N[1]+C*N[0],y.values[be]=Be+(et-Be)*ee}}}else for(let H=0;H<g;++H){let X=g>1?F*(d-1)+H*U:.5*(F+S)*(d-1);if(X<0||X>d-1){for(let re=0;re<c;re++){let te=re+H*N[2]+G*N[1]+C*N[0];y.values[te]=p}continue}let ee=Math.round(X),Z=Math.round(K);for(let re=0;re<c;re++){let te=re+ee*I[2]+Z*I[1]+M*I[0],ae=re+H*N[2]+G*N[1]+C*N[0];y.values[ae]=v[te]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var BH={kernelName:Go,backendName:"cpu",kernelFunc:PH};function WH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ye(a,"cumprod");let l=T.getAxesPermutation([s],a.shape.length),p=a;l!=null&&(p=An({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=T.getInnerMostAxes(1,a.shape.length)[0];if(u!==p.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${u}`);let h=tr(p.dtype,"int32"),d=w.makeOnesTypedArray(w.sizeFromShape(p.shape),h),c=n.data.get(p.dataId).values,f=p.shape[p.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)d[x]=i?1:c[x];else{let v=m(y,b-1);d[x]=i?c[v]*d[v]:c[x]*d[v]}}let g=n.makeTensorInfo(p.shape,h,d);if(l!=null){let y=T.getUndoAxesPermutation(l),b=An({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(p),b}return g}var VH={kernelName:Uo,backendName:"cpu",kernelFunc:WH};function UH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ye(a,"cumsum");let l=T.getAxesPermutation([s],a.shape.length),p=a;l!=null&&(p=An({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=T.getInnerMostAxes(1,a.shape.length)[0];if(u!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${u}`);let h=tr(p.dtype,"int32"),d=w.makeZerosTypedArray(w.sizeFromShape(p.shape),h),c=n.data.get(p.dataId).values,f=p.shape[p.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)d[x]=i?0:c[x];else{let v=m(y,b-1);d[x]=i?c[v]+d[v]:c[x]+d[v]}}let g=n.makeTensorInfo(p.shape,h,d);if(l!=null){let y=T.getUndoAxesPermutation(l),b=An({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(p),b}return g}var GH={kernelName:Js,backendName:"cpu",kernelFunc:UH};function HH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=Jb(l,p,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),p=n.bufferSync(s),u=yS(l,p,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var jH={kernelName:$d,backendName:"cpu",kernelFunc:HH};function qH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;w.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],p=a.shape[2],u=a.shape[3],h=l*s,d=p*s,c=u/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*h*d*c),g=0;for(let y=0;y<o;++y)for(let b=0;b<h;++b){let x=Math.floor(b/s),v=b%s;for(let I=0;I<d;++I){let N=Math.floor(I/s),C=I%s,E=(v*s+C)*c;for(let A=0;A<c;++A){let F=A+E+u*(N+p*(x+l*y));m[g++]=f[F]}}}return n.makeTensorInfo([o,h,d,c],a.dtype,m)}var KH={kernelName:Ho,backendName:"cpu",kernelFunc:qH};function lN(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:p}=r;ye([a,s],"depthwiseConv2DNative");let u=w.computeStrides(a.shape),h=w.computeStrides(s.shape),d=l;d==null&&(d=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=T.computeConv2DInfo(a.shape,s.shape,i,d,o,p,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.left,v=b.top,I=c.outChannels/c.inChannels,N=new Mt(c.outShape,a.dtype),C=n.data.get(a.dataId).values,E=n.data.get(s.dataId).values,A=N.values;for(let F=0;F<c.batchSize;++F){let R=F*u[0],S=F*N.strides[0];for(let M=0;M<c.outHeight;++M){let B=S+M*N.strides[1],U=M*c.strideHeight-v;for(let G=0;G<f;++G){let K=U+G*g;if(K<0||K>=c.inHeight)continue;let H=G*h[0],X=R+K*u[1];for(let ee=0;ee<c.outWidth;++ee){let Z=B+ee*N.strides[2],re=ee*c.strideWidth-x;for(let te=0;te<m;++te){let ae=re+te*y;if(ae<0||ae>=c.inWidth)continue;let ie=H+te*h[1],we=X+ae*c.inChannels,be=Z,pe=ie;for(let Ie=0;Ie<c.inChannels;++Ie){let Te=C[we+Ie];for(let De=0;De<I;++De)A[be+De]+=Te*E[pe+De];be+=I,pe+=I}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var XH={kernelName:Ys,backendName:"cpu",kernelFunc:lN};function ZH(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,filterShape:u}=r;ye([a,s],"depthwiseConv2dNativeBackpropFilter");let h=T.computeConv2DInfo(a.shape,u,i,o,l,p,!0),{strideHeight:d,strideWidth:c,filterHeight:f,filterWidth:m}=h,g=new Mt(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(a.dataId).values,I=new Mt(a.shape,a.dtype,v),N=n.data.get(s.dataId).values,C=new Mt(s.shape,s.dtype,N);for(let E=0;E<f;++E){let A=Math.max(0,Math.ceil((b-E)/d)),F=Math.min(h.outHeight,(h.inHeight+b-E)/d);for(let R=0;R<m;++R){let S=Math.max(0,Math.ceil((y-R)/c)),M=Math.min(h.outWidth,(h.inWidth+y-R)/c);for(let B=0;B<h.outChannels;++B){let U=Math.trunc(B/x),G=B%x,K=0;for(let H=0;H<h.batchSize;++H)for(let X=A;X<F;++X){let ee=E+X*d-b;for(let Z=S;Z<M;++Z){let re=R+Z*c-y;K+=I.get(H,ee,re,U)*C.get(H,X,Z,B)}}g.set(K,E,R,U,G)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var JH={kernelName:Ad,backendName:"cpu",kernelFunc:ZH};function YH(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,inputShape:u}=r;ye([a,s],"depthwiseConv2DNativeBackpropInput");let h=w.computeStrides(a.shape),d=w.computeStrides(s.shape),c=T.computeConv2DInfo(u,s.shape,i,o,l,p,!0),f=new Mt(c.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(a.dataId).values,[v,I,N]=h,C=n.data.get(s.dataId).values,[E,A,F]=d,{batchSize:R,filterHeight:S,filterWidth:M,inChannels:B,inHeight:U,inWidth:G,outChannels:K,outHeight:H,outWidth:X,strideHeight:ee,strideWidth:Z}=c,re=S-1-c.padInfo.top,te=M-1-c.padInfo.left,ae=K/B;for(let ie=0;ie<R;++ie)for(let we=0;we<B;++we)for(let be=0;be<U;++be){let pe=be-re,Ie=Math.max(0,Math.ceil(pe/ee)),Te=Math.min(H,(S+pe)/ee);for(let De=0;De<G;++De){let Be=De-te,et=Math.max(0,Math.ceil(Be/Z)),Ge=Math.min(X,(M+Be)/Z),je=0;for(let $e=Ie;$e<Te;++$e){let Ze=$e*ee-pe;for(let st=et;st<Ge;++st){let Fn=st*Z-Be,kt=v*ie+I*$e+N*st,In=E*(S-1-Ze)+A*(M-1-Fn)+F*we;for(let qt=0;qt<ae;++qt){let Sn=we*ae+qt,sr=x[kt+Sn],Dn=C[In+qt];je+=sr*Dn}}}m[g*ie+y*be+b*De+we]=je}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var QH={kernelName:Rd,backendName:"cpu",kernelFunc:YH};function e6(e){let{inputs:t,backend:n}=e,{x:r}=t,a=w.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=ze([a,a],r.dtype),o=i.values;for(let p=0;p<s.length;p++)o[p*a+p]=s[p];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var t6={kernelName:Fd,backendName:"cpu",kernelFunc:e6},n6={kernelName:Zu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,p=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:c,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:I,filterHeight:N,filterWidth:C,dilationHeight:E,dilationWidth:A,outShape:F}=T.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),R=w.sizeFromShape(F),S=F.length,M=w.getArrayFromDType(r.dtype,R);for(let B=0;B<c;++B)for(let U=0;U<y;++U){let G=U*v-x.top;for(let K=0;K<b;++K){let H=K*I-x.left;for(let X=0;X<g;++X){let ee=Number.MIN_SAFE_INTEGER;for(let re=0;re<N;++re){let te=G+re*E;if(te>=0&&te<f)for(let ae=0;ae<C;++ae){let ie=H+ae*A;if(ie>=0&&ie<m){let we=w.locToIndex([B,te,ie,X],u,w.computeStrides(r.shape)),be=w.locToIndex([re,ae,X],d,w.computeStrides(a.shape)),pe=p[we]+h[be];pe>ee&&(ee=pe)}}}let Z=w.locToIndex([B,U,K,X],S,w.computeStrides(F));M[Z]=ee}}}return{dataId:l.write(w.toTypedArray(M,r.dtype),F,r.dtype),shape:F,dtype:r.dtype}}},r6={kernelName:Ph,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,p=t,u=w.toNestedArray(r.shape,p.data.get(r.dataId).values),h=w.toNestedArray(a.shape,p.data.get(a.dataId).values),{batchSize:d,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:E,outShape:A}=T.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${Ph}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let F=w.toNestedArray(A,p.data.get(s.dataId).values),R=w.makeZerosNestedTypedArray(a.shape,a.dtype);for(let S=0;S<d;++S)for(let M=0;M<g;++M){let B=M*x-b.top;for(let U=0;U<y;++U){let G=U*v-b.left;for(let K=0;K<m;++K){let H=Number.MIN_SAFE_INTEGER,X=0,ee=0;for(let Z=0;Z<I;++Z){let re=B+Z*C;if(re>=0&&re<c)for(let te=0;te<N;++te){let ae=G+te*E;if(ae>=0&&ae<f){let ie=u[S][re][ae][K]+h[Z][te][K];ie>H&&(H=ie,X=Z,ee=te)}}}R[X][ee][K]+=F[S][M][U][K]}}}return{dataId:p.write(w.toTypedArray(R,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},a6={kernelName:zh,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,p=t,u=w.toNestedArray(r.shape,p.data.get(r.dataId).values),h=w.toNestedArray(a.shape,p.data.get(a.dataId).values),{batchSize:d,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:E,outShape:A}=T.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${zh}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let F=w.toNestedArray(A,p.data.get(s.dataId).values),R=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<d;++S)for(let M=0;M<g;++M){let B=M*x-b.top;for(let U=0;U<y;++U){let G=U*v-b.left;for(let K=0;K<m;++K){let H=Number.MIN_SAFE_INTEGER,X=B<0?0:B,ee=G<0?0:G;for(let Z=0;Z<I;++Z){let re=B+Z*C;if(re>=0&&re<c)for(let te=0;te<N;++te){let ae=G+te*E;if(ae>=0&&ae<f){let ie=u[S][re][ae][K]+h[Z][te][K];ie>H&&(H=ie,X=re,ee=ae)}}}R[S][X][ee][K]+=F[S][M][U][K]}}}return{dataId:p.write(w.toTypedArray(R,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Pp(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"sum");let o;a.dtype==="bool"?o=Ba({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):o=Gr({inputs:{x:a},backend:n});let l=o.shape.length,p=w.parseAxisParam(s,o.shape),u=T.getAxesPermutation(p,l),h=p,d=o;u!=null&&(d=An({inputs:{x:o},backend:n,attrs:{perm:u}}),h=T.getInnerMostAxes(h.length,l)),T.assertAxesAreInnerMostDims("sum",h,d.shape.length);let[c,f]=T.computeOutAndReduceShapes(d.shape,h),m=T.upcastType(d.dtype,"int32"),g=ad(n,c,m),y=w.sizeFromShape(f),b=n.data.get(g.dataId).values,x=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){let I=v*y,N=0;for(let C=0;C<y;++C)N+=x[I+C];b[v]=N}if(i){let v=T.expandShapeToKeepDim(g.shape,p),I=g;g=ut({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),u!=null&&n.disposeIntermediateTensorInfo(d),g}var s6={kernelName:Di,backendName:"cpu",kernelFunc:Pp};function i6(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(a,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:p,steps:u}=T.getEinsumComputePath(o,l),h=u.length,d=null,c=i.length,f=[];for(let m=0;m<h;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=T.getEinsumPermutation(c,l[g]),x;T.isIdentityPermutation(y)?x=s[g]:(x=An({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=ut({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),d===null?d=x:(d=ef({inputs:{a:x,b:d},backend:n}),f.push(d))}m<h-1&&(p[m]>=0&&(d=Pp({inputs:{x:d},backend:n,attrs:{axis:p[m]-(i.length-c),keepDims:!1}}),f.push(d)),c--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var o6={kernelName:Dd,backendName:"cpu",kernelFunc:i6};function l6(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;ye([r,a],"eluGrad");let s=new Float32Array(w.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let p=i[l];p>=1?s[l]=o[l]:s[l]=o[l]*(p+1)}return n.makeTensorInfo(a.shape,"float32",s)}var u6={kernelName:Md,backendName:"cpu",kernelFunc:l6},p6=T.ERF_P,h6=T.ERF_A1,d6=T.ERF_A2,c6=T.ERF_A3,f6=T.ERF_A4,m6=T.ERF_A5,g6=Qe(jo,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+p6*n);return t*(1-((((m6*r+f6)*r+c6)*r+d6)*r+h6)*r*Math.exp(-n*n))}),y6={kernelName:jo,backendName:"cpu",kernelFunc:g6};function od(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),ut({inputs:{x:a},backend:n,attrs:{shape:o}})}var b6={kernelName:Ko,backendName:"cpu",kernelFunc:od},x6=At((e,t)=>e/t),lx=jt(Qs,x6),xm={kernelName:Qs,backendName:"cpu",kernelFunc:lx};function uN(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,p=[a,s],u=w.sizeFromShape(p),h=w.getTypedArrayFromDType("float32",u),d=w.getTypedArrayFromDType("float32",u);for(let g=0;g<a;g++){let y=Os({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),b=Os({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=zn({inputs:{real:y,imag:b},backend:n}),{real:v,imag:I}=w6(x,t,n),N=T.mergeRealAndImagArrays(v,I);for(let C=0;C<s;C++){let E=T.getComplexWithIndex(N,C);h[g*s+C]=E.real,d[g*s+C]=E.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}let c=n.makeTensorInfo(p,"float32",h),f=n.makeTensorInfo(p,"float32",d),m=zn({inputs:{real:c,imag:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}function w6(e,t,n){let r=w.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(v6(r)){let o=wm(s,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let p=n.makeTensorInfo(l,"float32",o.real),u=n.makeTensorInfo(l,"float32",o.imag),h=n.makeTensorInfo([],"float32",w.createScalarValue(r,"float32")),d=Gr({inputs:{x:h},backend:n}),c=xm.kernelFunc({inputs:{a:p,b:h},backend:n}),f=xm.kernelFunc({inputs:{a:u,b:d},backend:n}),m=n.data.get(c.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=T.mergeRealAndImagArrays(s,i),l=k6(o,r,t);return T.splitRealAndImagArrays(l)}}function v6(e){return(e&e-1)===0}function wm(e,t,n,r,a){if(n===1)return{real:e,imag:t};let s=T.mergeRealAndImagArrays(e,t),i=n/2,o=T.complexWithEvenIndex(s),l=o.real,p=o.imag,u=[l.length],h=a.makeTensorInfo(u,"float32",l),d=a.makeTensorInfo(u,"float32",p),c=zn({inputs:{real:h,imag:d},backend:a}),f=T.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),x=a.makeTensorInfo(y,"float32",g),v=zn({inputs:{real:b,imag:x},backend:a}),I=wm(l,p,i,r,a),N=I.real,C=I.imag,E=[N.length],A=a.makeTensorInfo(E,"float32",N),F=a.makeTensorInfo(E,"float32",C),R=zn({inputs:{real:A,imag:F},backend:a}),S=wm(m,g,i,r,a),M=S.real,B=S.imag,U=[M.length],G=a.makeTensorInfo(U,"float32",M),K=a.makeTensorInfo(U,"float32",B),H=zn({inputs:{real:G,imag:K},backend:a}),X=T.exponents(n,r),ee=[X.real.length],Z=a.makeTensorInfo(ee,"float32",X.real),re=a.makeTensorInfo(ee,"float32",X.imag),te=zn({inputs:{real:Z,imag:re},backend:a}),ae=ef({inputs:{a:te,b:H},backend:a}),ie=No({inputs:{a:R,b:ae},backend:a}),we=ix({inputs:{a:R,b:ae},backend:a}),be=Ms({inputs:{input:ie},backend:a}),pe=Ms({inputs:{input:we},backend:a}),Ie=To({inputs:{input:ie},backend:a}),Te=To({inputs:{input:we},backend:a}),De=Co({inputs:[be,pe],backend:a,attrs:{axis:0}}),Be=Co({inputs:[Ie,Te],backend:a,attrs:{axis:0}}),et=a.data.get(De.dataId).values,Ge=a.data.get(Be.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(Z),a.disposeIntermediateTensorInfo(re),a.disposeIntermediateTensorInfo(te),a.disposeIntermediateTensorInfo(ae),a.disposeIntermediateTensorInfo(ie),a.disposeIntermediateTensorInfo(we),a.disposeIntermediateTensorInfo(be),a.disposeIntermediateTensorInfo(Ie),a.disposeIntermediateTensorInfo(pe),a.disposeIntermediateTensorInfo(Te),a.disposeIntermediateTensorInfo(De),a.disposeIntermediateTensorInfo(Be),{real:et,imag:Ge}}function k6(e,t,n){let r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,i=0;for(let o=0;o<t;o++){let l=T.exponent(a*o,t,n),p=T.getComplexWithIndex(e,o);s+=p.real*l.real-p.imag*l.imag,i+=p.real*l.imag+p.imag*l.real}n&&(s/=t,i/=t),T.assignToTypedArray(r,s,i,a)}return r}function I6(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=ut({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=uN(o,!1,n),p=ut({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),p}var S6={kernelName:Od,backendName:"cpu",kernelFunc:I6};function ux(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||w.inferDtype(a),o=w.getArrayFromDType(i,w.sizeFromShape(r));return T6(o,a),t.makeTensorInfo(r,i,o)}var N6={kernelName:Ju,backendName:"cpu",kernelFunc:ux};function T6(e,t,n){e.fill(t)}var C6={kernelName:Zo,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[i,o,l,p]=r.shape,u=a.data.get(r.dataId).values;for(let h=0;h<i;h++){let d=h*l*o*p;for(let c=0;c<o;c++){let f=c*(l*p);for(let m=0;m<l;m++){let g=m*p;for(let y=0;y<p;y++){let b=Math.round(l-m-1),x=d+f+g+y,v=u[x];if(b>=0&&b<l){let I=b*p,N=d+f+I+y;v=u[N]}s[x]=v}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_6=At((e,t)=>Math.floor(e/t)),E6=jt(ri,_6,null,"int32"),$6={kernelName:ri,backendName:"cpu",kernelFunc:E6};function A6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=r,m=oN({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:p,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let g=m;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=ut({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=No({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=No({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(c){let g=m;if(u==="NCHW"&&c==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=ut({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=id(n,m,c,y,f),n.disposeIntermediateTensorInfo(y)}else m=id(n,m,c,o,f);n.disposeIntermediateTensorInfo(g)}return m}var R6={kernelName:Is,backendName:"cpu",kernelFunc:A6};function F6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=r,m=lN({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:p,dataFormat:u,dilations:h,dimRoundingMode:d}});if(i){let g=m;m=No({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(c){let g=m;m=id(n,m,c,o,f),n.disposeIntermediateTensorInfo(g)}return m}var D6={kernelName:Ss,backendName:"cpu",kernelFunc:F6};function M6(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=w.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,p,u,h]=T.prepareAndValidate(r,a);if(p===0)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(a.dataId).values,c=n.bufferSync(r),f=NS(d,c,r.dtype,p,o,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var O6={kernelName:Yo,backendName:"cpu",kernelFunc:M6};function L6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;ye([a,s],"gatherV2");let l=w.parseAxisParam(i,a.shape)[0],p=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<p.length;++v){let I=p[v];w.assert(I<=u-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${u-1}]`)}let h=o;o==null&&(h=0);let d=w.sizeFromShape(s.shape),c=T.segment_util.collectGatherOpShapeInfo(a,s,l,h),f=ut({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=ut({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,d/c.batchSize]}}),g=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=TS(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}var z6={kernelName:Jo,backendName:"cpu",kernelFunc:L6};function P6(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=ut({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=uN(o,!0,n),p=ut({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),p}var B6={kernelName:Ld,backendName:"cpu",kernelFunc:P6},W6=Qe(el,e=>Number.isFinite(e)?1:0,"bool"),V6={kernelName:el,backendName:"cpu",kernelFunc:W6},U6=Qe(tl,e=>Math.abs(e)===1/0?1:0,"bool"),G6={kernelName:tl,backendName:"cpu",kernelFunc:U6},H6=Qe(oi,e=>Number.isNaN(e)?1:0,"bool"),j6={kernelName:oi,backendName:"cpu",kernelFunc:H6};function q6(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=AS(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var K6={kernelName:Pd,backendName:"cpu",kernelFunc:q6},X6=Qe(al,e=>Math.log1p(e)),Z6={kernelName:al,backendName:"cpu",kernelFunc:X6},J6=At((e,t)=>e&&t),Y6=jt(sl,J6,null,"bool"),Q6={kernelName:sl,backendName:"cpu",kernelFunc:Y6},ej=Qe(il,e=>e?0:1,"bool"),tj={kernelName:il,backendName:"cpu",kernelFunc:ej},nj=At((e,t)=>e||t),rj=jt(ol,nj,null,"bool"),aj={kernelName:ol,backendName:"cpu",kernelFunc:rj};function sj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;ye(a,"LRN");let p=a.shape[3],u=p-1,h=n.data.get(a.dataId).values,d=w.sizeFromShape(a.shape),c=new Float32Array(d);function f(m){let g=m%p,y=m-g+Math.max(0,g-s),b=m-g+Math.min(g+s,u),x=0;for(;y<=b;y++){let v=h[y];x+=v*v}return x}for(let m=0;m<d;m++){let g=f(m),y=h[m]*Math.pow(i+o*g,-l);c[m]=y}return n.makeTensorInfo(a.shape,a.dtype,c)}var ij={kernelName:Yu,backendName:"cpu",kernelFunc:sj};function oj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:p,beta:u}=r;ye(i,"LRNGrad");let h=w.sizeFromShape(i.shape),d=i.shape[3],c=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){let x=b%d,v=b-x+Math.max(0,x-o),I=b-x+Math.min(d,x+o+1),N=0;for(let C=v;C<I;C++)N+=Math.pow(f[C],2);N=p*N+l;for(let C=v;C<I;C++){let E=-2*p*u*f[C]*m[b]/N;b===C&&(E+=Math.pow(N,-u)),E*=c[b],g[C]+=E}}return n.makeTensorInfo(i.shape,a.dtype,g)}var lj={kernelName:Bd,backendName:"cpu",kernelFunc:oj};function pN(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,p=l.length,u=w.parseAxisParam(s,l),h=u,d=T.getAxesPermutation(h,p),c=o.data.get(a.dataId).values;if(d!=null){let v=new Array(p);for(let I=0;I<v.length;I++)v[I]=l[d[I]];c=ex(c,l,a.dtype,d,v),h=T.getInnerMostAxes(h.length,p),l=v}ye(a,"max"),T.assertAxesAreInnerMostDims("max",h,p);let[f,m]=T.computeOutAndReduceShapes(l,h),g=w.sizeFromShape(m),y=FS(c,g,f,a.dtype),b=o.write(y,f,a.dtype),x=f;return i&&(x=T.expandShapeToKeepDim(f,u)),{dataId:b,shape:x,dtype:a.dtype}}var uj={kernelName:pi,backendName:"cpu",kernelFunc:pN};function pj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ye(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=T.computePool2DInfo(a.shape,s,i,p,o,l),h;if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))h=Gr({inputs:{x:a},backend:n});else{let d=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),f=ox(d,a.shape,a.dtype,c,u,"max");h=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return h}var hj={kernelName:di,backendName:"cpu",kernelFunc:pj};function dj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r;ye(a,"maxPool3d");let u=T.computePool3DInfo(a.shape,s,i,1,o,l,p),h=n.data.get(a.dataId).values,d=iN(h,a.shape,a.dtype,w.computeStrides(a.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var cj={kernelName:Qu,backendName:"cpu",kernelFunc:dj};function fj(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r;ye([a,s],"maxPool3DGrad");let u=T.computePool3DInfo(s.shape,i,o,1,l,p),h=n.bufferSync(s),d=tH(h,u),c=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,v=u.effectiveFilterHeight,I=u.effectiveFilterWidth,N=x-1-u.padInfo.front,C=I-1-u.padInfo.left,E=v-1-u.padInfo.top,A=ze(s.shape,"float32"),F=n.bufferSync(a);for(let R=0;R<u.batchSize;++R)for(let S=0;S<u.inChannels;++S)for(let M=0;M<u.inDepth;++M)for(let B=0;B<u.inHeight;++B)for(let U=0;U<u.inWidth;++U){let G=M-N,K=B-E,H=U-C,X=0;for(let ee=0;ee<x;ee+=g){let Z=(G+ee)/c;if(!(Z<0||Z>=u.outDepth||Math.floor(Z)!==Z))for(let re=0;re<v;re+=y){let te=(K+re)/f;if(!(te<0||te>=u.outHeight||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let ie=(H+ae)/m;if(ie<0||ie>=u.outWidth||Math.floor(ie)!==ie)continue;let we=x*v*I-1-d.get(R,Z,te,ie,S),be=ee*v*I+re*I+ae,pe=we===be?1:0;if(pe===0)continue;let Ie=F.get(R,Z,te,ie,S);X+=Ie*pe}}}A.set(X,R,M,B,U,S)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var mj={kernelName:Vd,backendName:"cpu",kernelFunc:fj};function gj(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;ye([s,i],"maxPoolGrad");let{filterSize:l,strides:p,pad:u,dimRoundingMode:h}=r,d=T.computePool2DInfo(o.shape,l,p,1,u,h),c=n.data.get(o.dataId).values,f=ze(d.outShape,o.dtype,sN(c,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,I=v-1-d.padInfo.left,N=x-1-d.padInfo.top,C=ze(o.shape,"float32"),E=n.data.get(a.dataId).values,A=ze(a.shape,"float32",E);for(let F=0;F<d.batchSize;++F)for(let R=0;R<d.inChannels;++R)for(let S=0;S<d.inHeight;++S)for(let M=0;M<d.inWidth;++M){let B=S-N,U=M-I,G=0;for(let K=0;K<x;K+=y){let H=(B+K)/m;if(!(H<0||H>=d.outHeight||Math.floor(H)!==H))for(let X=0;X<v;X+=b){let ee=(U+X)/g;if(ee<0||ee>=d.outWidth||Math.floor(ee)!==ee)continue;let Z=x*v-1-f.get(F,H,ee,R),re=K*v+X,te=Z===re?1:0;if(te===0)continue;let ae=A.get(F,H,ee,R);G+=ae*te}}C.set(G,F,S,M,R)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var yj={kernelName:Wd,backendName:"cpu",kernelFunc:gj};function bj(e,t,n,r,a){let s=w.computeStrides(t),i=ox(e,t,n,s,a,"max"),o=sN(e,t,n,a,!0,r);return[i.values,o.values]}var xj={kernelName:Ud,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ye(r,"MaxPoolWithArgmax");let p=l.data.get(r.dataId).values,u=T.computePool2DInfo(r.shape,a,s,[1,1],i),[h,d]=bj(p,r.shape,r.dtype,o,u),c=l.write(h,u.outShape,r.dtype),f=l.write(d,u.outShape,r.dtype);return[{dataId:c,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function wj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=w.parseAxisParam(s,a.shape),l=T.computeOutAndReduceShapes(a.shape,o)[1],p=w.sizeFromShape(l),u=[],h=n.makeTensorInfo([],"float32",new Float32Array([p]));u.push(h);let d=Ba({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(d);let c=lx({inputs:{a:d,b:h},backend:n});u.push(c);let f=Pp({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var vj={kernelName:ci,backendName:"cpu",kernelFunc:wj};function kj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"min");let o=w.parseAxisParam(s,a.shape),l=o,p=T.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=An({inputs:{x:a},backend:n,attrs:{perm:p}}),l=T.getInnerMostAxes(l.length,a.shape.length)),T.assertAxesAreInnerMostDims("min",l,u.shape.length);let[h,d]=T.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(d),f=w.makeZerosTypedArray(w.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];(Number.isNaN(I)||I<x)&&(x=I)}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(h,u.dtype,f);if(i){let y=T.expandShapeToKeepDim(h,o),b=ut({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var Ij={kernelName:fi,backendName:"cpu",kernelFunc:kj};function Sj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;ye(a,"mirrorPad");let o=s.map((b,x)=>b[0]+a.shape[x]+b[1]),l=s.map(b=>b[0]),p=s.map((b,x)=>b[0]+a.shape[x]),u=i==="reflect"?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,c=w.computeStrides(a.shape),f=w.sizeFromShape(o),m=o.length,g=w.computeStrides(o),y=w.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let x=w.indexToLoc(b,m,g);for(let I=0;I<m;I++)x[I]<l[I]?x[I]=l[I]*2-x[I]-u:x[I]>=p[I]&&(x[I]=(p[I]-1)*2-x[I]+u);x=x.map((I,N)=>I-l[N]);let v=w.locToIndex(x,d,c);y[b]=h[v]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var Nj={kernelName:gi,backendName:"cpu",kernelFunc:Sj},Tj=At((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Cj=jt(ll,Tj),_j={kernelName:ll,backendName:"cpu",kernelFunc:Cj},Ej=Ua(yd());function hN(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=w.parseAxisParam([o],a.shape),p=pN({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=T.expandShapeToKeepDim(p.shape,l),h=ut({inputs:{x:p},backend:n,attrs:{shape:u}}),d=ix({inputs:{a,b:h},backend:n}),c=kS({inputs:{x:d},backend:n}),f=Pp({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),m=ut({inputs:{x:f},backend:n,attrs:{shape:u}}),g=lx({inputs:{a:c,b:m},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var $j={kernelName:Mi,backendName:"cpu",kernelFunc:hN};function Aj(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;ye(a,"multinomial");let l=o?a:hN({inputs:{logits:a},backend:n,attrs:{dim:-1}}),p=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[p,s],c=w.makeZerosTypedArray(w.sizeFromShape(d),"int32");for(let f=0;f<p;++f){let m=f*u,g=new Float32Array(u-1);g[0]=h[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[m+x];let y=Ej.alea(i.toString()),b=f*s;for(let x=0;x<s;++x){let v=y();c[b+x]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){c[b+x]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",c)}var Rj={kernelName:Gd,backendName:"cpu",kernelFunc:Aj},Fj=qr.nonMaxSuppressionV3Impl;function Dj(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;ye(a,"NonMaxSuppression");let p=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=Fj(p,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var Mj={kernelName:hl,backendName:"cpu",kernelFunc:Dj},Oj=qr.nonMaxSuppressionV4Impl;function Lj(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r;ye(a,"NonMaxSuppressionPadded");let u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:c}=Oj(u,h,i,o,l,p);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var zj={kernelName:dl,backendName:"cpu",kernelFunc:Lj},Pj=qr.nonMaxSuppressionV5Impl;function Bj(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r;ye(a,"NonMaxSuppressionWithScore");let u=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=i,c=o,f=l,m=p,{selectedIndices:g,selectedScores:y}=Pj(u,h,d,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Wj={kernelName:cl,backendName:"cpu",kernelFunc:Bj};function Vj(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;ye(a,"oneHot");let p=w.sizeFromShape(a.shape),u=new Float32Array(p*i);u.fill(l);let h=n.data.get(a.dataId).values;for(let d=0;d<p;++d)h[d]>=0&&h[d]<i&&(u[d*i+h[d]]=o);return n.makeTensorInfo([...a.shape,i],s,u)}var Uj={kernelName:bi,backendName:"cpu",kernelFunc:Vj};function ld(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Ms({inputs:{input:r},backend:n}),s=ld({inputs:{x:a},backend:n}),i=To({inputs:{input:r},backend:n}),o=ld({inputs:{x:i},backend:n}),l=zn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return ux({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Gj={kernelName:Al,backendName:"cpu",kernelFunc:ld};function dN(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Ms({inputs:{input:r},backend:n}),s=dN({inputs:{x:a},backend:n}),i=To({inputs:{input:r},backend:n}),o=ld({inputs:{x:i},backend:n}),l=zn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return ux({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Hj={kernelName:fl,backendName:"cpu",kernelFunc:dN};function cN(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return od({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=od({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),p=Co({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),p}var jj={kernelName:ml,backendName:"cpu",kernelFunc:cN};function qj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;ye(a,"pad");let o=s.map((y,b)=>y[0]+a.shape[b]+y[1]),l=s.map(y=>y[0]),p=n.data.get(a.dataId).values,u=w.sizeFromShape(a.shape),h=a.shape.length,d=w.computeStrides(a.shape),c=w.sizeFromShape(o),f=o.length,m=w.computeStrides(o),g=w.getTypedArrayFromDType(a.dtype,c);i!==0&&g.fill(i);for(let y=0;y<u;y++){let b=w.indexToLoc(y,h,d).map((v,I)=>v+l[I]),x=w.locToIndex(b,f,m);g[x]=p[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var fN={kernelName:xi,backendName:"cpu",kernelFunc:qj},Kj=At((e,t)=>Math.pow(e,t)),Xj=jt(wi,Kj),Zj={kernelName:wi,backendName:"cpu",kernelFunc:Xj};function Jj(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,o=a.map(g=>n.data.get(g.dataId).values),l=a.map(g=>g.shape),p=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,[h,d,c]=PS(o,l,p,s.shape,s.dtype,u,i.shape),f=h.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(c,s.dtype,d);return f.concat([m])}var Yj={kernelName:Hd,backendName:"cpu",kernelFunc:Jj};function Qj(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=BS(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([p.length],"int32",p),d=n.makeTensorInfo([u.length],r.dtype,u);return[h,d]}var e5={kernelName:jd,backendName:"cpu",kernelFunc:Qj};function t5(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=o.map(g=>n.data.get(g.dataId).values),c=o.map(g=>g.shape),[f,m]=WS(p,a.shape,u,s.shape,s.dtype,h,i.shape,d,c,l);return n.makeTensorInfo(f,s.dtype,m)}var n5={kernelName:qd,backendName:"cpu",kernelFunc:t5};function r5(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=tx(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var a5={kernelName:ep,backendName:"cpu",kernelFunc:r5},s5=Qe(Ii,e=>1/e),i5={kernelName:Ii,backendName:"cpu",kernelFunc:s5};function o5(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ye(a,"resizeBilinear");let l=w.computeStrides(a.shape),[p,u]=o,[h,d,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(w.sizeFromShape([h,p,u,f])),y=[s&&p>1?d-1:d,s&&u>1?c-1:c],b=[s&&p>1?p-1:p,s&&u>1?u-1:u],x=0,v=y[0]/b[0],I=y[1]/b[1];for(let N=0;N<h;N++)for(let C=0;C<p;C++){let E;i?E=v*(C+.5)-.5:E=v*C;let A=Math.max(0,Math.floor(E)),F=E-A,R=Math.min(d-1,Math.ceil(E)),S=N*l[0]+A*l[1],M=N*l[0]+R*l[1];for(let B=0;B<u;B++){let U;i?U=I*(B+.5)-.5:U=I*B;let G=Math.max(0,Math.floor(U)),K=U-G,H=Math.min(c-1,Math.ceil(U)),X=S+G*l[2],ee=M+G*l[2],Z=S+H*l[2],re=M+H*l[2];for(let te=0;te<f;te++){let ae=m[X+te],ie=m[ee+te],we=m[Z+te],be=m[re+te],pe=ae+(we-ae)*K,Ie=ie+(be-ie)*K,Te=pe+(Ie-pe)*F;g[x++]=Te}}}return n.makeTensorInfo([h,p,u,f],"float32",g)}var l5={kernelName:Ti,backendName:"cpu",kernelFunc:o5};function u5(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ye([s,a],"resizeBilinearGrad");let o=w.computeStrides(a.shape),[l,p,u,h]=a.shape,[,d,c]=s.shape,f=new Float32Array(l*p*u*h),m=[i&&d>1?p-1:p,i&&c>1?u-1:u],g=[i&&d>1?d-1:d,i&&c>1?c-1:c],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let I=0;I<l;I++){let N=I*o[0];for(let C=0;C<d;C++){let E=C*y,A=Math.floor(E),F=Math.min(Math.ceil(E),p-1),R=N+A*o[1],S=N+F*o[1],M=E-A,B=1-M;for(let U=0;U<c;U++){let G=U*b,K=Math.floor(G),H=Math.min(Math.ceil(G),u-1),X=G-K,ee=1-X,Z=R+K*o[2],re=R+H*o[2],te=S+K*o[2],ae=S+H*o[2],ie=B*ee,we=B*X,be=M*ee,pe=M*X;for(let Ie=0;Ie<h;Ie++){let Te=x[v++];f[Z+Ie]+=Te*ie,f[re+Ie]+=Te*we,f[te+Ie]+=Te*be,f[ae+Ie]+=Te*pe}}}}return n.makeTensorInfo([l,u,p,h],"float32",f)}var p5={kernelName:Zd,backendName:"cpu",kernelFunc:u5};function h5(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ye(a,"resizeNearestNeighbor");let l=w.computeStrides(a.shape),[p,u]=o,[h,d,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(h*p*u*f),y=[s&&p>1?d-1:d,s&&u>1?c-1:c],b=[s&&p>1?p-1:p,s&&u>1?u-1:u],x=y[0]/b[0],v=y[1]/b[1],I=0;for(let N=0;N<h;N++){let C=N*l[0];for(let E=0;E<p;E++){let A=i?x*(E+.5):x*E,F=Math.min(d-1,s?Math.round(A):Math.floor(A));i&&(F=Math.max(0,F));let R=C+F*l[1];for(let S=0;S<u;S++){let M=i?v*(S+.5):v*S,B=Math.min(c-1,s?Math.round(M):Math.floor(M));i&&(B=Math.max(0,B));let U=R+B*l[2];for(let G=0;G<f;G++){let K=m[U+G];g[I++]=K}}}}return n.makeTensorInfo([h,p,u,f],a.dtype,g)}var d5={kernelName:Ni,backendName:"cpu",kernelFunc:h5};function c5(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ye([s,a],"resizeNearestNeighborGrad");let o=w.computeStrides(a.shape),l=w.computeStrides(s.shape),[p,u,h,d]=a.shape,[,c,f]=s.shape,m=new Float32Array(p*u*h*d),g=n.data.get(s.dataId).values,y=[i&&c>1?u-1:u,i&&f>1?h-1:h],b=[i&&c>1?c-1:c,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],I=1/x,N=1/v,C=Math.ceil(I)*2+2,E=Math.ceil(N)*2+2;for(let A=0;A<p;A++){let F=A*o[0];for(let R=0;R<u;R++){let S=F+R*o[1],M=Math.floor(R*I),B=Math.floor(M-C/2);for(let U=0;U<h;U++){let G=S+U*o[2],K=Math.floor(U*N),H=Math.floor(K-E/2);for(let X=0;X<d;X++){let ee=0;for(let Z=0;Z<C;Z++){let re=Z+B;if(re<0||re>=c)continue;let te=F+re*l[1],ae=re*x,ie=Math.min(u-1,i?Math.round(ae):Math.floor(ae));if(R===ie)for(let we=0;we<E;we++){let be=we+H;if(be<0||be>=f)continue;let pe=te+be*l[2],Ie=be*v,Te=Math.min(h-1,i?Math.round(Ie):Math.floor(Ie));U===Te&&(ee+=g[pe+X])}}m[G+X]=ee}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var f5={kernelName:Xd,backendName:"cpu",kernelFunc:c5};function m5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;ye(a,"reverse");let i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return Gr({inputs:{x:a},backend:n});let l=new Mt(a.shape,a.dtype),p=n.bufferSync(a);for(let u=0;u<l.size;u++){let h=l.indexToLoc(u),d=h.slice();o.forEach(c=>d[c]=a.shape[c]-1-d[c]),l.set(p.get(...d),...h)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var g5={kernelName:_i,backendName:"cpu",kernelFunc:m5},y5={kernelName:Rl,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[p,u,h,d]=r.shape,[c,f]=T.getImageCenter(i,u,h),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let x=0;x<p;x++){let v=x*h*u*d;for(let I=0;I<u;I++){let N=I*(h*d);for(let C=0;C<h;C++){let E=C*d;for(let A=0;A<d;A++){let F=[p,I,C,A],R=F[2],S=F[1],M=(R-c)*y-(S-f)*g,B=(R-c)*g+(S-f)*y;M=Math.round(M+c),B=Math.round(B+f);let U=s;if(typeof s!="number"&&(A===3?U=m:U=s[A]),M>=0&&M<h&&B>=0&&B<u){let K=B*(h*d),H=M*d,X=v+K+H+A;U=b[X]}let G=v+N+E+A;l[G]=U}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},b5=Qe(Ei,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),x5={kernelName:Ei,backendName:"cpu",kernelFunc:b5};function w5(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:u,outputSize:h}=T.calculateShapes(s,a,i),d=!0,c=n.bufferSync(a),f=n.bufferSync(s),m=so(c,f,i,h,p,l,o,u,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}var v5={kernelName:yl,backendName:"cpu",kernelFunc:w5};function k5(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function I5(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function S5(e,t,n,r,a,s){let i=w.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),p=o*a;for(let u=0;u<a;++u)i[p+u]=s==="left"?k5(l,t[u+p]):I5(l,t[u+p])}return i}function N5(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,p=S5(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",p)}var T5={kernelName:Jd,backendName:"cpu",kernelFunc:N5};function C5(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;ye([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=tr(a.dtype,s.dtype),h=w.makeZerosTypedArray(w.sizeFromShape(a.shape),u),d=0,c=i===0||i>1||a.shape.length===1?1:w.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<c;m++)o[f]===1?h[d++]=l[f]:h[d++]=p[f];return n.makeTensorInfo(a.shape,u,h)}var _5={kernelName:bl,backendName:"cpu",kernelFunc:C5},E5=T.SELU_SCALEALPHA,$5=T.SELU_SCALE,A5=Qe(xl,e=>e>=0?$5*e:E5*(Math.exp(e)-1)),R5={kernelName:xl,backendName:"cpu",kernelFunc:A5},F5=Qe(kl,e=>e<0?-1:e>0?1:0),D5={kernelName:kl,backendName:"cpu",kernelFunc:F5},M5=Qe(Ai,e=>Math.sin(e)),O5={kernelName:Ai,backendName:"cpu",kernelFunc:M5},L5=Qe(vl,e=>Math.sinh(e)),z5={kernelName:vl,backendName:"cpu",kernelFunc:L5},P5=11920928955078125e-23,pv=Math.log(P5)+2,B5=Qe(Il,e=>{let t=e>-pv,n=e<pv,r=Math.exp(e),a;return n?a=r:t?a=e:a=Math.log(1+r),a}),W5={kernelName:Il,backendName:"cpu",kernelFunc:B5};function V5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ye([a],"spaceToBatchND");let o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let p=fN.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=T.getReshaped(p.shape,s,o,!1),h=T.getPermuted(u.length,s.length,!1),d=T.getReshapedPermuted(p.shape,s,o,!1),c=ut({inputs:{x:p},backend:n,attrs:{shape:u}}),f=An({inputs:{x:c},backend:n,attrs:{perm:h}}),m=ut({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}var U5={kernelName:Sl,backendName:"cpu",kernelFunc:V5};function G5(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[h,d,c,f,m]=GS(o,r.shape,r.dtype,l,a.dtype,p,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var H5={kernelName:tp,backendName:"cpu",kernelFunc:G5};function j5(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[p,u,h]=HS(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,p),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var q5={kernelName:Tl,backendName:"cpu",kernelFunc:j5};function K5(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=nx(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,p)}var X5={kernelName:np,backendName:"cpu",kernelFunc:K5};function Z5(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=nx(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,p)}var J5={kernelName:rp,backendName:"cpu",kernelFunc:Z5};function Y5(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:u,strides:h,outputSize:d}=T.calculateShapes(s,a,o),c=!1,f=n.bufferSync(a),m;switch(s.dtype){case"bool":{let g=n.bufferSync(s),y=Boolean(n.data.get(i.dataId).values[0]);m=so(f,g,o,d,u,p,l,h,y,c);break}case"float32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=so(f,g,o,d,u,p,l,h,y,c);break}case"int32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=so(f,g,o,d,u,p,l,h,y,c);break}case"string":{let g=n.bufferSync(s),y=w.decodeString(n.data.get(i.dataId).values[0]);m=so(f,g,o,d,u,p,l,h,y,c);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var Q5={kernelName:Yd,backendName:"cpu",kernelFunc:Y5};function eq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),p=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let c=Os({inputs:{x:a},backend:n,attrs:{begin:p,size:d}});return p[o]+=h,c})}var tq={kernelName:Nl,backendName:"cpu",kernelFunc:eq},nq={kernelName:ap,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;ye(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let o=a[i];s[i]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},rq=Qe(Ka,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),aq={kernelName:Ka,backendName:"cpu",kernelFunc:rq};function sq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;ye(a,"stridedSlice");let{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,h,d),I;if(m)I=ut({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let N=Lt.computeOutShape(b,x,v),C=Os({inputs:{x:a},backend:n,attrs:{begin:b,size:N}});I=ut({inputs:{x:C},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(C)}else{let N=n.bufferSync(a),C=qS(c,N,v,b);I=n.makeTensorInfo(f,C.dtype,C.values)}return I}var iq={kernelName:Cl,backendName:"cpu",kernelFunc:sq};function oq(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,c=n.data.get(h.dataId).values,[f,m]=rx(d,c,a,s,i,o,l,p);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var lq={kernelName:sp,backendName:"cpu",kernelFunc:oq};function uq(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[p,u,h]=ax(o,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",p),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var pq={kernelName:ip,backendName:"cpu",kernelFunc:uq};function hq(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=sx(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var dq={kernelName:op,backendName:"cpu",kernelFunc:hq},cq=Qe(zi,e=>Math.tan(e)),fq={kernelName:zi,backendName:"cpu",kernelFunc:cq},mq=Qe(Pi,e=>Math.tanh(e)),gq={kernelName:Pi,backendName:"cpu",kernelFunc:mq};function yq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;ye(a,"tile");let i=XS(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var bq={kernelName:qa,backendName:"cpu",kernelFunc:yq};function xq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;ye(a,"topk");let o=n.data.get(a.dataId).values,[l,p]=JS(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(p.shape,p.dtype,p.values)]}var wq={kernelName:_l,backendName:"cpu",kernelFunc:xq};function vq(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=n,[u,h,d,c]=a.shape,[f,m]=p??[h,d],g=[u,f,m,c],y=w.computeStrides(a.shape),b=y[0],x=y[1],v=y[2],I=w.computeStrides(g),N=I[0],C=I[1],E=I[2],A=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(g));A.fill(l);let F=r.data.get(a.dataId).values,R=r.data.get(s.dataId).values;for(let S=0;S<u;++S){let M=s.shape[0]===1?R:R.subarray(S*8,S*8+8);for(let B=0;B<f;++B)for(let U=0;U<m;++U)for(let G=0;G<c;++G){let K,H=M[6]*U+M[7]*B+1;if(H===0)continue;let X=(M[0]*U+M[1]*B+M[2])/H,ee=(M[3]*U+M[4]*B+M[5])/H,Z=hv(X,d,o),re=hv(ee,h,o);switch(i){case"nearest":K=Cq(F,h,d,b,x,v,S,re,Z,G,l);break;case"bilinear":K=_q(F,h,d,b,x,v,S,re,Z,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let te=S*N+B*C+U*E+G;A[te]=K}return r.makeTensorInfo(g,a.dtype,A)}return{dataId:r.write(A,g,a.dtype),shape:a.shape,dtype:a.dtype}}var kq={kernelName:El,backendName:"cpu",kernelFunc:vq};function hv(e,t,n){switch(n){case"reflect":return Iq(e,t);case"wrap":return Sq(e,t);case"nearest":return Tq(e,t);case"constant":default:return Nq(e)}}function Iq(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return w.clamp(0,n,t-1)}function Sq(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return w.clamp(0,n,t-1)}function Nq(e,t){return e}function Tq(e,t){return w.clamp(0,e,t-1)}function gu(e,t,n,r,a,s,i,o,l,p,u){let h=i*r+o*a+l*s+p;return 0<=o&&o<t&&0<=l&&l<n?e[h]:u}function Cq(e,t,n,r,a,s,i,o,l,p,u){let h=Math.round(o),d=Math.round(l);return gu(e,t,n,r,a,s,i,h,d,p,u)}function _q(e,t,n,r,a,s,i,o,l,p,u){let h=Math.floor(o),d=Math.floor(l),c=h+1,f=d+1,m=(f-l)*gu(e,t,n,r,a,s,i,h,d,p,u)+(l-d)*gu(e,t,n,r,a,s,i,h,f,p,u),g=(f-l)*gu(e,t,n,r,a,s,i,c,d,p,u)+(l-d)*gu(e,t,n,r,a,s,i,c,f,p,u);return(c-o)*m+(o-h)*g}function Eq(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;ye(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:p}=YS(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}var $q={kernelName:Qd,backendName:"cpu",kernelFunc:Eq};function Aq(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),p=0;for(let c=0;c<i;c++)c!==s&&(l[p++]=a.shape[c]);let u=new Array(i).fill(0),h=a.shape.slice();h[s]=1;let d=new Array(o);for(let c=0;c<d.length;c++){u[s]=c;let f=Os({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});d[c]=ut({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return d}var Rq={kernelName:$l,backendName:"cpu",kernelFunc:Aq};function Fq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;ye(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,p=[],u=[],h=o-l,d=s;for(let f=0;f<h;++f){let m=od({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=m,u.push(m)}for(let f=0;f<i;++f){let m=w.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=wS({inputs:{a:g,b:d},backend:n}),b=Ba({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=ef({inputs:{a:b,b:a},backend:n}),v=Pp({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});p.push(v),u.push(g),u.push(y),u.push(b),u.push(x),u.push(v)}let c=cN({inputs:p,backend:n,attrs:{axis:0}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),c}var Dq={kernelName:lp,backendName:"cpu",kernelFunc:Fq},Mq=[EG,gU,AG,FG,kU,MG,LG,PG,WG,UG,HG,qG,XG,YG,eH,rH,sH,oH,uH,CG,hH,cH,mH,yH,wU,SU,xH,yU,vH,IH,SH,TH,_H,$H,RH,DH,OH,zH,BH,VH,GH,jH,KH,XH,JH,QH,t6,n6,r6,a6,o6,wG,u6,NU,y6,TU,b6,_U,S6,N6,C6,$U,$6,R6,D6,O6,z6,RU,DU,bU,B6,kH,V6,G6,j6,vG,OU,zU,K6,BU,Z6,Q6,tj,aj,ij,lj,uj,VU,hj,cj,mj,yj,xj,vj,Ij,GU,Nj,_j,Rj,jU,KU,Mj,zj,Wj,ZU,Uj,Hj,jj,fN,Zj,IG,QU,Yj,e5,n5,a5,xU,xm,i5,SG,NG,TG,l5,p5,d5,f5,g5,y5,x5,oG,v5,T5,_5,R5,uG,D5,O5,z5,pG,$j,W5,U5,H5,q5,X5,J5,Q5,tq,cG,nq,mG,aq,iq,lq,pq,dq,xG,s6,fq,gq,bq,wq,kq,JU,$q,Rq,Dq,Gj];for(let e of Mq)up(e);var mN={};Ee(mN,{assertNotComplex:()=>Kl,bindCanvasToFramebuffer:()=>jq,bindColorTextureToFramebuffer:()=>$h,bindTextureToProgramUniformSampler:()=>AN,bindTextureUnit:()=>_N,bindVertexBufferToProgramAttribute:()=>vm,callAndCheck:()=>ue,canBeRepresented:()=>yN,createFragmentShader:()=>wN,createFramebuffer:()=>CN,createProgram:()=>vN,createStaticIndexBuffer:()=>SN,createStaticVertexBuffer:()=>IN,createTexture:()=>NN,createVertexShader:()=>xN,getBatchDim:()=>Ls,getExtensionOrThrow:()=>yu,getFramebufferErrorMessage:()=>RN,getMaxTexturesInShader:()=>ON,getNumChannels:()=>Gq,getProgramUniformLocation:()=>$N,getProgramUniformLocationOrThrow:()=>EN,getRowsCols:()=>zs,getShapeAs3D:()=>xu,getTextureShapeFromLogicalShape:()=>DN,getWebGLDisjointQueryTimerVersion:()=>LN,getWebGLErrorMessage:()=>bN,getWebGLMaxTextureSize:()=>MN,hasExtension:()=>Yn,isCapableOfRenderingToFloatTexture:()=>zN,isDownloadFloatTextureEnabled:()=>PN,isReshapeFree:()=>Bu,isWebGLFenceEnabled:()=>BN,isWebGLVersionEnabled:()=>Im,linkProgram:()=>kN,logShaderSourceAndInfoLog:()=>hx,resetMaxTextureSize:()=>qq,resetMaxTexturesInShader:()=>Kq,unbindColorTextureFromFramebuffer:()=>km,unbindTextureUnit:()=>Hq,validateFramebuffer:()=>bu,validateProgram:()=>Eh,validateTextureSize:()=>TN});var fs={},xh={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gN(e,t){fs[e]=t}function _r(e,t){if(!(e in fs)||t!=null){let r=Lq(e,t);if(r!==null)fs[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=fs[e];return n==null||n.isContextLost()?(delete fs[e],_r(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fs[e])}function Oq(e){if(typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Lq(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??Oq(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete fs[e]},!1),j().getBool("SOFTWARE_WEBGL_ENABLED")&&(xh.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",xh)||n.getContext("experimental-webgl",xh):n.getContext("webgl2",xh)}var Pu;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(Pu||(Pu={}));var Jn;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Jn||(Jn={}));var Yt;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Yt||(Yt={}));function Bp(e,t){return[t,e]}function zq(e,t){return e*t}function wh(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function ql(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Pq(e,t){let[n,r]=ql(e,t);return n*r*4}function px(e,t){let n=e,r,a,s,i,o,l,p,u,h,d;return j().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,p=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,p=4,u=4,h=t!=null?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:p,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function ue(e,t){let n=t();return j().getBool("DEBUG")&&Bq(e),n}function Bq(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+bN(e,t))}var Wq=596e-10,Vq=65504;function yN(e){return!!(j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Wq<Math.abs(e)&&Math.abs(e)<Vq)}function bN(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function yu(e,t){return ma(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function xN(e,t){let n=ma(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ue(e,()=>e.shaderSource(n,t)),ue(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function wN(e,t){let n=ma(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ue(e,()=>e.shaderSource(n,t)),ue(e,()=>e.compileShader(n)),j().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw hx(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Uq=/ERROR: [0-9]+:([0-9]+):/g;function hx(e,t){let n=Uq.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split(`
`),s=a.length.toString().length+2,i=a.map((h,d)=>w.rightPad((d+1).toString(),s)+h),o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);let l=i.slice(0,r-1),p=i.slice(r-1,r),u=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(p[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function vN(e){return ma(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function kN(e,t){if(ue(e,()=>e.linkProgram(t)),!j().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Eh(e,t){if(ue(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function IN(e,t){let n=ma(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ue(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),ue(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function SN(e,t){let n=ma(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return ue(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),ue(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Gq(){return j().getNumber("WEBGL_VERSION")===2?1:4}function NN(e){return ma(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function TN(e,t){let n=j().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function CN(e){return ma(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function vm(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(ue(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),ue(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),ue(e,()=>e.enableVertexAttribArray(o)),!0)}function _N(e,t,n){FN(e,n),ue(e,()=>e.activeTexture(e.TEXTURE0+n)),ue(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function Hq(e,t){FN(e,t),ue(e,()=>e.activeTexture(e.TEXTURE0+t)),ue(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function EN(e,t,n){return ma(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function $N(e,t,n){return e.getUniformLocation(t,n)}function AN(e,t,n,r){ue(e,()=>_N(e,t,r)),ue(e,()=>e.uniform1i(n,r))}function jq(e){ue(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ue(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),ue(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function $h(e,t,n){ue(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),ue(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function km(e,t){ue(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),ue(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function bu(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+RN(e,t))}function RN(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ma(e,t,n){let r=ue(e,()=>t());if(r==null)throw new Error(n);return r}function FN(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let a=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${a}.`)}}function Ls(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function zs(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function xu(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Ls(e),...zs(e)]),t}function DN(e,t=!1){let n=j().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=j().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&j().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let a=w.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=Ls(e),l=2,p=2;e.length&&([l,p]=zs(e)),a=o*(l/2)*(p/2),s=w.sizeToSquarishShape(a).map(u=>u*2)}else s=w.sizeToSquarishShape(a);return s}function vh(e){return e%2===0}function Bu(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||vh(n)&&vh(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&vh(e[0])&&vh(t[0])}var Ah,Rh;function MN(e){if(Ah==null){let t=_r(e);Ah=t.getParameter(t.MAX_TEXTURE_SIZE)}return Ah}function qq(){Ah=null}function Kq(){Rh=null}function ON(e){if(Rh==null){let t=_r(e);Rh=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Rh)}function LN(e){if(e===0)return 0;let t,n=_r(e);return Yn(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Yn(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Yn(e,t){return e.getExtension(t)!=null}function Im(e){try{if(_r(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function zN(e){if(e===0)return!1;let t=_r(e);if(e===1){if(!Yn(t,"OES_texture_float"))return!1}else if(!Yn(t,"EXT_color_buffer_float"))return!1;return Sm(t)}function PN(e){if(e===0)return!1;let t=_r(e);if(e===1){if(!Yn(t,"OES_texture_float")||!Yn(t,"WEBGL_color_buffer_float"))return!1}else{if(Yn(t,"EXT_color_buffer_float"))return Sm(t);let n="EXT_color_buffer_half_float";if(Yn(t,n)){let r=t.getExtension(n);return Xq(t,r)}return!1}return Sm(t)}function Sm(e){let t=px(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),i}function Xq(e,t){let n=px(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function BN(e){return e!==2?!1:_r(e).fenceSync!=null}function Kl(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var xe=j();xe.registerFlag("HAS_WEBGL",()=>xe.getNumber("WEBGL_VERSION")>0);xe.registerFlag("WEBGL_VERSION",()=>Im(2)?2:Im(1)?1:0);xe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);xe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>xe.get("WEBGL_VERSION")===2);xe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);xe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);xe.registerFlag("WEBGL_PACK",()=>xe.getBool("HAS_WEBGL"));xe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_CLIP",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_REDUCE",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_LAZILY_UNPACK",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_CONV_IM2COL",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>MN(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>ON(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=xe.getNumber("WEBGL_VERSION");return e===0?0:LN(e)});xe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>xe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!dp.isMobile());xe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>zN(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>xe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:xe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));xe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>PN(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>BN(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>xe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);xe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});xe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>dp.isMobile()?1:-1,e=>{if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});xe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);xe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);xe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);xe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);xe.registerFlag("WEBGL_EXP_CONV",()=>!1);xe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>xe.getBool("IS_TEST"));xe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);xe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);xe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);xe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function vn(){let e,t,n,r,a,s,i,o,l,p;return j().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=j().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",p=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,p=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:p}}function qi(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / ${a}`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a}`:`index -= ${e[s]} * ${a}`;return`${i}; ${o};`}).join("")}function tf(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function Zq(e,t){let n=e.length,r=e.map(s=>`${t}[${s}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function Jq(e,t,n="index"){let r=e.map((s,i)=>i),a=Zq(r,t);return a.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${a[i]}`,l=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a[i]}`:`index -= ${e[i]} * ${a[i]}`;return`${o}; ${l};`}).join("")}function dx(e){let t=w.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function cx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var WN=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:VN}=T;function Yq(e,t,n){let r=[];if(e.forEach(d=>{let c=w.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${c>1?`[${c}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),n.enableShapeUniforms){let{uniformShape:f}=fx(n.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let a=r.join(`
`),s=e.map(d=>Qq(d,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=vn(),l=nK(o),p,u,h=sK(o);return t.isPacked?(p=eK(t.logicalShape,i,n.enableShapeUniforms),u=aK(o)):(p=tK(t.logicalShape,i,n.enableShapeUniforms),u=rK(o)),n.packedInputs&&(h+=uK),[h,l,u,a,p,s,n.userCode].join(`
`)}function Xl(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return vK(e,t);case 1:return IK(e,t);case 2:return NK(e,t);case 3:return CK(e,t);case 4:return EK(e,t);case 5:return $K(e);case 6:return AK(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function UN(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return wK(e);case 1:return kK(e,t);case 2:return SK(e,t);case 3:return TK(e,t);default:return _K(e,t)}}function Qq(e,t,n=!1,r){let a="";n?a+=UN(e,r):a+=Xl(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=RK(e,t):a+=FK(e,t)),a}function eK(e,t,n){switch(e.length){case 0:return GN();case 1:return pK(e,t,n);case 2:return bK(e,t,n);case 3:return dK(e,t,n);default:return fK(e,t,n)}}function tK(e,t,n){switch(e.length){case 0:return GN();case 1:return hK(e,t,n);case 2:return xK(e,t,n);case 3:return cK(e,t,n);case 4:return mK(e,t,n);case 5:return gK(e,t);case 6:return yK(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function nK(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function rK(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function aK(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function sK(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${iK}
    ${oK}
    ${lK}
  `}var iK=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oK=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lK=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,uK=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function GN(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pK(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function hK(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function dK(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function cK(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${tf(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=qi(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function fK(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let p=2;p<e.length-1;p++)i*=e[e.length-p-1],o=`
      int b${p} = index / ${i};
      index -= b${p} * ${i};
    `+o,l=`b${p}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}function mK(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${tf(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=qi(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function gK(e,t){let n=qi(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function yK(e,t){let n=qi(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function bK(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let a=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function xK(e,t,n){return w.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Ki(e){return`offset${e}`}function wK(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=vn();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function vK(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Ki(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function kK(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=vn();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function IK(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Zl(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Ki(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function SK(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=vn();if(s!=null&&w.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let p=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${p[0]}, ${p[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function NK(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(n,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let d=s[0],c=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=w.squeezeShape(n),l=i;if(l.length<n.length){let d=Jl(e,l),c=["row","col"];return`
      ${Xl(d,t)}
      float ${a}(int row, int col) {
        return ${a}(${Yl(c,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Zl(e)}
      }
    `;let p=s[0],u=s[1],h=Ki(r);return u===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `:p===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${p}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function TK(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let d=n.slice(1),c=[1,2],f=Jl(e,d),m=["b","row","col"];return`
        ${UN(f,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${Yl(m,c)});
        }
      `}let o=vn();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],p=i[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${p}, ${h}, ${u}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function CK(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=w.squeezeShape(n),p=o;if(p.length<n.length){let m=Jl(e,p),g=["row","col","depth"];return`
        ${Xl(m,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${Yl(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Zl(e)}
      }
    `;let u=e.shapeInfo.texShape,h=u[0],d=u[1],c=e.shapeInfo.flatOffset;if(d===s&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===i&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Ki(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function _K(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=vn();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],p=l[0],u=l[1],h=Math.ceil(s[i-1]/2),d=h*Math.ceil(s[i-2]/2),c="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)c=`int b${m}, `+c,d*=s[i-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${r}(${c}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${p});
      return ${a.texture2D}(${n}, uv);
    }
  `}function EK(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:p}=w.squeezeShape(n);if(l.length<n.length){let b=Jl(e,l),x=["row","col","depth","depth2"];return`
      ${Xl(b,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${Yl(x,p)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Zl(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],c=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(c===o&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(c===s&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Ki(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${c}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function $K(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:p}=w.squeezeShape(t);if(l.length<t.length){let m=Jl(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Xl(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Yl(g,p)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${a})) +
          depth3;
        ${Zl(e)}
      }
    `;let u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],c=h[1];if(c===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(c===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Ki(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${a} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${c}, index);
      return sampleTexture(${n}, uv);
    }
  `}function AK(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=w.squeezeShape(t);if(a.length<t.length){let g=Jl(e,a),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Xl(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Yl(y,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,p=t[2]*l,u=t[1]*p;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${p}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Zl(e)}
      }
    `;let h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],f=d[1];if(f===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${p}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Ki(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${p} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${c}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Zl(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function RK(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=VN(e.shapeInfo.logicalShape,t.logicalShape),l=pt(i),p=i-s,u,h=["x","y","z","w","u","v"];s===0?u="":i<2&&o.length>=1?u="coords = 0;":u=o.map(g=>`coords.${h[g+p]} = 0;`).join(`
`);let d="";i<2&&s>0?d="coords":d=e.shapeInfo.logicalShape.map((g,y)=>`coords.${h[y+p]}`).join(", ");let c="return outputValue;",f=w.sizeFromShape(e.shapeInfo.logicalShape)===1,m=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!f&&!m)c=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?c=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:c=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=s-2,y=s-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?c="return vec4(outputValue.x);":o.indexOf(g)>-1?c="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(c="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${d});
      ${c}
    }
  `}function FK(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let p=pt(l),u=VN(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,d,c=["x","y","z","w","u","v"];o===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${c[m+h]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${c[g+h]}`).join(", "),`
    float ${a}() {
      ${p} coords = getOutputCoords();
      ${d}
      return get${r}(${f});
    }
  `}function pt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function fx(e,t,n){let{newShape:r,keptDims:a}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&s>1&&!w.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Jl(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Yl(e,t){return t.map(n=>e[n]).join(", ")}function DK(e,t,n,r){let a=n.map((u,h)=>{let d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[h],shapeInfo:d}}),s=a.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Yq(a,i,t),l=wN(e.gl,o),p=e.createProgram(l);return j().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:i},HN(e,t,p))}function HN(e,t,n){let r={},a={},s={},i=[],o,l,p,u=null,h=null;h=e.getUniformLocation(n,"NAN",!1),j().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(n,"INFINITY",!1));let d=!1;for(let c=0;c<t.variableNames.length;c++){let f=t.variableNames[c];r[f]=e.getUniformLocation(n,f,d),r[`offset${f}`]=e.getUniformLocation(n,`offset${f}`,d),t.enableShapeUniforms&&(a[`${f}Shape`]=e.getUniformLocation(n,`${f}Shape`,d),s[`${f}TexShape`]=e.getUniformLocation(n,`${f}TexShape`,d))}return t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",d),p=e.getUniformLocation(n,"outShapeStrides",d),l=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms&&t.customUniforms.forEach((c,f)=>{i[f]=e.getUniformLocation(n,c.name,d)}),{uniformLocations:r,customUniformLocations:i,infLoc:u,nanLoc:h,inShapesLocations:a,inTexShapesLocations:s,outShapeLocation:o,outShapeStridesLocation:p,outTexShapeLocation:l}}function dv(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,s=t[r],i=s.shape;if(!w.arraysEqual(a,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function MK(e,t,n,r,a){t.program.enableShapeUniforms||(dv(t.inShapeInfos,n),dv([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),j().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((l,p)=>{let u=t.program.variableNames[p],h=t.uniformLocations[u],d=t.uniformLocations[`offset${u}`],c=t.inShapesLocations[`${u}Shape`],f=t.inTexShapesLocations[`${u}TexShape`];if(c){let{uniformShape:m}=fx(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(c,new Int32Array(m));break;case 2:e.gl.uniform2iv(c,new Int32Array(m));break;case 3:e.gl.uniform3iv(c,new Int32Array(m));break;case 4:e.gl.uniform4iv(c,new Int32Array(m));break}}if(f&&e.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(w.sizeFromShape(l.shape)<2)e.gl.uniform1f(h,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(h,m)}return}l.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,l.texData.slice.flatOffset),e.setInputMatrixTexture(l.texData.texture.texture,h,p)}});let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=w.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach((l,p)=>{let u=t.customUniformLocations[p],h=a[p];if(l.type==="float")e.gl.uniform1fv(u,h);else if(l.type==="vec2")e.gl.uniform2fv(u,h);else if(l.type==="vec3")e.gl.uniform3fv(u,h);else if(l.type==="vec4")e.gl.uniform4fv(u,h);else if(l.type==="int")e.gl.uniform1iv(u,h);else if(l.type==="ivec2")e.gl.uniform2iv(u,h);else if(l.type==="ivec3")e.gl.uniform3iv(u,h);else if(l.type==="ivec4")e.gl.uniform4iv(u,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),e.executeProgram()}function OK(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:p,uniformShape:u,keptDims:h}=fx(e.packedInputs,i.shape,l),d="",c="",f="";if(u.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${I[0]>1}_${I[1]>1}`}else if(u.length===2&&!e.packedInputs)c=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let I=w.computeStrides(u);f=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let m=i.shape.length,g=u.length===2&&w.arraysEqual(i.shape,l),y=w.sizeFromShape(i.shape)===1,b=T.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&w.arraysEqual(l,n.texData.texShape),v=e.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${p?h:""}_${u.length}_${y}_${b}_${g}_${d}_${c}_${f}_${v}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${j().getNumber("WEBGL_VERSION")}`,s}function kn(e){return j().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var LK=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Pu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=vn();this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?tf(["r","c","d"],e):qi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},zK=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Pu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=vn();this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?tf(["r","c","d"],e):qi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},PK=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Jn.DOWNLOAD;let t=vn();this.outputShape=e,this.userCode=`
      ${WN}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},BK=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Jn.DOWNLOAD;let t=vn();this.outputShape=e,this.userCode=`
      ${WN}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},WK={R:0,G:1,B:2,A:3},cv=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=vn();this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${WK[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?cx():dx(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}},VK=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=vn();this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?cx():dx(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}},jN={};Ee(jN,{bindVertexProgramAttributeStreams:()=>t2,createBufferFromOutputTexture:()=>a2,createFloat16MatrixTexture:()=>JN,createFloat16PackedMatrixTexture:()=>e2,createFloat32MatrixTexture:()=>ZN,createIndexBuffer:()=>XN,createPackedMatrixTexture:()=>QN,createUnsignedBytesMatrixTexture:()=>YN,createVertexBuffer:()=>KN,createVertexShader:()=>qN,downloadByteEncodedFloatMatrixFromOutputTexture:()=>i2,downloadFloat32MatrixFromBuffer:()=>s2,downloadMatrixFromPackedOutputTexture:()=>l2,downloadPackedMatrixFromBuffer:()=>o2,getInternalFormatForFloat16MatrixTexture:()=>gx,getInternalFormatForFloat16PackedMatrixTexture:()=>xx,getInternalFormatForFloat32MatrixTexture:()=>mx,getInternalFormatForPackedMatrixTexture:()=>bx,getInternalFormatForUnsignedBytesMatrixTexture:()=>yx,uploadDenseMatrixToTexture:()=>n2,uploadPixelDataToTexture:()=>r2});function qN(e){let t=vn(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return xN(e,n)}function KN(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return IN(e,t)}function XN(e){let t=new Uint16Array([0,1,2,2,1,3]);return SN(e,t)}function Wp(e,t,n,r,a,s){TN(t,n);let i=NN(e),o=e.TEXTURE_2D;return ue(e,()=>e.bindTexture(o,i)),ue(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),ue(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),ue(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),ue(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),j().getNumber("WEBGL_VERSION")===1?ue(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):ue(e,()=>e.texStorage2D(o,1,r,t,n)),ue(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function mx(e){return e.internalFormatFloat}function ZN(e,t,n,r){let[a,s]=Bp(t,n);return Wp(e,a,s,mx(r),r.textureFormatFloat,e.FLOAT)}function gx(e){return e.internalFormatHalfFloat}function JN(e,t,n,r){let[a,s]=Bp(t,n);return Wp(e,a,s,gx(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function yx(e){return e.downloadTextureFormat}function YN(e,t,n,r){let[a,s]=Bp(t,n);return Wp(e,a,s,yx(r),e.RGBA,e.UNSIGNED_BYTE)}function bx(e){return e.internalFormatPackedFloat}function QN(e,t,n,r){let[a,s]=ql(t,n);return Wp(e,a,s,bx(r),e.RGBA,e.FLOAT)}function xx(e){return e.internalFormatPackedHalfFloat}function e2(e,t,n,r){let[a,s]=ql(t,n);return Wp(e,a,s,xx(r),e.RGBA,r.textureTypeHalfFloat)}function t2(e,t,n){return ue(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),vm(e,t,"clipSpacePos",n,3,20,0)&&vm(e,t,"uv",n,2,20,12)}function n2(e,t,n,r,a,s){ue(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),j().getNumber("WEBGL_VERSION")===2?ue(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):ue(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),ue(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function r2(e,t,n){ue(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?j().getNumber("WEBGL_VERSION")===2?ue(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):ue(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):j().getNumber("WEBGL_VERSION")===2?ue(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):ue(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),ue(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function a2(e,t,n,r){let a=e.createBuffer();ue(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=4*4*t*n;return ue(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),ue(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),ue(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function s2(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function i2(e,t,n,r){let[a,s]=Bp(t,n),i=4,o=new Uint8Array(zq(t*n,i));return ue(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function o2(e,t,n,r,a,s,i,o){let l=e,p=new Float32Array(Pq(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,p),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),p}function l2(e,t,n){let r=new Float32Array(t*n*4);return ue(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var Fh=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=j().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,gN(t,e)):this.gl=_r(t),e=this.gl,j().getNumber("WEBGL_VERSION")===2){let a=e;this.createVertexArray=()=>ue(a,()=>a.createVertexArray()),this.bindVertexArray=s=>ue(a,()=>a.bindVertexArray(s)),this.deleteVertexArray=s=>ue(a,()=>a.deleteVertexArray(s)),this.getVertexArray=()=>ue(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){let a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ue(e,()=>a.createVertexArrayOES()),this.bindVertexArray=s=>ue(e,()=>a.bindVertexArrayOES(s)),this.deleteVertexArray=s=>ue(e,()=>a.deleteVertexArrayOES(s)),this.getVertexArray=()=>ue(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),j().getNumber("WEBGL_VERSION")===1){let a="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=yu(this.gl,a),Yn(this.gl,s))this.textureHalfFloatExtension=yu(this.gl,s);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Yn(this.gl,r))this.colorBufferHalfFloatExtension=yu(this.gl,r);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Yn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Yn(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=KN(this.gl),this.indexBuffer=XN(this.gl),this.framebuffer=CN(this.gl),this.textureConfig=px(this.gl,this.textureHalfFloatExtension)}get debug(){return j().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;ue(e,()=>e.finish()),ue(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ue(e,()=>e.deleteFramebuffer(this.framebuffer)),ue(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ue(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ue(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),ZN(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),JN(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),YN(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),r2(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),n2(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),e2(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),QN(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(km(this.gl,this.framebuffer),this.outputTexture=null),ue(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>i2(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return o2(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return s2(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=a2(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(j().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=r.clientWaitSync(a,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},t=a}else j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>l2(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=qN(t));let n=vN(t);ue(t,()=>t.attachShader(n,this.vertexShader)),ue(t,()=>t.attachShader(n,e)),kN(t,n);let r;return r=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(r.vao),ue(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(t2(t,r,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&Eh(t,r),this.setProgram(r),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(ue(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&Eh(this.gl,this.program)),ue(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?EN(this.gl,e,t):$N(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ue(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),AN(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=ql(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Eh(this.gl,this.program),bu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ue(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ue(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yu(this.gl,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=UK(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in j().platform&&(n=j().platform.setTimeoutCustom.bind(j().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),$h(this.gl,e,this.framebuffer),this.debug&&bu(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?($h(this.gl,this.outputTexture,this.framebuffer),this.debug&&bu(this.gl)):km(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;$h(r,e,this.framebuffer),this.debug&&bu(r),this.outputTexture=e,ue(r,()=>r.viewport(0,0,t,n)),ue(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),ue(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function UK(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:GK,bincountImpl:u2,bincountReduceImpl:HK,castImpl:jK,ceilImpl:qK,concatImpl:KK,equalImpl:XK,expImpl:ZK,expm1Impl:JK,floorImpl:YK,gatherNdImpl:QK,gatherV2Impl:e8,greaterImpl:t8,greaterEqualImpl:n8,lessImpl:r8,lessEqualImpl:a8,linSpaceImpl:s8,logImpl:i8,maxImpl:o8,maximumImpl:l8,minimumImpl:u8,multiplyImpl:p8,negImpl:h8,notEqualImpl:d8,prodImpl:c8,raggedGatherImpl:f8,raggedRangeImpl:m8,raggedTensorToTensorImpl:g8,rangeImpl:y8,rsqrtImpl:b8,scatterImpl:x8,sigmoidImpl:w8,simpleAbsImpl:p2,sliceImpl:v8,sparseFillEmptyRowsImpl:k8,sparseReshapeImpl:I8,sparseSegmentReductionImpl:h2,sqrtImpl:S8,stridedSliceImpl:N8,stringNGramsImpl:T8,stringSplitImpl:C8,stringToHashBucketFastImpl:_8,subImpl:E8,tileImpl:$8,topKImpl:A8,transposeImpl:wx,uniqueImpl:R8}=cS;function d2(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function hn(e,t){return t===1?[e]:d2(e,t)}function F8(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var D8=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=kn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=hn("rc",this.rank),n=pt(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)a=`${e[e.length-1-s]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},c2=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${M8(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?cx():dx(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function M8(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Jq(["r","c","d"],"inputShape"):qi(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var O8=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let r=mv(t,n),a=gv(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s=fv(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[a].shift();return this.usedTextures[a].push(o),o}let i;return r===Yt.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Yt.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Yt.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Yt.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Yt.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let a=mv(n,r),s=gv(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=fv(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=j().get("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],p=l.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function L8(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function fv(e,t,n,r,a){let s=z8(t,r),i;if(a){let[l,p]=ql(e[0],e[1]);i=l*p}else{let[l,p]=Bp(e[0],e[1]);i=l*p}let o=L8(n,s);return i*o}function z8(e,t){switch(e){case Yt.PACKED_2X2_FLOAT32:return bx(t);case Yt.PACKED_2X2_FLOAT16:return xx(t);case Yt.UNPACKED_FLOAT32:return mx(t);case Yt.UNPACKED_FLOAT16:return gx(t);case Yt.PACKED_4X1_UNSIGNED_BYTE:return yx(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function P8(e){return j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Yt.PACKED_2X2_FLOAT32:Yt.UNPACKED_FLOAT32:e?Yt.PACKED_2X2_FLOAT16:Yt.UNPACKED_FLOAT16}function mv(e,t){if(e===Jn.UPLOAD)return Yt.PACKED_2X2_FLOAT32;if(e===Jn.RENDER||e==null)return P8(t);if(e===Jn.DOWNLOAD||e===Jn.PIXELS)return Yt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function gv(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var zr=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},yr="if (isnan(x)) return x;",B8="return x;",yv="return abs(x);",W8="return (x >= 0.0) ? x : (exp(x) - 1.0);",V8=yr+`
  return (x < 0.0) ? 0.0 : x;
`,U8=yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ia="return x;",G8="return 1.0 / (1.0 + exp(-1.0 * x));",H8="return x;",j8=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,q8=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,K8=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,X8="return 1.0 / (1.0 + exp(-1.0 * x));",_a=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},Z8=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length);let t=e.length,n=hn("rc",t),r=pt(t),a=F8(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},J8=qr.whereImpl,Y8=1e-7,Q8=1e-4,$f={};function eX(e){return e in $f||($f[e]={}),$f[e]}var tX=j().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),nX=600;function rX(){return j().global.screen==null?1024:j().global.screen.height*j().global.screen.width*window.devicePixelRatio*nX/1024/1024}var nf=class extends Hu{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!j().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Fh)t=e;else{let n=_r(j().getNumber("WEBGL_VERSION"),e);t=new Fh(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=_r(j().getNumber("WEBGL_VERSION"));t=new Fh(n),this.binaryCache=eX(j().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new O8(this.gpgpu),this.numMBBeforeWarning=rX(),this.texData=new bd(this,pr())}nextDataId(){return nf.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=xu(t),p=new cv(l,!1,s),u=this.runWebGLProgram(p,[i],n,[[r,a]]);return u.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((j().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||j().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:Jn.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(j().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:Jn.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(s!=null){let h;o?h=new _a(i,Ia):h=new zr(i,Ia);let d=this.runWebGLProgram(h,[{dataId:e,shape:i,dtype:r}],r),c=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),c}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;let l=this.activeTimers!=null,p;l&&(p=w.now());let u;if(r==="complex64"){let h=this.readSync(a.real.dataId),d=this.readSync(a.imag.dataId);u=T.mergeRealAndImagArrays(h,d)}else u=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=w.now()-p),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let c=this.pendingRead.get(e);return new Promise(f=>c.push(f))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(a!=null){let c;o?c=new _a(r,Ia):c=new zr(r,Ia);let f=this.runWebGLProgram(c,[{dataId:e,shape:r,dtype:s}],s),m=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(n!=null)return this.convertAndCacheOnCPU(e);if(j().getBool("DEBUG")&&!j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&j().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(s!=="complex64"&&j().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let c=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(c.texture.texture,...wh(r))}this.pendingRead.set(e,[]),s!=="complex64"&&await this.gpgpu.createAndWaitForFence();let u;if(s==="complex64"){let c=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),f=c[0],m=c[1];u=T.mergeRealAndImagArrays(f,m)}else if(l==null)u=this.getValuesFromTexture(e);else{let c=w.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(l,c)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let c=this.gpgpu.gl;ue(c,()=>c.deleteBuffer(l))}let h=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(c=>c(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&pr().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(s!=null){let d;o?d=new _a(a,Ia):d=new zr(a,Ia);let c=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:i}],i),f=this.readToGPU(c,t);return this.disposeIntermediateTensorInfo(c),f}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,t.customTexShape),u=pr().makeTensorFromTensorInfo(p),h=this.texData.get(p.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(r=>w.decodeString(r));return ze(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!yN(n))throw j().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=w.sizeFromShape(t);if(j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let h=this.decode(e),d=this.texData.get(h.dataId),c=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...wh(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),c}let s=j().getBool("WEBGL_PACK")&&r===!0,i=s?xu(t):t,o=s?new BK(i):new PK(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),p=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=w.flatten(this.activeTimers.map(o=>o.query)).filter(o=>o!=null),s=w.flatten(this.activeTimers.map(o=>o.name)).filter(o=>o!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let o=await Promise.all(a);i.kernelMs=w.sum(o),i.getExtraProfileInfo=()=>o.map((l,p)=>({name:s[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(e){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=w.now(),e)}async getQueryTime(e){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=tX){return j().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&w.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){T.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return J8(e.shape,t)}packedUnaryOp(e,t,n){let r=new _a(e.shape,t),a=this.compileAndRun(r,[e],n);return pr().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let r=p2(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(j().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,yv,e.dtype);let t=new zr(e.shape,yv),n=this.compileAndRun(t,[e]);return pr().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&w.isString(n[0])){let a=n.map(s=>w.encodeString(s));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return pr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new Z8(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new D8(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[Ls(e.shape),...zs(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[Ls(t),...zs(t)],s=new c2(a,n),i=!0,o=[n],l=this.runWebGLProgram(s,[r],e.dtype,o,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(t!=null){let h=w.sizeFromShape(a),d=t[0]*t[1]*4;w.assert(h<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=xu(a),o;r?o=new zK(i):o=new LK(i);let l=!0,p=[t??wh(i)],u=this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:e}],s,p,l,t);return{dtype:s,shape:a,dataId:u.dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===Pu.DENSE){let g=s??wh(e.outputShape);o.texShape=g.map(y=>y*2)}if(e.outTexUsage!=null&&(o.usage=e.outTexUsage),w.sizeFromShape(i.shape)===0)return o.values=w.getTypedArrayFromDType(i.dtype,0),i;let l=[],p=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!e.packedInputs&&w.sizeFromShape(g.shape)<=j().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!y.isPacked!=!!e.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),l.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!Bu(y.shape,g.shape)){let b=g,x=g.shape;g.shape=y.shape,g=this.packedReshape(g,x),l.push(g),y=this.texData.get(g.dataId),b.shape=x}return{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(i.dataId);let u={shape:i.shape,texData:o,isUniform:!1},h=OK(e,p,u),d=this.getAndSaveBinary(h,()=>DK(this.gpgpu,e,p,u)),c=this.activeTimers!=null,f;c&&(f=this.startTimer()),j().get("ENGINE_COMPILE_ONLY")||MK(this.gpgpu,d,p,u,r),l.forEach(g=>this.disposeIntermediateTensorInfo(g)),c&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));let m=j().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let g=w.now();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!j().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&a===!1){let g=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),g}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(j().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=W(()=>{if(!j().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=j().getBool("DEBUG");j().set("DEBUG",!1);let t=this.abs(ve(1e-8)).dataSync()[0];if(j().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Y8:Q8}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(s!=null)return;let l=this.activeTimers!=null,p;l&&(p=w.now());let u=t.texShape;if(u==null&&(u=DN(n,o),t.texShape=u),a!=null){let h=xu(n),d,c=u[1],f=u[0],m=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!m)&&([c,f]=ql(u[0],u[1])),o?d=new VK(h,m):d=new cv(h,m);let g=m?[f,c]:u,y=this.makeTensorInfo(g,r),b=this.texData.get(y.dataId);m?b.usage=Jn.PIXELS:b.usage=Jn.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),c,f,a);let x=[[f,c]],v=!0,I=this.runWebGLProgram(d,[y],r,x,v),N=this.texData.get(I.dataId);t.texShape=N.texShape,t.isPacked=N.isPacked,t.usage=N.usage,j().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(t.texture=N.texture,t.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(y),l&&(this.uploadWaitMs+=w.now()-p)}else{let h=this.acquireTexture(u,i,r,o);t.texture=h}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return t!=null&&(n.values=aX(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*w.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(a){throw a}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await cy(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(hx(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:p}=HN(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.inShapesLocations=s,e.inTexShapesLocations=i,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=p}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=pr().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return pr().makeTensorFromDataId(l,t,n,o)}};nf.nextDataId=0;function aX(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var sX="4.2.0";function f2(){j().set("WEBGL_FORCE_F16_TEXTURES",!0)}dp.isBrowser()&&nc("webgl",()=>new nf,2);var iX={forceHalfFloat:f2},vx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,_o=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=kn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Vp=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Up=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=kn(a);let s="";if(r)if(a===0||w.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${pt(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=hn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Hn(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var oX={kernelName:ii,backendName:"webgl",kernelFunc:Hn};function es(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=Hn({inputs:{x:r},backend:n}),l=Hn({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var lX={kernelName:Td,backendName:"webgl",kernelFunc:es},m2="return (a < 0.) ? b * a : a;",g2=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function uX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",w.createScalarValue(s,"float32")),o=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Up(g2,a.shape,i.shape):new _o(m2,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var pX={kernelName:li,backendName:"webgl",kernelFunc:uX},y2="return (a < 0.) ? b * a : a;",b2=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function hX(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Up(b2,r.shape,a.shape):new _o(y2,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var dX={kernelName:vi,backendName:"webgl",kernelFunc:hX},Ql="if (isnan(x)) return x;";function qe({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let h=o.texData.get(i.dataId),d=n(h.values,l);return o.makeTensorInfo(i.shape,l,d)}let p=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return p?u=new _a(i.shape,t):u=new zr(i.shape,e),o.runWebGLProgram(u,[i],l)}}function tn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:p}=i,u=o;if(r&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(p.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[v,I]=x,N={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:I.dataId,dtype:I.dtype,shape:p.shape},E=new _o(e,l.shape,p.shape);return u.runWebGLProgram(E,[N,C],tr(v.dtype,I.dtype))}),b=es({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}let h=s||tr(l.dtype,p.dtype);if((l.dtype==="string"||p.dtype==="string"||u.shouldExecuteOnCPU([l,p]))&&a!=null){let f=u.texData.get(l.dataId).values,m=u.texData.get(p.dataId).values,g=l.dtype==="string"?T.fromUint8ToStringArray(f):f,y=l.dtype==="string"?T.fromUint8ToStringArray(m):m,[b,x]=a(l.shape,p.shape,g,y,h),v=u.makeTensorInfo(x,h),I=u.texData.get(v.dataId);return I.values=b,v}let d=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,c;return d?c=new Up(t,l.shape,p.shape,n):c=new _o(e,l.shape,p.shape),u.runWebGLProgram(c,[l,p],h)}}function Wu(e,t=!1){if(e==="linear")return t?H8:B8;if(e==="relu")return t?q8:V8;if(e==="elu")return t?j8:W8;if(e==="relu6")return t?K8:U8;if(e==="prelu")return t?b2:y2;if(e==="leakyrelu")return t?g2:m2;if(e==="sigmoid")return t?X8:G8;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var x2=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=kn(this.outputShape.length);let p=r?e[1]:e[2],u=Math.ceil(p/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",c=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${c[0]} * ${f[0]});
          result += (${c[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},bv={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},xv=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},wv="return a * b;";function kx(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=T.upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),p=new xv(bv.REAL,r.shape,a.shape),u=new xv(bv.IMAG,r.shape,a.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],d=n.runWebGLProgram(p,h,"float32"),c=n.runWebGLProgram(u,h,"float32"),f=es({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),f}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[p,u]=p8(r.shape,a.shape,o.values,l.values,s),h=n.makeTensorInfo(u,s),d=n.texData.get(h.dataId);return d.values=p,h}let i;return j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Up(wv,r.shape,a.shape):i=new _o(wv,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}var cX={kernelName:yi,backendName:"webgl",kernelFunc:kx};function fX(e,t,n){let r=[Ls(e.shape),...zs(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Ls(t),...zs(t)],i=new c2(s,r),o=!0,l=[r],p=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:p.dataId,shape:t,dtype:p.dtype}}function he(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=w.sizeFromShape(a.shape),l=w.inferFromImplicitShape(s,o),p=w.sizeFromShape(l);w.assert(o===p,()=>`The new shape (${l}) has ${p} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(a.dataId);return u.isPacked&&!Bu(a.shape,l)&&!(u.texture!==null&&Bu(u.shape,l))?fX(a,l,i):(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype})}var mX={kernelName:gl,backendName:"webgl",kernelFunc:he},vv=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let u=1/t;l=`sumValue += dot(values * ${w.isInt(u)?u.toPrecision(2):u}, ones);`}let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},gX=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,u=n%4,h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${p};
        if (${u===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${u===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function yX(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=T.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Xi(e,t,n,r){let a=yX(e.shape),s=e;for(let i=0;i<a.length;i++){let{inSize:o,windowSize:l,outSize:p}=a[i],u,h;n==="mean"?u=i===0?new vv({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p},o):new vv({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p}):u=new gX({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p},n),h=s,s=r.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return s}var bX=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=pt(this.rank),a=xX(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};function xX(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var wX=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=pt(this.rank),a=d2("rc",this.rank),s=new Array(this.rank);for(let p=0;p<t.length;p++)s[t[p]]=a[p];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function rf(e,t,n){let r=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wX(e.shape,t):new bX(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function vX(e,t,n,r){let a=t,s=e.shape.length,i=w.parseAxisParam(a,e.shape),o=i,l=T.getAxesPermutation(o,s),p=l!=null,u=e;p&&(u=rf(e,l,r),o=T.getInnerMostAxes(o.length,s)),T.assertAxesAreInnerMostDims("sum",o,s);let[h,d]=T.computeOutAndReduceShapes(u.shape,o),c=h;n&&(c=T.expandShapeToKeepDim(h,i));let f=w.sizeFromShape(d),m=w.sizeFromShape(e.shape)/f,g=he({inputs:{x:u},attrs:{shape:[m,f]},backend:r}),y=tc(e.dtype),b=Xi(g,y,"sum",r),x=he({inputs:{x:b},attrs:{shape:c},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),p&&r.disposeIntermediateTensorInfo(u),x}function af(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return vX(a,s,i,n)}var kX={kernelName:Di,backendName:"webgl",kernelFunc:af};function mn(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let p;if(i.shouldExecuteOnCPU([a])){let u=i.texData.get(a.dataId).values,h=wx(u,a.shape,a.dtype,s,l);p=i.makeTensorInfo(l,a.dtype);let d=i.texData.get(p.dataId);d.values=h}else p=rf(a,s,i);return p}var IX={kernelName:aa,backendName:"webgl",kernelFunc:mn},w2=1e3;function ud({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let p=e.shape.length,u=t.shape.length,h=n?e.shape[p-2]:e.shape[p-1],d=r?t.shape[u-1]:t.shape[u-2],c=n?e.shape[p-1]:e.shape[p-2],f=r?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=w.sizeFromShape(m),b=w.sizeFromShape(g),x=Fl.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([c,f]);w.assert(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[y,h,c]:[y,c,h],I=r?[b,f,d]:[b,d,f],N=he({inputs:{x:e},backend:a,attrs:{shape:v}}),C=he({inputs:{x:t},backend:a,attrs:{shape:I}}),E=[N,C],A=Math.max(y,b),F=n?N.shape[1]:N.shape[2],R=s!=null,S=i!=null,M=l==="leakyrelu",B=l!=null?Wu(l,!0):null,U=R||S||M||B!=null,G;if((c===1||f===1)&&F>w2&&U===!1){let H=N,X=C;n&&(H=mn({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),E.push(H)),r&&(X=mn({inputs:{x:C},backend:a,attrs:{perm:[0,2,1]}}),E.push(X));let ee=f!==1,Z=f===1,re=H;ee&&(re=he({inputs:{x:H},backend:a,attrs:{shape:[A,F,1]}}),E.push(re));let te=f===1?2:1,ae=X;Z&&(ae=he({inputs:{x:X},backend:a,attrs:{shape:[A,1,F]}}),E.push(ae));let ie=kx({inputs:{a:re,b:ae},backend:a});G=af({inputs:{x:ie},backend:a,attrs:{axis:te,keepDims:!0}}),E.push(ie)}else{let H=tr(e.dtype,t.dtype),X=new x2(v,I,[A,c,f],n,r,R,B,S,M),ee=[N,C];if(s!=null&&ee.push(s),S&&ee.push(i),M){let Z=a.makeTensorInfo([],"float32",w.createScalarValue(o,"float32"));ee.push(Z),E.push(Z)}G=a.runWebGLProgram(X,ee,H)}let K=he({inputs:{x:G},backend:a,attrs:{shape:x}});E.push(G);for(let H of E)a.disposeIntermediateTensorInfo(H);return K}function SX(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:h}=r;return ud({a,b:s,transposeA:l,transposeB:p,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}var NX={kernelName:ks,backendName:"webgl",kernelFunc:SX},kv="return abs(x);";function TX(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),i=p2(s.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let a;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new _a(r.shape,kv):a=new zr(r.shape,kv),n.runWebGLProgram(a,[r],r.dtype)}var CX={kernelName:Ao,backendName:"webgl",kernelFunc:TX},_X=yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,EX=qe({opSnippet:_X}),$X={kernelName:Ro,backendName:"webgl",kernelFunc:EX},AX=yr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,RX=qe({opSnippet:AX}),FX={kernelName:Fo,backendName:"webgl",kernelFunc:RX},Iv="return a + b;",DX=tn({opSnippet:Iv,packedOpSnippet:Iv,supportsComplex:!0,cpuKernelImpl:GK}),MX={kernelName:Ha,backendName:"webgl",kernelFunc:DX},OX=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},LX=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function Dh(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Hn({inputs:{x:r[0]},backend:n});if(r.length>j().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=Dh({inputs:r.slice(0,o),backend:n}),p=Dh({inputs:r.slice(o),backend:n});return Dh({inputs:[l,p],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>tr(o,l)),s=r.map(o=>o.shape),i=j().getBool("WEBGL_PACK")?new LX(r[0].shape,s):new OX(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var zX={kernelName:Ws,backendName:"webgl",kernelFunc:Dh};function PX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=T.getAxesPermutation(p,o),h=a;u!=null&&(h=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=T.getInnerMostAxes(p.length,o)),T.assertAxesAreInnerMostDims("all",p,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,p),f=w.sizeFromShape(c),m=he({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Xi(m,m.dtype,"all",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var BX={kernelName:Do,backendName:"webgl",kernelFunc:PX};function WX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=T.getAxesPermutation(p,o),h=a;u!=null&&(h=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=T.getInnerMostAxes(p.length,o)),T.assertAxesAreInnerMostDims("any",p,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,p),f=w.sizeFromShape(c),m=he({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Xi(m,m.dtype,"any",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var VX={kernelName:Mo,backendName:"webgl",kernelFunc:WX},UX=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},GX=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=pt(o),p=hn("coords",o),u,h;if(s===1){h=o+1;let C=pt(h);u=`
        ${C} sourceLocR = ${C}(${p.join()}, 0);
        ++${p[o-1]};
        ${C} sourceLocG = ${C}(${p.join()}, 0);
        ++${p[o-2]};
        ${C} sourceLocA = ${C}(${p.join()}, 0);
        --${p[o-1]};
        ${C} sourceLocB = ${C}(${p.join()}, 0);
        --${p[o-2]};`}else h=o,u=`
        ${l} sourceLocR = coords;
        ++${p[o-1]};
        ${l} sourceLocG = coords;
        ++${p[o-2]};
        ${l} sourceLocA = coords;
        --${p[o-1]};
        ${l} sourceLocB = coords;
        --${p[o-2]};`;let d=["x","y","z","w","u","v"].slice(0,h),c="."+d[h-1],f=d.map(C=>"int "+C),m=hn("sourceLocR",h-1).concat("inIdx.r"),g=hn("sourceLocG",h-1).concat("inIdx.g"),y=hn("sourceLocB",h-1).concat("inIdx.b"),b=hn("sourceLocA",h-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,I=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,N=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${N}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${p[o-2]} < ${i[o-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${c}, sourceLocG${c},
          sourceLocB${c}, sourceLocA${c}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function v2(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);let i=T.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new UX(o,n,r==null),p=[t];r!=null&&p.push(r);let u=e.runWebGLProgram(l,p,"int32");if(u.shape[1]===1)return u;let h=v2(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function k2(e,t,n,r=null){let a=r!=null?r.shape:t.shape,s=a[a.length-1],i=T.computeOptimalWindowSize(s),o=new GX(a,i,n,r==null),l=r==null?[t]:[t,r],p=e.runWebGLProgram(o,l,"int32");if(p.shape.length===t.shape.length){let u=k2(e,t,n,p);return e.disposeIntermediateTensorInfo(p),u}return p}function I2(e,t,n,r){let a=[n];if(T.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!j().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[p,u]=T.computeOutAndReduceShapes(l.shape,a),h=w.sizeFromShape(u),d=he({inputs:{x:l},backend:e,attrs:{shape:[-1,h]}});s.push(d);let c=v2(e,d,r);s.push(c);let f=he({inputs:{x:c},backend:e,attrs:{shape:p}});return s.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return k2(e,t,r)}function HX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=mn({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=I2(n,l,i[0],"max");return p.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var jX={kernelName:Vs,backendName:"webgl",kernelFunc:HX};function qX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=T.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=mn({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=I2(n,l,i[0],"min");return p.forEach(h=>n.disposeIntermediateTensorInfo(h)),u}var KX={kernelName:ju,backendName:"webgl",kernelFunc:qX},XX=yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ZX=qe({opSnippet:XX}),JX={kernelName:Oo,backendName:"webgl",kernelFunc:ZX},YX=yr+"return log(x + sqrt(x * x + 1.0));",QX=qe({opSnippet:YX}),e7={kernelName:Lo,backendName:"webgl",kernelFunc:QX},t7=yr+`
  return atan(x);
`,n7=qe({opSnippet:t7}),r7={kernelName:zo,backendName:"webgl",kernelFunc:n7},a7=vx+`
  return atan(a, b);
`,s7=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vp+`
  return result;
`,i7=tn({opSnippet:a7,packedOpSnippet:s7}),o7={kernelName:Bo,backendName:"webgl",kernelFunc:i7},l7=yr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,u7=qe({opSnippet:l7}),p7={kernelName:Po,backendName:"webgl",kernelFunc:u7},Vu=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let C=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${d}, ${c});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?m:g:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let v=Math.floor(s/4)*4,I=s%4,N=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${d}, ${c});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${N}
          }

          int xC = xCCorner + ${v};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${N}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${N}
          }
        }
        setOutput(${x});
      }
    `}},Ix=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",x="0.0";if(b||(x="-1.0 / 1e-20"),n){let A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${c};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let N=Math.floor(s/4)*4,C=s%4,E=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${N}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${N};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${I});
      }
    `}};function h7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Kl(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=T.computePool2DInfo(a.shape,s,i,p,o,l);if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))return Hn({inputs:{x:a},backend:n});let h=new Vu(u,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}var d7={kernelName:Us,backendName:"webgl",kernelFunc:h7};function c7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r,u=[1,1,1],h=T.computePool3DInfo(a.shape,s,i,u,o,l,p),d=new Ix(h,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var f7={kernelName:qu,backendName:"webgl",kernelFunc:c7},m7=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=o-1-e.padInfo.top,u=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${u});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},g7=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${c}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function y7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:u}=r,h=[1,1,1],d=T.computePool3DInfo(i.shape,o,l,h,p,u),c=new g7(d);return n.runWebGLProgram(c,[a],i.dtype)}var b7={kernelName:Id,backendName:"webgl",kernelFunc:y7};function x7(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Kl([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:p}=r,u=T.computePool2DInfo(i.shape,o,l,1,p),h=new m7(u);return n.runWebGLProgram(h,[a],i.dtype)}var w7={kernelName:kd,backendName:"webgl",kernelFunc:x7};function v7(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return ud({a,b:s,transposeA:i,transposeB:o,backend:n})}var k7={kernelName:Gs,backendName:"webgl",kernelFunc:v7},I7=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},S7=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},N7=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;w.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=[r,a,s],u=null;i!=null&&(u=i.shape,p.push(i));let h=null;o!=null&&(h=o.shape,p.push(o));let d=j().getBool("WEBGL_PACK_NORMALIZATION")?new S7(r.shape,a.shape,s.shape,u,h,l):new I7(r.shape,a.shape,s.shape,u,h,l);return t.runWebGLProgram(d,p,p[0].dtype)},T7={kernelName:ai,backendName:"webgl",kernelFunc:N7},C7=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=pt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=_7(this.rank),r,a=e.map((s,i)=>`sourceLoc.${Nm[i]} = start[${i}] + coords.${Nm[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},Nm=["x","y","z","w","u","v"];function _7(e){if(e===1)return"sourceLoc";if(e<=6)return Nm.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var E7=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=pt(this.rank),n=hn("coords",this.rank),r=hn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,u)=>`start[${u}]`).join()});`:e.map((p,u)=>`${r[u]} = ${n[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function $7(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Lt.computeFlatOffset(t,w.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function eu(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Lt.parseSliceParams(a,s,i);if(Lt.assertParamsValid(a,o,l),w.sizeFromShape(l)===0)return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){let h=n.texData.get(a.dataId),d=v8(h.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,d)}let{isPacked:p}=n.texData.get(a.dataId),u=Lt.isSliceContinous(a.shape,o,l);if(p||!u){let h=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new E7(l):new C7(l),d=[o];return n.runWebGLProgram(h,[a],a.dtype,d)}return n.uploadToGPU(a.dataId),$7(a,o,l,n)}var A7={kernelName:wl,backendName:"webgl",kernelFunc:eu},R7=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;w.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((b,x)=>b*x),l=T.getReshaped(a.shape,s,o),p=T.getPermuted(l.length,s.length),u=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(u,i,s.length),c=[],f=he({inputs:{x:a},backend:n,attrs:{shape:l}}),m=mn({inputs:{x:f},backend:n,attrs:{perm:p}}),g=he({inputs:{x:m},backend:n,attrs:{shape:u}}),y=eu({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return c.push(f),c.push(m),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},F7={kernelName:Wo,backendName:"webgl",kernelFunc:R7};function D7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),p=u2(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}var M7={kernelName:Sd,backendName:"webgl",kernelFunc:D7};function O7(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var L7={kernelName:Nd,backendName:"webgl",kernelFunc:O7},z7="return float(a != b);",S2=tn({opSnippet:z7,cpuKernelImpl:d8,dtype:"bool"}),P7={kernelName:pl,backendName:"webgl",kernelFunc:S2};function Gp(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Hn({inputs:{x:a.complexTensorInfos.real},backend:n})}var B7={kernelName:Kd,backendName:"webgl",kernelFunc:Gp},W7="return float(int(x));";function V7(e,t){let n=new zr(e.shape,W7),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Tm(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Hn({inputs:{x:a},backend:n});let i=bt(a.shape),o=Tm({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=es({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(a.dtype==="complex64"){let i=Gp({inputs:{input:a},backend:n}),o=Tm({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!w.hasEncodingLoss(a.dtype,s)){let i=Hn({inputs:{x:a},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId).values,[o,l,p]=jK(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,p)}if(s==="int32")return V7(a,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),o=S2({inputs:{a,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var U7={kernelName:Hs,backendName:"webgl",kernelFunc:Tm},Sv="return ceil(x);",G7=qe({opSnippet:Sv,packedOpSnippet:Sv,cpuKernelImpl:qK}),H7={kernelName:js,backendName:"webgl",kernelFunc:G7},j7=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},q7=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function K7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o;j().getBool("WEBGL_PACK_CLIP")?o=new q7(a.shape):o=new j7(a.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}var X7={kernelName:ja,backendName:"webgl",kernelFunc:K7},Z7=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function Nv(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function J7(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new Z7(r.shape),i=[Nv(r,a.complexTensorInfos.real),Nv(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var Y7={kernelName:Ku,backendName:"webgl",kernelFunc:J7},Q7=class{constructor(e){this.outputShape=[],this.outputShape=T.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},eZ=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=pt(r),s=hn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],p=i.slice(-2),u=i.join(),h=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${u}), vec2(${p.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];h+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${kh(i,l,m)}),
            vec2(${kh(p,l,m)}));
        }`}let d=o.length,c=o[o.length-1];h+=`
        return getChannel(
          getT${d}(${kh(i,l,c)}),
          vec2(${kh(p,l,c)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function kh(e,t,n){let r=e.indexOf(t);return e.map((a,s)=>s===r?`${a} - ${n}`:a).join()}function sf(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Hn({inputs:{x:a.complexTensorInfos.imag},backend:n})}var tZ={kernelName:zd,backendName:"webgl",kernelFunc:sf};function wu(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(b=>Gp({inputs:{input:b},backend:n})),f=e.map(b=>sf({inputs:{input:b},backend:n})),m=wu(c,t,n),g=wu(f,t,n),y=es({inputs:{real:m,imag:g},backend:n});return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let a=n.shouldExecuteOnCPU(e);if(r==="string"&&(a=!0),a){let c=e.map(v=>{let I=[-1,w.sizeFromShape(v.shape.slice(t))];return he({inputs:{x:v},backend:n,attrs:{shape:I}})}),f=c.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),m=T.computeOutShape(c.map(v=>v.shape),1),g=c[0].shape[0]===1,y=KK(f,m,r,g),b=T.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(b,r,y);return c.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let s=e.filter(c=>w.sizeFromShape(c.shape)>0),i=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let c=i?new zr(e[0].shape,Ia):new _a(e[0].shape,Ia);return n.runWebGLProgram(c,e,r)}let o=j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let c=[];for(let m=0;m<s.length;m+=o){let g=s.slice(m,m+o);c.push(wu(g,t,n))}let f=wu(c,t,n);for(let m of c)n.disposeIntermediateTensorInfo(m);return f}if(i){let c=new eZ(s.map(f=>f.shape),t);return n.runWebGLProgram(c,s,r)}let{tensors2D:l,outShape:p}=nZ(s,t,n),u=new Q7(l.map(c=>c.shape)),h=n.runWebGLProgram(u,l,r);l.forEach(c=>n.disposeIntermediateTensorInfo(c));let d=he({inputs:{x:h},attrs:{shape:p},backend:n});return n.disposeIntermediateTensorInfo(h),d}function nZ(e,t,n){let r=T.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>he({inputs:{x:a},attrs:{shape:[-1,w.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function N2(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(p=>p.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(p=>p.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(p=>w.sizeFromShape(p.shape)>0);return l.length===1?Hn({inputs:{x:l[0]},backend:n}):wu(l,s,n)}var rZ={kernelName:Vo,backendName:"webgl",kernelFunc:N2},T2=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,c=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,b=m?3:1,x="",v="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${c}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${c}) *
                    getW(wR, wC, ${c}, d2);
              } else {
                dotProd +=
                    getX(batch, ${c}, xR, xC) *
                    getW(wR, wC, ${c}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2),
                getW(wR, wC, ${c} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1),
                  getX(batch, xR, xC, ${c} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC),
                  getX(batch, ${c} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${v}
        setOutput(result);
      }
    `}},aZ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,c=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${c}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${c}) *
                  getW(wF, wR, wC, ${c}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1),
                  getX(batch, xF, xR, xC, ${c} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2),
                  getW(wF, wR, wC, ${c} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},C2=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,u=p,h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<p;m++)h+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;h+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<p;m++)h+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){let g=m*2;if(h+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<p&&(s%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?h+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<p)){let y=s%2===0?w.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:h+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?h+=`
                     xC${g+1} = xTexelC${g};
                     `:h+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<p&&(s%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<p&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<p&&(h+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<p&&(h+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<p&&(h+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let d="",c="";n&&(r?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,c="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${c}
         setOutput(result);
       }
     `}},sZ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=kn(this.outputShape.length);let{dataFormat:n}=t,r=vn(),a=n==="channelsLast",s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)l+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${p};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function pd(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function _2({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,p=r.texData.get(e.dataId),u=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,c=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(s!=null){let b=pd(s.shape,c);b!=null&&(s=he({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(a!=null){let b=pd(a.shape,c);b!=null&&(a=he({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(!((h===1||d===1)&&u>w2)&&p.isPacked&&c&&p.texture!=null&&l[2]%2!==0&&w.arraysEqual(p.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},v=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,w.assert(Bu(p.shape,x.shape),()=>`packed reshape ${p.shape} to ${x.shape} isn't free`);let I=he({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(I);let N=ud({a:x,b:I,backend:r,transposeA:f,transposeB:m,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),C=r.texData.get(N.dataId);w.assert(C.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=v,C.shape=n.outShape,g=Hn({inputs:{x:N},backend:r}),g.shape=n.outShape,y.push(N)}else{let b=n.outHeight*n.outWidth,x=he({inputs:{x:e},backend:r,attrs:{shape:c?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),v=he({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=ud({a:c?x:v,b:c?v:x,transposeA:!c,transposeB:m,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=he({inputs:{x:I},backend:r,attrs:{shape:n.outShape}}),y.push(x),y.push(v),y.push(I)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function E2({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:p,inChannels:u,outWidth:h,outHeight:d,dataFormat:c}=n,f=c==="channelsLast",m=l*p*u,g=d*h,y=[n.batchSize,m,g],b=!0,x=!1,v=[];if(s!=null){let H=pd(s.shape,f);H!=null&&(s=he({inputs:{x:s},backend:r,attrs:{shape:H}}),v.push(s))}if(a!=null){let H=pd(a.shape,f);H!=null&&(a=he({inputs:{x:a},backend:r,attrs:{shape:H}}),v.push(a))}let I=he({inputs:{x:t},backend:r,attrs:{shape:[1,m,w.sizeFromShape(t.shape)/m]}});v.push(I);let N=new sZ(y,n),C=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(N,[e],"float32",C),A=he({inputs:{x:E},backend:r,attrs:{shape:y}});v.push(E),v.push(A);let F=a!=null,R=s!=null,S=o==="leakyrelu",M=o?Wu(o,!0):null,B=new x2(f?A.shape:I.shape,f?I.shape:A.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,F,M,R,S),U=f?[A,I]:[I,A];if(a&&U.push(a),R&&U.push(s),S){let H=r.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));U.push(H),v.push(H)}let G=r.runWebGLProgram(B,U,"float32"),K=he({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});v.push(G);for(let H of v)r.disposeIntermediateTensorInfo(H);return K}function iZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:p,dimRoundingMode:u}=r,h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!1,h),c;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))c=_2({x:a,filter:s,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){let m=new C2(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];c=n.runWebGLProgram(m,[a,s],"float32",g)}else if(j().getBool("WEBGL_CONV_IM2COL"))c=E2({x:a,filter:s,convInfo:d,backend:n});else{let m=new T2(d);c=n.runWebGLProgram(m,[a,s],"float32")}let f=he({inputs:{x:c},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(c),f}var oZ={kernelName:qs,backendName:"webgl",kernelFunc:iZ},lZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${s}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},uZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,p=s?2:3,u=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},pZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},hZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function dZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:u}=r,h=T.convertConv2DDataFormat(l),d=T.computeConv2DInfo(a.shape,u,i,1,o,p,!1,h),c=new lZ(d);return n.runWebGLProgram(c,[a,s],"float32")}var cZ={kernelName:Cd,backendName:"webgl",kernelFunc:dZ};function fZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:p,dimRoundingMode:u}=r,h=T.convertConv2DDataFormat(p),d=T.computeConv2DInfo(i,s.shape,o,1,l,u,!1,h),c=new uZ(d);return n.runWebGLProgram(c,[a,s],"float32")}var mZ={kernelName:Ks,backendName:"webgl",kernelFunc:fZ};function gZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,p=T.computeConv3DInfo(a.shape,s.shape,i,l,o),u=new aZ(p);return n.runWebGLProgram(u,[a,s],"float32")}var yZ={kernelName:Xu,backendName:"webgl",kernelFunc:gZ};function bZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,p=T.computeConv3DInfo(a.shape,l,i,1,o),u=new pZ(p);return n.runWebGLProgram(u,[a,s],"float32")}var xZ={kernelName:_d,backendName:"webgl",kernelFunc:bZ};function wZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,p=T.computeConv3DInfo(l,s.shape,o,1,i),u=new hZ(p);return n.runWebGLProgram(u,[a,s],"float32")}var vZ={kernelName:Ed,backendName:"webgl",kernelFunc:wZ},kZ=Ql+`
  return cos(x);
`,IZ=qe({opSnippet:kZ}),SZ={kernelName:Xs,backendName:"webgl",kernelFunc:IZ},NZ=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,TZ=qe({opSnippet:NZ}),CZ={kernelName:Zs,backendName:"webgl",kernelFunc:TZ},_Z=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[p]=t,[u,h]=n;this.outputShape=[p,u,h,l];let d=r==="bilinear"?1:0,[c,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${c} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${c}`],[b,x,v]=h>1?[`${(o-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${c} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},EZ=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:p}=r,u=new _Z(a.shape,s.shape,o,l,p);return n.runWebGLProgram(u,[a,s,i],"float32")},$Z={kernelName:Go,backendName:"webgl",kernelFunc:EZ},Uu;(function(e){e.Prod="*",e.Sum="+"})(Uu||(Uu={}));var Tv=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===Uu.Prod?"1.0":"0.0",i=n?s:`getX(${Cv(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",p="";n?(l=r?`end != ${o-1}`:"end != 0",p=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",p=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${pt(a)} coords = getOutputCoords();
        int end = ${_v(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${p};
          ${_v(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${Cv(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Cv(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function _v(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function $2(e,t,n,r,a,s){let i=t.shape.length,o=T.getAxesPermutation([r],i),l=t;o!=null&&(l=mn({inputs:{x:t},backend:n,attrs:{perm:o}}));let p=T.getInnerMostAxes(1,i)[0];if(p!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let u=l.shape[p],h=Hn({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){let c=new Tv(e,l.shape,!1,s),f=[[d]],m=h;h=n.runWebGLProgram(c,[h],h.dtype,f),n.disposeIntermediateTensorInfo(m)}if(a){let d=new Tv(e,l.shape,a,s),c=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(c)}if(o!=null){let d=T.getUndoAxesPermutation(o),c=mn({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),c}return h}function AZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return $2(Uu.Prod,a,n,s,i,o)}var RZ={kernelName:Uo,backendName:"webgl",kernelFunc:AZ};function FZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return $2(Uu.Sum,a,n,s,i,o)}var DZ={kernelName:Js,backendName:"webgl",kernelFunc:FZ};function MZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.readSync(a.dataId),p=n.readSync(s.dataId),u=u2(l,p,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),p=n.bufferSync(s),u=HK(l,p,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var OZ={kernelName:$d,backendName:"webgl",kernelFunc:MZ},LZ=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function zZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],p=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=p*s,c=u/(s*s),f=i==="NHWC"?[o,h,d,c]:[o,c,h,d],m=new LZ(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var PZ={kernelName:Ho,backendName:"webgl",kernelFunc:zZ},A2=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",p="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${p}
        setOutput(result);
      }
    `}},R2=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,u=e.filterWidth,h=u,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)d+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;d+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let g=0;g<u;g++)d+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(h+1)/2;g++){let y=g*2;if(d+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<u&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?d+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<u)){let b=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:d+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?d+=`
                    xC${y+1} = xTexelC${y};
                    `:d+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<u&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<u&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<u&&(d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<u&&(d+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<u&&(d+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let c="",f="";n&&(r?c=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?c=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:c=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function BZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:p}=r,u=l;u==null&&(u=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let h=T.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!0),d;j().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new R2(h):d=new A2(h);let c=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",c)}var WZ={kernelName:Ys,backendName:"webgl",kernelFunc:BZ},VZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},UZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function GZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,filterShape:u}=r,h=T.computeConv2DInfo(a.shape,u,i,o,l,p,!0),d=new VZ(h);return n.runWebGLProgram(d,[a,s],"float32")}var HZ={kernelName:Ad,backendName:"webgl",kernelFunc:GZ};function jZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,inputShape:u}=r,h=T.computeConv2DInfo(u,s.shape,i,o,l,p,!0),d=new UZ(h);return n.runWebGLProgram(d,[a,s],"float32")}var qZ={kernelName:Rd,backendName:"webgl",kernelFunc:jZ},KZ=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function XZ(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=w.sizeFromShape(r.shape),i=he({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new KZ(s),l=n.runWebGLProgram(o,[i],i.dtype),p=he({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),p}var ZZ={kernelName:Fd,backendName:"webgl",kernelFunc:XZ},JZ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:p}=e,{top:u,left:h}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${u}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function YZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,p=T.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u,h=new JZ(p);u=n.runWebGLProgram(h,[a,s],"float32");let d=he({inputs:{x:u},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(u),d}var QZ={kernelName:Zu,backendName:"webgl",kernelFunc:YZ};function eJ(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(a,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:p,steps:u}=T.getEinsumComputePath(o,l),h=u.length,d=null,c=i.length,f=[];for(let m=0;m<h;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=T.getEinsumPermutation(c,l[g]),x;T.isIdentityPermutation(y)?x=s[g]:(x=mn({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=he({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),d===null?d=x:(d=kx({inputs:{a:x,b:d},backend:n}),f.push(d))}m<h-1&&(p[m]>=0&&(d=af({inputs:{x:d},backend:n,attrs:{axis:p[m]-(i.length-c),keepDims:!1}}),f.push(d)),c--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var tJ={kernelName:Dd,backendName:"webgl",kernelFunc:eJ},nJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",rJ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,aJ=qe({opSnippet:nJ,packedOpSnippet:rJ}),sJ={kernelName:ei,backendName:"webgl",kernelFunc:aJ},iJ="return (b >= 1.0) ? a : a * (b + 1.0);",oJ=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,lJ=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Up(oJ,r.shape,a.shape):new _o(iJ,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},uJ={kernelName:Md,backendName:"webgl",kernelFunc:lJ},pJ=`
  return vec4(equal(a, b));
`,hJ="return float(a == b);",dJ=tn({opSnippet:hJ,packedOpSnippet:pJ,dtype:"bool",cpuKernelImpl:XK}),cJ={kernelName:qo,backendName:"webgl",kernelFunc:dJ},fJ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${T.ERF_P};
  float a1 = ${T.ERF_A1};
  float a2 = ${T.ERF_A2};
  float a3 = ${T.ERF_A3};
  float a4 = ${T.ERF_A4};
  float a5 = ${T.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,mJ=qe({opSnippet:fJ}),gJ={kernelName:jo,backendName:"webgl",kernelFunc:mJ},yJ=Ql+`
  return exp(x);
`,bJ=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,F2=qe({opSnippet:yJ,packedOpSnippet:bJ,cpuKernelImpl:ZK,dtype:"float32"}),xJ={kernelName:ti,backendName:"webgl",kernelFunc:F2};function Cm(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(w.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),he({inputs:{x:s},backend:r,attrs:{shape:o}})}var wJ={kernelName:Ko,backendName:"webgl",kernelFunc:Cm},Ev="return exp(x) - 1.0;",vJ=qe({opSnippet:Ev,packedOpSnippet:Ev,cpuKernelImpl:JK}),kJ={kernelName:Xo,backendName:"webgl",kernelFunc:vJ},$v=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function D2(e,t,n){let r=n.texData.get(e.dataId),a=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=he({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,p=new $v("real",l,t),u=new $v("imag",l,t),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(p,h,"float32"),c=n.runWebGLProgram(u,h,"float32"),f=es({inputs:{real:d,imag:c},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c);let m=he({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function IJ(e){let{inputs:t,backend:n}=e,{input:r}=t;return D2(r,!1,n)}var SJ={kernelName:Od,backendName:"webgl",kernelFunc:IJ},NJ=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Hp(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||w.inferDtype(a),s==="string"){let i=w.getArrayFromDType(s,w.sizeFromShape(r));return i.fill(a),t.makeTensorInfo(r,s,i)}else{let i=new NJ(r,a),o=[[a]];return t.runWebGLProgram(i,[],s,o)}}var TJ={kernelName:Ju,backendName:"webgl",kernelFunc:Hp},CJ=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},_J={kernelName:Zo,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new CJ(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},Av="return floor(x);",EJ=qe({opSnippet:Av,packedOpSnippet:Av,cpuKernelImpl:YK}),$J={kernelName:ni,backendName:"webgl",kernelFunc:EJ},AJ=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,RJ=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,FJ=tn({opSnippet:AJ,packedOpSnippet:RJ,dtype:"int32"}),DJ={kernelName:ri,backendName:"webgl",kernelFunc:FJ},MJ=class{constructor(e){this.variableNames=["A"];let t=vn(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},OJ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=vn(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},LJ={kernelName:Bh,backendName:"webgl",kernelFunc:zJ},to,Af=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function zJ(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[l,p]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[p,l],h=[p,l,s];if(o||i){let m=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(to==null||m!==Af)&&(Af=m,to=document.createElement("canvas").getContext("2d",{willReadFrequently:Af})),to.canvas.width=l,to.canvas.height=p,to.drawImage(a,0,0,l,p),a=to.canvas}let d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=Jn.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let c=j().getBool("WEBGL_PACK")?new OJ(h):new MJ(h),f=n.runWebGLProgram(c,[d],"int32");return n.disposeData(d.dataId),f}function PJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:h,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=r,m=T.convertConv2DDataFormat(u),g=T.computeConv2DInfo(a.shape,s.shape,l,h,p,d,!1,m),y,b=[],x=i!=null,v=o!=null,I=c==="leakyrelu",N=()=>{let E=[a,s],A=(F,R)=>{if(R==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){let S=he({inputs:{x:F},backend:n,attrs:{shape:[F.shape[0],1,1]}});return b.push(S),S}return F};if(x&&E.push(A(i,u)),v&&E.push(A(o,u)),I){let F=n.makeTensorInfo([],"float32",w.createScalarValue(f,"float32"));E.push(F),b.push(F)}return E};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=_2({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&j().getBool("WEBGL_EXP_CONV")){let E=c?Wu(c,!0):null,A=new C2(g,x,E,v,I),F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],R=N();y=n.runWebGLProgram(A,R,"float32",F)}else if(j().getBool("WEBGL_CONV_IM2COL"))y=E2({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:f});else{let E=c?Wu(c,!1):null,A=new T2(g,x,E,v,I),F=N();y=n.runWebGLProgram(A,F,"float32")}let C=he({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(E=>n.disposeIntermediateTensorInfo(E)),C}var BJ={kernelName:Is,backendName:"webgl",kernelFunc:PJ};function WJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:c}=r,f=[],m=u;m==null&&(m=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=T.computeConv2DInfo(a.shape,s.shape,l,m,p,h,!0),y=j().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?Wu(d,y):null,x=[a,s],v=i!=null,I=o!=null,N=d==="leakyrelu";if(v&&x.push(i),I&&x.push(o),N){let F=n.makeTensorInfo([],"float32",w.createScalarValue(c,"float32"));x.push(F),f.push(F)}let C;y?C=new R2(g,v,b,I,N):C=new A2(g,v,b,I,N);let E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=n.runWebGLProgram(C,x,"float32",E);return f.forEach(F=>n.disposeIntermediateTensorInfo(F)),A}var VJ={kernelName:Ss,backendName:"webgl",kernelFunc:WJ},UJ=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=pt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function GJ(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=w.sizeFromShape(r.shape),[l,p,u,h]=T.prepareAndValidate(r,a),d=he({inputs:{x:a},backend:n,attrs:{shape:[p,i]}}),c=he({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){let y=n.readSync(a.dataId),b=n.bufferSync(r),x=QK(y,b,r.dtype,p,i,u,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}let f=new UJ(i,h,[p,u],r.shape),m=n.runWebGLProgram(f,[c,d],c.dtype),g=he({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),g}var HJ={kernelName:Yo,backendName:"webgl",kernelFunc:GJ},jJ=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=pt(this.rank),r=qJ(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function qJ(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)a===2?r.push("index"):r.push(`${n[a]}`);return r.join()}function M2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0];if(j().get("DEBUG")){let b=n.readSync(s.dataId),x=a.shape[l];for(let v=0;v<b.length;++v){let I=b[v];w.assert(I<=x-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${x-1}]`)}}let p=T.segment_util.collectGatherOpShapeInfo(a,s,l,o),u=w.sizeFromShape(s.shape),h=[],d=he({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),c=he({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,u/p.batchSize]}});h.push(d),h.push(c);let f=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){let b=n.bufferSync(c),x=n.bufferSync(d),v=e8(x,b,f);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(p.outputShape,v.dtype,v.values)}let m=new jJ(d.shape,f),g=n.runWebGLProgram(m,[d,c],d.dtype);h.push(g);let y=he({inputs:{x:g},backend:n,attrs:{shape:p.outputShape}});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var KJ={kernelName:Jo,backendName:"webgl",kernelFunc:M2},XJ="return float(a > b);",ZJ=`
  return vec4(greaterThan(a, b));
`,JJ=tn({opSnippet:XJ,packedOpSnippet:ZJ,cpuKernelImpl:t8,dtype:"bool"}),YJ={kernelName:Qo,backendName:"webgl",kernelFunc:JJ},QJ="return float(a >= b);",e9=`
  return vec4(greaterThanEqual(a, b));
`,t9=tn({opSnippet:QJ,packedOpSnippet:e9,dtype:"bool",cpuKernelImpl:n8}),n9={kernelName:si,backendName:"webgl",kernelFunc:t9};function r9(e){let{inputs:t,backend:n}=e,{input:r}=t;return D2(r,!0,n)}var a9={kernelName:Ld,backendName:"webgl",kernelFunc:r9},s9="return float(!isnan(x) && !isinf(x));",i9=qe({opSnippet:s9,dtype:"bool"}),o9={kernelName:el,backendName:"webgl",kernelFunc:i9},l9="return float(isinf(x));",u9=qe({opSnippet:l9,dtype:"bool"}),p9={kernelName:tl,backendName:"webgl",kernelFunc:u9},h9="return float(isnan(x));",d9=qe({opSnippet:h9,dtype:"bool"}),c9={kernelName:oi,backendName:"webgl",kernelFunc:d9},f9="return float(a < b);",m9=`
  return vec4(lessThan(a, b));
`,g9=tn({opSnippet:f9,packedOpSnippet:m9,cpuKernelImpl:r8,dtype:"bool"}),y9={kernelName:nl,backendName:"webgl",kernelFunc:g9},b9="return float(a <= b);",x9=`
  return vec4(lessThanEqual(a, b));
`,w9=tn({opSnippet:b9,packedOpSnippet:x9,cpuKernelImpl:a8,dtype:"bool"}),v9={kernelName:rl,backendName:"webgl",kernelFunc:w9};function k9(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=s8(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var I9={kernelName:Pd,backendName:"webgl",kernelFunc:k9},S9=Ql+`
  return x < 0.0 ? 0./0. : log(x);
`,N9=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,T9=qe({opSnippet:S9,packedOpSnippet:N9,cpuKernelImpl:i8}),C9={kernelName:ui,backendName:"webgl",kernelFunc:T9},_9=Ql+`
  return log(1.0 + x);
`,E9=qe({opSnippet:_9}),$9={kernelName:al,backendName:"webgl",kernelFunc:E9},A9="return float(a >= 1.0 && b >= 1.0);",R9=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,F9=tn({opSnippet:A9,packedOpSnippet:R9,dtype:"bool"}),D9={kernelName:sl,backendName:"webgl",kernelFunc:F9},M9="return float(!(x >= 1.0));",O9=qe({opSnippet:M9}),L9={kernelName:il,backendName:"webgl",kernelFunc:O9},z9="return float(a >= 1.0 || b >= 1.0);",P9=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,B9=tn({opSnippet:z9,packedOpSnippet:P9,dtype:"bool"}),W9={kernelName:ol,backendName:"webgl",kernelFunc:B9},V9=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},U9=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},G9=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,p=j().getBool("WEBGL_PACK_NORMALIZATION")?new U9(a.shape,s,i,o,l):new V9(a.shape,s,i,o,l);return n.runWebGLProgram(p,[a],a.dtype)},H9={kernelName:Yu,backendName:"webgl",kernelFunc:G9},j9=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},q9=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:p,beta:u}=r,h=new j9(a.shape,o,l,p,u);return n.runWebGLProgram(h,[a,s,i],a.dtype)},K9={kernelName:Bd,backendName:"webgl",kernelFunc:q9};function X9(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=he({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Xi(i,e.dtype,"max",r),l=he({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function O2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=T.getAxesPermutation(p,o),h=u!=null,d=n.shouldExecuteOnCPU([a]),c=a;if(h){if(d){let b=n.texData.get(c.dataId).values,x=new Array(o);for(let N=0;N<x.length;N++)x[N]=a.shape[u[N]];let v=wx(b,a.shape,a.dtype,u,x);c=n.makeTensorInfo(x,a.dtype);let I=n.texData.get(c.dataId);I.values=v}else c=rf(a,u,n);p=T.getInnerMostAxes(p.length,o)}T.assertAxesAreInnerMostDims("max",p,o);let[f,m]=T.computeOutAndReduceShapes(c.shape,p),g=f;i&&(g=T.expandShapeToKeepDim(f,l));let y;if(d){let b=n.texData.get(c.dataId).values,x=o8(b,w.sizeFromShape(m),g,a.dtype);y=n.makeTensorInfo(g,a.dtype);let v=n.texData.get(y.dataId);v.values=x}else y=X9(c,m,g,n);return h&&n.disposeIntermediateTensorInfo(c),y}var Z9={kernelName:pi,backendName:"webgl",kernelFunc:O2},J9=vx+`
  return max(a, b);
`,Y9=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vp+`
  return result;
`,Q9=tn({opSnippet:J9,packedOpSnippet:Y9,cpuKernelImpl:l8}),eY={kernelName:hi,backendName:"webgl",kernelFunc:Q9};function tY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Kl(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=T.computePool2DInfo(a.shape,s,i,p,o,l);if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))return Hn({inputs:{x:a},backend:n});let h=new Vu(u,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}var nY={kernelName:di,backendName:"webgl",kernelFunc:tY};function rY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:p}=r,u=[1,1,1],h=T.computePool3DInfo(a.shape,s,i,u,o,p,l),d=new Ix(h,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var aY={kernelName:Qu,backendName:"webgl",kernelFunc:rY},sY=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},iY=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=p-1-e.padInfo.left,c=o*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${c} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function oY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:u}=r,h=[1,1,1],d=T.computePool3DInfo(i.shape,o,l,h,p,u),c=new Ix(d,"max",!0),f=n.runWebGLProgram(c,[i],i.dtype),m=new iY(d),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var lY={kernelName:Vd,backendName:"webgl",kernelFunc:oY};function uY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Kl([s,i],"maxPoolGrad");let{filterSize:l,strides:p,pad:u,dimRoundingMode:h}=r,d=T.computePool2DInfo(o.shape,l,p,1,u,h),c=!0,f=new Vu(d,"max",c),m=n.runWebGLProgram(f,[o],o.dtype),g=new sY(d),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var pY={kernelName:Wd,backendName:"webgl",kernelFunc:uY};function hY(e,t,n,r){let a=new Vu(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new Vu(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var dY={kernelName:Ud,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let p=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(s,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);let u=T.computePool2DInfo(r.shape,a,s,p,i),[h,d]=hY(r,o,u,l);return[h,d]}};function cY(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=he({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Xi(i,"float32","mean",r),l=he({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var fY={kernelName:ci,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=w.parseAxisParam(s,r.shape),p=l,u=T.getAxesPermutation(p,o),h=u!=null,d=i.shouldExecuteOnCPU([r]),c=[],f=r;if(h){if(d){let x=i.texData.get(f.dataId).values,v=new Array(o);for(let C=0;C<v.length;C++)v[C]=r.shape[u[C]];let I=wx(x,r.shape,r.dtype,u,v);f=i.makeTensorInfo(v,r.dtype);let N=i.texData.get(f.dataId);N.values=I}else f=rf(r,u,i);c.push(f),p=T.getInnerMostAxes(p.length,o)}T.assertAxesAreInnerMostDims("sum",p,o);let[m,g]=T.computeOutAndReduceShapes(f.shape,p),y=m;a&&(y=T.expandShapeToKeepDim(m,l));let b=cY(f,g,y,i);for(let x of c)i.disposeIntermediateTensorInfo(x);return b}};function mY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=T.getAxesPermutation(p,o),h=a;u!=null&&(h=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=T.getInnerMostAxes(p.length,a.shape.length)),T.assertAxesAreInnerMostDims("min",p,o);let[d,c]=T.computeOutAndReduceShapes(h.shape,p),f=w.sizeFromShape(c),m=he({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}}),g=Xi(m,m.dtype,"min",n),y;if(i){let b=T.expandShapeToKeepDim(d,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(h),y}var gY={kernelName:fi,backendName:"webgl",kernelFunc:mY},yY=vx+`
  return min(a, b);
`,bY=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vp+`
  return result;
`,xY=tn({opSnippet:yY,packedOpSnippet:bY,cpuKernelImpl:u8}),wY={kernelName:mi,backendName:"webgl",kernelFunc:xY},vY=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((p,u)=>p[0]+e[u]+p[1]);let r=e.length,a=pt(r),s=t.map(p=>p[0]).join(","),i=t.map((p,u)=>p[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},kY=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((c,f)=>c[0]+e[f]+c[1]);let r=e.length,a=pt(r),s=t.map(c=>c[0]).join(","),i=t.map((c,f)=>c[0]+e[f]).join(","),o=hn("rc",r),l=hn("source",r),p=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,h=n==="reflect"?0:1,d="";if(r===1){let c=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${p}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
      `}else{let c=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;d=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${p}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${c}
          result[2] = getChannel(getX(${l.join()}), ${u});
          ${o[r-1]} += 1;
          if(${p}) {
            ${c}
            result[3] = getChannel(getX(${l.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}},IY=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kY(r.shape,a,s):new vY(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},SY={kernelName:gi,backendName:"webgl",kernelFunc:IY},NY=`if (b == 0.0) return NAN;
  return mod(a, b);`,TY=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vp+`
  return result;
`,CY=tn({opSnippet:NY,packedOpSnippet:TY}),_Y={kernelName:ll,backendName:"webgl",kernelFunc:CY},EY=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},$Y=`
if (a == b) {
  return 1.0;
};
return a / b;`,AY=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,L2=tn({opSnippet:$Y,packedOpSnippet:AY,checkOutOfBounds:!0}),RY={kernelName:Qs,backendName:"webgl",kernelFunc:L2},Rv="return a - b;",z2=tn({opSnippet:Rv,packedOpSnippet:Rv,supportsComplex:!0,cpuKernelImpl:E8}),FY={kernelName:Li,backendName:"webgl",kernelFunc:z2};function P2(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=w.parseAxisParam([s],a.shape),o=O2({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=T.expandShapeToKeepDim(o.shape,i),p=he({inputs:{x:o},backend:n,attrs:{shape:l}}),u=z2({inputs:{a,b:p},backend:n}),h=F2({inputs:{x:u},backend:n}),d=af({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),c=he({inputs:{x:d},backend:n,attrs:{shape:l}}),f=L2({inputs:{a:h,b:c},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),f}var DY={kernelName:Mi,backendName:"webgl",kernelFunc:P2};function MY(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:P2({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),p=l.shape[0],u=l.shape[1],h=new EY(p,u,s),d=[[i]],c=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),c}var OY={kernelName:Gd,backendName:"webgl",kernelFunc:MY},LY=yr+`
  return -x;
`,zY=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function PY(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[i,o]=h8(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let a;return j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new _a(r.shape,zY):a=new zr(r.shape,LY),n.runWebGLProgram(a,[r],r.dtype)}var BY={kernelName:ul,backendName:"webgl",kernelFunc:PY},WY=qr.nonMaxSuppressionV3Impl;function VY(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,p=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=WY(p,u,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}var UY={kernelName:hl,backendName:"webgl",kernelFunc:VY},GY=qr.nonMaxSuppressionV4Impl;function HY(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:c}=GY(u,h,i,o,l,p);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var jY={kernelName:dl,backendName:"webgl",kernelFunc:HY},qY=qr.nonMaxSuppressionV5Impl;function KY(e){T.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r,u=n.readSync(a.dataId),h=n.readSync(s.dataId),d=i,c=o,f=l,m=p,{selectedIndices:g,selectedScores:y}=qY(u,h,d,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var XY={kernelName:cl,backendName:"webgl",kernelFunc:KY},ZY=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},JY=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,p=w.sizeFromShape(a.shape),u=new ZY(p,i,o,l),h=he({inputs:{x:a},backend:n,attrs:{shape:[p]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);let c=[...a.shape,i],f=he({inputs:{x:d},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),f},YY={kernelName:bi,backendName:"webgl",kernelFunc:JY};function hd(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let a=Gp({inputs:{input:r},backend:n}),s=hd({inputs:{x:a},backend:n}),i=sf({inputs:{input:r},backend:n}),o=hd({inputs:{x:i},backend:n}),l=es({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Hp({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var QY={kernelName:Al,backendName:"webgl",kernelFunc:hd};function B2(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let a=Gp({inputs:{input:r},backend:n}),s=B2({inputs:{x:a},backend:n}),i=sf({inputs:{input:r},backend:n}),o=hd({inputs:{x:i},backend:n}),l=es({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Hp({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var eQ={kernelName:fl,backendName:"webgl",kernelFunc:B2};function tQ(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return Cm({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=Cm({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),p=N2({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),p}var nQ={kernelName:ml,backendName:"webgl",kernelFunc:tQ},rQ=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let r=e.length,a=pt(r),s=t.map(l=>l[0]).join(","),i=t.map((l,p)=>l[0]+e[p]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},aQ=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,a=pt(r),s=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=hn("rc",r),l=hn("source",r),p=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${p}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${p}) {`],d=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",c="";for(let f=0,m=r===1?2:4;f<m;f++)c+=`
        ${h[f]}
        if (${d}) {
          result[${f}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${u});
        }
      `;c+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${c}
        setOutput(result);
      }
    `}},W2=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(w.sizeFromShape(a.shape)===0){let p=s.map((u,h)=>u[0]+a.shape[h]+u[1]);return Hp({backend:n,attrs:{shape:p,value:i,dtype:a.dtype}})}let o=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aQ(a.shape,s,i):new rQ(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},sQ={kernelName:xi,backendName:"webgl",kernelFunc:W2},iQ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,oQ=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vp+`
  return result;
`,lQ=tn({opSnippet:iQ,packedOpSnippet:oQ}),uQ={kernelName:wi,backendName:"webgl",kernelFunc:lQ};function pQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],p=w.parseAxisParam(s,a.shape),u=p,h=T.getAxesPermutation(u,o),d=a;h!=null&&(d=mn({inputs:{x:a},backend:n,attrs:{perm:h}}),u=T.getInnerMostAxes(u.length,o),l.push(d)),T.assertAxesAreInnerMostDims("prod",u,o);let c;if(n.shouldExecuteOnCPU([d])){let f=n.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=c8(d.shape,d.dtype,f,u);c=n.makeTensorInfo(g,y,m)}else{let[f,m]=T.computeOutAndReduceShapes(d.shape,u),g=w.sizeFromShape(m),y=he({inputs:{x:d},backend:n,attrs:{shape:[-1,g]}}),b=tc(a.dtype),x=Xi(y,b,"prod",n);c=he({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(c);let f=T.expandShapeToKeepDim(c.shape,p);c=he({inputs:{x:c},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),c}var hQ={kernelName:ki,backendName:"webgl",kernelFunc:pQ};function dQ(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.readSync(y.dataId)),p=a.map(y=>y.shape),u=n.readSync(s.dataId),h=n.readSync(i.dataId),[d,c,f]=f8(l,p,u,s.shape,s.dtype,h,i.shape,o),m=d.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}var cQ={kernelName:Hd,backendName:"webgl",kernelFunc:dQ};function fQ(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=m8(i,r.shape,r.dtype,o,a.shape,l,s.shape),h=n.makeTensorInfo([p.length],"int32",p),d=n.makeTensorInfo([u.length],r.dtype,u);return[h,d]}var mQ={kernelName:jd,backendName:"webgl",kernelFunc:fQ};function gQ(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=n.readSync(a.dataId),u=n.readSync(s.dataId),h=n.readSync(i.dataId),d=o.map(g=>n.readSync(g.dataId)),c=o.map(g=>g.shape),[f,m]=g8(p,a.shape,u,s.shape,s.dtype,h,i.shape,d,c,l);return n.makeTensorInfo(f,s.dtype,m)}var yQ={kernelName:qd,backendName:"webgl",kernelFunc:gQ},V2=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=y8(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},bQ={kernelName:ep,backendName:"webgl",kernelFunc:V2},xQ="return 1.0 / x;",wQ=qe({opSnippet:xQ}),vQ={kernelName:Ii,backendName:"webgl",kernelFunc:wQ},kQ=yr+`
  return (x < 0.0) ? 0.0 : x;
`,IQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,SQ=qe({opSnippet:kQ,packedOpSnippet:IQ}),NQ={kernelName:Si,backendName:"webgl",kernelFunc:SQ},TQ=yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,CQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_Q=qe({opSnippet:TQ,packedOpSnippet:CQ}),EQ={kernelName:Ci,backendName:"webgl",kernelFunc:_Q},$Q=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/u[0]},
          ${p[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},AQ=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/u[0]},
          ${p[1]/u[1]},
          ${p[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function RQ(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AQ(a.shape,l,p,s,i):new $Q(a.shape,l,p,s,i);return n.runWebGLProgram(u,[a],"float32")}var FQ={kernelName:Ti,backendName:"webgl",kernelFunc:RQ},DQ=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],p=o[0]/l[0],u=o[1]/l[1],h=1/p,d=1/u,c=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function MQ(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new DQ(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var OQ={kernelName:Zd,backendName:"webgl",kernelFunc:MQ},LQ=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/u[0]},
          ${p[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},zQ=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0",d;a?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/u[0]},
          ${p[1]/u[1]},
          ${p[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function PQ(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zQ(a.shape,l,p,s,i):new LQ(a.shape,l,p,s,i);return n.runWebGLProgram(u,[a],a.dtype)}var BQ={kernelName:Ni,backendName:"webgl",kernelFunc:PQ},WQ=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],p=o[0]/l[0],u=o[1]/l[1],h=1/p,d=1/u,c=Math.ceil(h)*2+2,f=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${d});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function VQ(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new WQ(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var UQ={kernelName:Xd,backendName:"webgl",kernelFunc:VQ},GQ=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,o)=>r(o)).join(","),s=pt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}},HQ=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=hn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=pt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${p(r.slice())};
            if(${a}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(c){return h(c)}function l(c){return c[n-1]="("+c[n-1]+" + 1)",h(c)}function p(c){return c[n-2]="("+c[n-2]+" + 1)",h(c)}function u(c){return c[n-1]="("+c[n-1]+" + 1)",c[n-2]="("+c[n-2]+" + 1)",h(c)}function h(c){let f=e.map((y,b)=>d(b,c)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function d(c,f){return t.indexOf(c)!==-1&&e[c]!==1?`${e[c]} - ${f[c]} - 1`:`${f[c]}`}}};function jQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return Hn({inputs:{x:a},backend:n});let l=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HQ(a.shape,o):new GQ(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var qQ={kernelName:_i,backendName:"webgl",kernelFunc:jQ},KQ=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},XQ={kernelName:Rl,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new KQ(r.shape,s),[p,u]=T.getImageCenter(i,r.shape[1],r.shape[2]),h=[[p,u,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},ZQ=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,JQ=qe({opSnippet:ZQ}),YQ={kernelName:Ei,backendName:"webgl",kernelFunc:JQ},QQ="return inversesqrt(x);",eee=qe({opSnippet:QQ,cpuKernelImpl:b8}),tee={kernelName:$i,backendName:"webgl",kernelFunc:eee},U2=class{constructor(e,t,n,r,a,s,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=pt(a.length),l=pt(s.length),p="";n===1?p="i":n===2&&(p="i, j");let u=`getIndices(${p})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let d=`getUpdates(${h})`,c=t>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${u});
              flattenedIndex += index * ${c};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function nee(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:u,outputSize:h}=T.calculateShapes(s,a,i),d=[h/p,p];if(h===0)return n.makeTensorInfo(i,a.dtype);let c=he({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=he({inputs:{x:s},backend:n,attrs:{shape:[l,p]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new U2(l,o,c.shape.length,f.shape.length,u,d),y=n.runWebGLProgram(g,[f,c,m],f.dtype),b=he({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var ree={kernelName:yl,backendName:"webgl",kernelFunc:nee},aee=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=j().getNumber("WEBGL_VERSION")===2?a:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function see(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new aee(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var iee={kernelName:Jd,backendName:"webgl",kernelFunc:see},oee=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let p=0;p<t.length;p++)l.push(`${i[p]}`),p<e&&o.push(`${i[p]}`);r=o.join(),a=l.join()}let s=pt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};function lee(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new oee(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],tr(a.dtype,s.dtype))}var uee={kernelName:bl,backendName:"webgl",kernelFunc:lee},pee=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${T.SELU_SCALEALPHA};
  float scale = ${T.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,hee=qe({opSnippet:pee}),dee={kernelName:xl,backendName:"webgl",kernelFunc:hee},cee=Ql+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,fee=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mee=qe({opSnippet:cee,packedOpSnippet:fee,cpuKernelImpl:w8}),gee={kernelName:Ri,backendName:"webgl",kernelFunc:mee},yee=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,bee=qe({opSnippet:yee}),xee={kernelName:kl,backendName:"webgl",kernelFunc:bee},wee=Ql+`
  return sin(x);
`,vee=qe({opSnippet:wee}),kee={kernelName:Ai,backendName:"webgl",kernelFunc:vee},Iee=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,See=qe({opSnippet:Iee}),Nee={kernelName:vl,backendName:"webgl",kernelFunc:See},Tee=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Cee=qe({opSnippet:Tee}),_ee={kernelName:Il,backendName:"webgl",kernelFunc:Cee},Eee=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;w.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let p=[],u=W2({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),h=T.getReshaped(u.shape,s,o,!1),d=T.getPermuted(h.length,s.length,!1),c=T.getReshapedPermuted(u.shape,s,o,!1),f=he({inputs:{x:u},backend:n,attrs:{shape:h}}),m=mn({inputs:{x:f},backend:n,attrs:{perm:d}}),g=he({inputs:{x:m},backend:n,attrs:{shape:c}});return p.push(u),p.push(f),p.push(m),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},$ee={kernelName:Sl,backendName:"webgl",kernelFunc:Eee};function Aee(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),p=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[h,d,c,f,m]=k8(o,r.shape,r.dtype,l,a.dtype,p,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Ree={kernelName:tp,backendName:"webgl",kernelFunc:Aee};function Fee(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[p,u,h]=I8(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,p),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}var Dee={kernelName:Tl,backendName:"webgl",kernelFunc:Fee};function Mee(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=h2(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,p)}var Oee={kernelName:np,backendName:"webgl",kernelFunc:Mee};function Lee(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=h2(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,p)}var zee={kernelName:rp,backendName:"webgl",kernelFunc:Lee};function Pee(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:u,strides:h,outputSize:d}=T.calculateShapes(s,a,o),c=!1;if(s.dtype==="string"){let y=n.bufferSync(a),b=n.bufferSync(s),x=w.decodeString(n.readSync(i.dataId)[0]),v=x8(y,b,o,d,u,p,l,h,x,c);return n.makeTensorInfo(o,v.dtype,v.values)}let f=new U2(p,l,a.shape.length,s.shape.length,h,[d,1],c),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=he({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var Bee={kernelName:Yd,backendName:"webgl",kernelFunc:Pee};function Wee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),p=a.shape.length,u=new Array(p).fill(0),h=a.shape.slice();return l.map(d=>{let c=[...h];c[o]=d;let f=eu({inputs:{x:a},backend:n,attrs:{begin:u,size:c}});return u[o]+=d,f})}var Vee={kernelName:Nl,backendName:"webgl",kernelFunc:Wee},Fv="return sqrt(x);",Uee=qe({opSnippet:Fv,packedOpSnippet:Fv,cpuKernelImpl:S8}),Gee={kernelName:Fi,backendName:"webgl",kernelFunc:Uee},Hee="return x * x;",jee=qe({opSnippet:Hee}),qee={kernelName:ap,backendName:"webgl",kernelFunc:jee},Dv="return (a - b) * (a - b);",Kee=tn({opSnippet:Dv,packedOpSnippet:Dv}),Xee={kernelName:Oi,backendName:"webgl",kernelFunc:Kee};function Zee({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=yr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new zr(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var Jee={kernelName:Ka,backendName:"webgl",kernelFunc:Zee},Yee=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=pt(n.length),s=pt(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,p)=>(o++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${o-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Qee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,h,d),I;if(m)I=he({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let C=Lt.computeOutShape(b,x,v),E=eu({inputs:{x:a},backend:n,attrs:{begin:b,size:C}});I=he({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([a])){let C=n.readSync(a.dataId),E=ze(a.shape,a.dtype,C),A=N8(c,E,v,b);I=n.makeTensorInfo(f,a.dtype,A.values)}else{let C=new Yee(b,v,c);I=n.runWebGLProgram(C,[a],a.dtype)}let N=he({inputs:{x:I},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(I),N}var ete={kernelName:Cl,backendName:"webgl",kernelFunc:Qee};function tte(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),c=n.readSync(h.dataId),[f,m]=T8(d,c,a,s,i,o,l,p);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}var nte={kernelName:sp,backendName:"webgl",kernelFunc:tte};function rte(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[p,u,h]=C8(o,l,a),d=u.length;return[n.makeTensorInfo([d,2],"int32",p),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}var ate={kernelName:ip,backendName:"webgl",kernelFunc:rte};function ste(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=_8(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var ite={kernelName:op,backendName:"webgl",kernelFunc:ste},ote="return tan(x);",lte=qe({opSnippet:ote}),ute={kernelName:zi,backendName:"webgl",kernelFunc:lte},pte=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,hte=qe({opSnippet:pte}),dte={kernelName:Pi,backendName:"webgl",kernelFunc:hte},cte=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=pt(this.rank),a=fte(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};function fte(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function G2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){let o=n.readSync(a.dataId),l=a.dtype==="string"?o.map(h=>w.decodeString(h)):o,p=ze(a.shape,a.dtype,l),u=$8(p,s);return n.makeTensorInfo(u.shape,u.dtype,u.values)}let i=new cte(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var mte={kernelName:qa,backendName:"webgl",kernelFunc:G2},gte=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},yte=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function ls(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function Mv(e){let t=1;for(;t<e;)t*=2;return t}function bte(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=j().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=j().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),p=a.shape,u=p[p.length-1];if(n.shouldExecuteOnCPU([a])||u<o||s>l){let A=n.readSync(a.dataId),[F,R]=A8(A,p,a.dtype,s,i);return[n.makeTensorInfo(F.shape,F.dtype,F.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(s===0)return p[p.length-1]=0,[n.makeTensorInfo(p,a.dtype,[]),n.makeTensorInfo(p,"int32",[])];if(u===1)return[a,Hp({attrs:{shape:p,dtype:"int32",value:0},backend:n})];let h=n.texData.get(a.dataId),d=h!==null&&h.isPacked,c=d?n.unpackTensor(a):a,f=w.sizeFromShape(p)/u,m=he({inputs:{x:c},attrs:{shape:[f,u]},backend:n});d&&ls(n,c);let g=Mv(s),y=Mv(u),b=null,x=()=>b===null?[m,m]:[m,b],v=(A,F,R)=>{let S=x(),M=new gte(R),B=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[A],[F]],U=b;b=n.runWebGLProgram(M,S,"int32",B),ls(n,U)};for(let A=1;A<g;A*=2){let F=A*2;for(let R=A;R>=1;R/=2)v(F,R,[f,y])}for(let A=y;A>g;A/=2){let F=x(),R=new yte([f,A/2]),S=[[u],[b===null?1:0],[g]],M=b;b=n.runWebGLProgram(R,F,"int32",S),ls(n,M);let B=g/2,U=B*2;for(let G=B;G>=1;G/=2)v(U,G,b.shape)}let I=b;b=eu({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),ls(n,I);let N=M2({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});ls(n,m);let C=p.slice(0,-1);C.push(s),I=b,b=he({inputs:{x:b},attrs:{shape:C},backend:n}),ls(n,I);let E=N;return N=he({inputs:{x:N},attrs:{shape:C},backend:n}),ls(n,E),[N,b]}var xte={kernelName:_l,backendName:"webgl",kernelFunc:bte},wte=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function vte(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=r,[u,h,d,c]=a.shape,[f,m]=p??[h,d],g=[u,f,m,c],y=new wte(h,d,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var kte={kernelName:El,backendName:"webgl",kernelFunc:vte};function Ite(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Kl(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:p}=R8(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}var Ste={kernelName:Qd,backendName:"webgl",kernelFunc:Ite};function Nte(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],p=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(p[u++]=i.shape[m]);let h=[],d=new Array(o).fill(0),c=i.shape.slice();c[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;let g=eu({inputs:{x:i},backend:n,attrs:{begin:d,size:c}}),y=he({inputs:{x:g},backend:n,attrs:{shape:p}});f[m]=y,h.push(g)}return h.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Tte={kernelName:$l,backendName:"webgl",kernelFunc:Nte},Cte=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",p=Math.floor(n/4)*4,u=n%4,h=`
        sumValue += dot(values, segFilter);
    `,d="";a%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${c}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${p};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${l});
      }
    `}};function _te(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],p=0,u=T.getAxesPermutation([p],o),h=a;u!=null&&(h=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(h),p=T.getInnerMostAxes(1,o)[0]);let d=T.segment_util.computeOutShape(h.shape,p,i),c=w.sizeFromShape([h.shape[p]]),f=he({inputs:{x:h},backend:n,attrs:{shape:[-1,c]}});l.push(f);let m=tc(a.dtype),g=(v,I,N,C,E)=>{let A=v.shape[0],F=v.shape[1],R=T.segment_util.segOpComputeOptimalWindowSize(F,E),S={windowSize:R,inSize:F,batchSize:A,numSegments:E},M=new Cte(S,I),B=n.compileAndRun(M,[v,N],C);if(l.push(B),B.shape[1]===E)return B;let U=V2({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),G=G2({inputs:{x:U},backend:n,attrs:{reps:[F/R]}});return l.push(U),l.push(G),g(B,I,G,C,E)},y=g(f,"unsortedSegmentSum",s,m,i),b=he({inputs:{x:y},backend:n,attrs:{shape:d}}),x=b;if(u!=null){l.push(b);let v=T.getUndoAxesPermutation(u);x=mn({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Ete={kernelName:lp,backendName:"webgl",kernelFunc:_te},$te=[NX,CX,$X,FX,MX,zX,BX,VX,jX,KX,JX,e7,r7,o7,p7,d7,f7,b7,w7,k7,T7,F7,M7,L7,U7,H7,X7,lX,Y7,rZ,oZ,cZ,mZ,yZ,xZ,vZ,SZ,CZ,$Z,RZ,DZ,OZ,PZ,WZ,HZ,qZ,ZZ,QZ,tJ,sJ,uJ,cJ,gJ,xJ,wJ,kJ,SJ,TJ,_J,$J,DJ,LJ,BJ,VJ,HJ,KJ,YJ,n9,oX,a9,tZ,o9,p9,c9,pX,y9,v9,I9,C9,$9,D9,L9,W9,H9,K9,Z9,eY,nY,aY,lY,pY,dY,fY,gY,wY,SY,_Y,OY,cX,BY,UY,jY,XY,P7,YY,eQ,nQ,sQ,uQ,dX,hQ,cQ,mQ,yQ,bQ,B7,RY,vQ,NQ,EQ,mX,FQ,OQ,BQ,UQ,qQ,XQ,YQ,tee,ree,iee,uee,dee,gee,xee,kee,Nee,A7,DY,_ee,$ee,Ree,Dee,Oee,zee,Bee,Vee,Gee,qee,Xee,Jee,ete,nte,ate,ite,FY,kX,ute,dte,mte,xte,kte,IX,Ste,Tte,Ete,QY];for(let e of $te)up(e);var vt;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(vt||(vt={}));var Gu;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(Gu||(Gu={}));var H2;function Ate(e){H2=e.wasm.cwrap(ks,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Rte(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:h}=r,d=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let E=n.dataIdMap.get(i.dataId);if(E.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E.shape.length}.`);f=E.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=Gu[u];if(g==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=p?s.shape[1]:s.shape[2],x=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,y,b],a.dtype),I=n.dataIdMap.get(v.dataId).id,N=new Uint8Array(new Int32Array(a.shape).buffer),C=new Uint8Array(new Int32Array(s.shape).buffer);return H2(d,N,a.shape.length,c,C,s.shape.length,l,p,g,f,m,h||0,I),v}var Fte={kernelName:ks,backendName:"wasm",setupFunc:Ate,kernelFunc:Rte};function Rt(e,t){let n;function r(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function a(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,p=i.makeOutput(o.shape,t||o.dtype),u=i.dataIdMap.get(p.dataId).id;return w.sizeFromShape(p.shape)===0||n(l,vt[o.dtype],u),p}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var Dte=Rt(Ao);function nn(e,t,n){let r;function a(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:p,b:u}=l,h=o.dataIdMap.get(p.dataId).id,d=o.dataIdMap.get(u.dataId).id,c=n??p.dtype,f=T.assertAndGetBroadcastShape(p.shape,u.shape),m=o.makeOutput(f,c);if(w.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(p.shape).buffer),y=new Uint8Array(new Int32Array(u.shape).buffer),b=o.dataIdMap.get(m.dataId).id;return r(h,g,p.shape.length,d,y,u.shape.length,vt[p.dtype],b),m}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var Mte=nn(Ha),j2;function Ote(e){j2=e.wasm.cwrap(Ws,null,["array","number","number","number"])}function Lte(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(r.shape)===0)return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return j2(s,a.length,vt[r.dtype],i),r}var zte={kernelName:Ws,backendName:"wasm",setupFunc:Ote,kernelFunc:Lte};function of(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return dn(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Pte={kernelName:ii,backendName:"wasm",kernelFunc:of},q2;function Bte(e){q2=e.wasm.cwrap(aa,null,["number","array","number","number","number","array","number"])}function Wa(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=Vte(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=Wte(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let f=of({inputs:t,backend:n});return f.shape=o,f}let p=n.makeOutput(o,l.dtype),u=n.dataIdMap.get(l.dataId).id,h=n.dataIdMap.get(p.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(l.shape).buffer);return q2(u,c,l.shape.length,vt[l.dtype],h,d,s.length),p}function Wte(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Vte(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)e[a]!==1&&n.push(e[a]),e[t[a]]!==1&&r.push(t[a]);for(let a=0;a<r.length;++a){let s=-1;for(let i=0;i<r.length;++i)r[i]>=a&&(s===-1||r[s]>r[i])&&(s=i);r[s]=a}return[n,r]}var Ute={kernelName:aa,backendName:"wasm",kernelFunc:Wa,setupFunc:Bte};function ts(e,t,n){let r=e.shape,a=e.shape.length,s=w.parseAxisParam(t,r),i=s,o=T.getAxesPermutation(i,a),l=null,p=!1;if(o!=null){let u=new Array(a);for(let d=0;d<u.length;d++)u[d]=r[o[d]];i=T.getInnerMostAxes(i.length,a),l=Wa({inputs:{x:e},attrs:{perm:o},backend:n});let h=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==h&&(p=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:p}}var K2;function Gte(e){K2=e.wasm.cwrap(Do,null,["number, number, number"])}function Hte(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:h,inputWasTransposed:d}=ts(i,a,t);if(d){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("all",u,c);let[f,m]=T.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;K2(o,g,b)}if(d&&t.disposeData(p.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var jte={kernelName:Do,backendName:"wasm",setupFunc:Gte,kernelFunc:Hte},X2;function qte(e){X2=e.wasm.cwrap(Mo,null,["number, number, number"])}function Kte(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:h,inputWasTransposed:d}=ts(i,a,t);if(d){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("any",u,c);let[f,m]=T.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;X2(o,g,b)}if(d&&t.disposeData(p.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var Xte={kernelName:Mo,backendName:"wasm",setupFunc:qte,kernelFunc:Kte},Z2;function Zte(e){Z2=e.wasm.cwrap(Vs,null,["number","number","number","number","number"])}function Jte(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=i,l=s,{transposed:p,axes:u,inputWasTransposed:h}=ts(s,a,t);if(h){let y=t.dataIdMap.get(p.dataId).id;y!==i&&(l=p,o=y)}let d=l.shape.slice(0,-1),c=t.makeOutput(d,"int32"),f=t.dataIdMap.get(c.dataId).id,m=w.sizeFromShape(c.shape),g=l.shape[u[0]];return Z2(o,vt[l.dtype],m,g,f),h&&t.disposeData(p.dataId),c}var Yte={kernelName:Vs,backendName:"wasm",kernelFunc:Jte,setupFunc:Zte},J2;function Qte(e){J2=e.wasm.cwrap(Us,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ene(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=n,u=T.computePool2DInfo(a.shape,i,o,1,l,p),h=u.filterHeight,d=u.filterWidth,c=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.strideHeight,b=u.strideWidth,x=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);let v=r.makeOutput(u.outShape,"float32"),I=r.dataIdMap.get(v.dataId).id;return J2(s,a.shape[0],a.shape[1],a.shape[2],h,d,c,f,m,g,y,b,x,I),v}var tne={kernelName:Us,backendName:"wasm",setupFunc:Qte,kernelFunc:ene};function En(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=w.sizeFromShape(r.shape),i=w.inferFromImplicitShape(a,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var nne={kernelName:gl,backendName:"wasm",kernelFunc:En},Y2;function rne(e){Y2=e.wasm.cwrap(Gs,null,["number","array","number","number","array","number","number","number","number"])}function ane(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,p=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],h=o?s.shape[p-1]:s.shape[p-2],d=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[p-2]:s.shape[p-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=w.sizeFromShape(f),y=w.sizeFromShape(m),b=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,c]);w.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,d]:[g,d,u],v=o?[y,c,h]:[y,h,c],I=En({inputs:{x:a},backend:n,attrs:{shape:x}}),N=En({inputs:{x:s},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(I.dataId).id,E=n.dataIdMap.get(N.dataId).id,A=i?I.shape[2]:I.shape[1],F=o?N.shape[1]:N.shape[2],R=Math.max(g,y),S=n.makeOutput([R,A,F],I.dtype),M=n.dataIdMap.get(S.dataId).id,B=new Uint8Array(new Int32Array(I.shape).buffer),U=new Uint8Array(new Int32Array(N.shape).buffer);return Y2(C,B,I.shape.length,E,U,N.shape.length,i,o,M),n.disposeData(I.dataId),n.disposeData(N.dataId),S.shape=b,S}var sne={kernelName:Gs,backendName:"wasm",setupFunc:rne,kernelFunc:ane};function Ps(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Lt.parseSliceParams(t,n,r),o=Lt.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),p=a.makeOutput(i,t.dtype),u=w.computeStrides(t.shape),h=a.dataIdMap.get(p.dataId);if(o){let f=Lt.computeFlatOffset(s,u);return t.dtype==="string"?h.stringBytes=l.slice(f,f+w.sizeFromShape(i)):a.typedArrayFromHeap(p).set(l.subarray(f,f+w.sizeFromShape(i))),p}if(t.dtype==="string"){let f=sd(l,s,i,t.shape,t.dtype);return h.stringBytes=f,p}let d=a.typedArrayFromHeap(p),c=t.shape.length;if(c===2)ine(l,u[0],d,s,i);else if(c===3)one(l,u[0],u[1],d,s,i);else if(c===4)lne(l,u[0],u[1],u[2],d,s,i);else{let f=sd(l,s,i,t.shape,t.dtype);d.set(f)}return p}function ine(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let p=i;p<l;p++){let u=p*t+o;n.set(e.subarray(u,u+a[1]),s),s+=a[1]}}function one(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],p=a[2],u=o+s[0],h=l+s[1];for(let d=o;d<u;d++)for(let c=l;c<h;c++){let f=d*t+c*n+p;r.set(e.subarray(f,f+s[2]),i),i+=s[2]}}function lne(e,t,n,r,a,s,i){let o=0,l=s[0],p=s[1],u=s[2],h=l+i[0],d=p+i[1],c=u+i[2],f=s[3];for(let m=l;m<h;m++)for(let g=p;g<d;g++)for(let y=u;y<c;y++){let b=m*t+g*n+y*r+f;a.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var une={kernelName:wl,backendName:"wasm",kernelFunc:Ps};function pne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce((y,b)=>y*b),l=T.getReshaped(a.shape,s,o),p=T.getPermuted(l.length,s.length),u=T.getReshapedPermuted(a.shape,s,o),h=T.getSliceBeginCoords(i,s.length),d=T.getSliceSize(u,i,s.length),c=En({inputs:{x:a},backend:n,attrs:{shape:l}}),f=Wa({inputs:{x:c},backend:n,attrs:{perm:p}}),m=En({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Ps({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeData(c.dataId),n.disposeData(f.dataId),n.disposeData(c.dataId),g}var hne={kernelName:Wo,backendName:"wasm",kernelFunc:pne};function tu(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var dne={kernelName:Hs,backendName:"wasm",kernelFunc:tu},cne=Rt(js),Q2;function fne(e){Q2=e.wasm.cwrap(ja,null,["number","number","number","number"])}function mne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(l.dataId).id;return Q2(o,s,i,p),l}var gne={kernelName:ja,backendName:"wasm",setupFunc:fne,kernelFunc:mne};function eT(e){let{inputs:t,backend:n}=e,r=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(c=>c.shape);T.assertParamsConsistent(a,r);let s=T.computeOutShape(t.map(c=>c.shape),r),i=t.filter(c=>w.sizeFromShape(c.shape)>0);if(i.length===1)return of({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let c=i.map(x=>{let v=[-1,w.sizeFromShape(x.shape.slice(r))];return En({inputs:{x},backend:n,attrs:{shape:v}})}),f=c.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=T.computeOutShape(c.map(x=>x.shape),1);let m=c[0].shape[0]===1,g=Yb(f,s,t[0].dtype,m),y=T.computeOutShape(i.map(x=>x.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=T.fromStringArrayToUint8(g),c.forEach(x=>n.disposeData(x.dataId)),o}let l=w.sizeFromShape(i[0].shape.slice(0,r)),p=0,u=i.map(c=>{let f=w.sizeFromShape(c.shape.slice(r));return p+=f,f}),h=i.map(c=>n.typedArrayFromHeap(c)),d=n.typedArrayFromHeap(o);for(let c=0;c<l;c++){let f=c*p;for(let m=0;m<h.length;m++){let g=u[m],y=c*g,b=h[m].subarray(y,y+g);d.set(b,f),f+=g}}return o}var yne={kernelName:Vo,backendName:"wasm",kernelFunc:eT},tT;function bne(e){tT=e.wasm.cwrap(qs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function xne(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:p,pad:u,dimRoundingMode:h,dataFormat:d}=n,c=T.convertConv2DDataFormat(d),f=T.computeConv2DInfo(a.shape,s.shape,l,p,u,h,!1,c),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,v=f.padInfo.left,I=f.dilationHeight,N=f.dilationWidth,C=f.strideHeight,E=f.strideWidth,A=f.inChannels,F=f.outChannels,R=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(f.outShape,"float32"),M=r.dataIdMap.get(S.dataId).id;return tT(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,x,v,R,I,N,C,E,A,F,M),S}var wne={kernelName:qs,backendName:"wasm",setupFunc:bne,kernelFunc:xne},nT;function vne(e){nT=e.wasm.cwrap(Ks,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kne(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,inputShape:u}=r,h=1,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(u,s.shape,i,h,o,p,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:v,outHeight:I,outWidth:N,strideHeight:C,strideWidth:E}=c,A=m-1-c.padInfo.top,F=g-1-c.padInfo.left,R=c.dataFormat==="channelsLast",S=w.computeStrides(c.inShape),M=w.computeStrides(a.shape),[B,U,G]=w.computeStrides(s.shape),K=S[0],H=R?S[1]:S[2],X=R?S[2]:1,ee=R?1:S[1],Z=M[0],re=R?M[1]:M[2],te=R?M[2]:1,ae=R?1:M[1],ie=t.makeOutput(c.inShape,"float32"),we=t.dataIdMap.get(ie.dataId).id,be=t.dataIdMap.get(a.dataId).id,pe=t.dataIdMap.get(s.dataId).id;return nT(be,pe,f,m,g,b,x,y,I,N,v,C,E,A,F,B,U,G,K,H,X,ee,Z,re,te,ae,we),ie}var Ine={kernelName:Ks,backendName:"wasm",setupFunc:vne,kernelFunc:kne},Sne=Rt(Xs),Nne=Rt(Zs),_m;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(_m||(_m={}));var rT;function Tne(e){rT=e.wasm.cwrap(Go,null,["number","number","number","number","array","number","number","number","number","number"])}function Cne(e){let{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:i}=r,{image:o,boxes:l,boxInd:p}=n,u=l.shape[0],[h,d]=i,c=[u,h,d,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=tu({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(p.dataId).id,x=t.makeOutput(c,"float32"),v=t.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return rT(g,y,b,u,I,h,d,_m[a],s,v),m!=null&&t.disposeData(m.dataId),x}var _ne={kernelName:Go,backendName:"wasm",setupFunc:Tne,kernelFunc:Cne},aT;function Ene(e){aT=e.wasm.cwrap(Uo,null,["number","number","number","number","number","number"])}function $ne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let p=T.getAxesPermutation([s],l),u=a;p!==null&&(u=Wa({inputs:{x:a},attrs:{perm:p},backend:n}));let h=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims("cumprod",[h],l);let d=n.makeOutput(u.shape,u.dtype),c=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;aT(f,i?1:0,o?1:0,c,m,vt[a.dtype]);let g=d;if(p!==null){let y=T.getUndoAxesPermutation(p);g=Wa({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return g}var Ane={kernelName:Uo,backendName:"wasm",setupFunc:Ene,kernelFunc:$ne},sT;function Rne(e){sT=e.wasm.cwrap(Js,null,["number","number","number","number","number","number"])}function Fne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let p=T.getAxesPermutation([s],l),u=a;p!==null&&(u=Wa({inputs:{x:a},attrs:{perm:p},backend:n}));let h=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims("cumsum",[h],l);let d=n.makeOutput(u.shape,u.dtype),c=u.shape[h],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(d.dataId).id;sT(f,i?1:0,o?1:0,c,m,vt[a.dtype]);let g=d;if(p!==null){let y=T.getUndoAxesPermutation(p);g=Wa({inputs:{x:d},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(d.dataId)}return g}var Dne={kernelName:Js,backendName:"wasm",setupFunc:Rne,kernelFunc:Fne},iT;function Mne(e){iT=e.wasm.cwrap(Ho,null,["number","number","number","array","number","array","array","number","number"])}function One(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],p=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],h=l*s,d=p*s,c=u/(s*s),f=i==="NHWC"?[o,h,d,c]:[o,c,h,d],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return iT(g,s,i==="NHWC"?1:0,y,a.shape.length-1,b,x,f.length,v),m}var Lne={kernelName:Ho,backendName:"wasm",setupFunc:Mne,kernelFunc:One},oT;function zne(e){oT=e.wasm.cwrap(Ys,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Pne(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:p,pad:u,dimRoundingMode:h}=n,d=p??[1,1],c=T.computeConv2DInfo(a.shape,s.shape,l,d,u,h,!0),f=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,y=c.padInfo.right,b=c.padInfo.bottom,x=c.padInfo.left,v=c.dilationHeight,I=c.dilationWidth,N=c.strideHeight,C=c.strideWidth,E=c.inChannels,A=c.outChannels,F=c.padInfo.type==="SAME"?1:0;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let R=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(R.dataId).id;return oT(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,x,F,v,I,N,C,E,A,S),R}var Bne={kernelName:Ys,backendName:"wasm",setupFunc:zne,kernelFunc:Pne},Wne=Rt(ei),Vne=!1,Une=nn(qo,Vne,"bool"),Gne=Rt(ti,"float32");function Em(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),En({inputs:{x:a},backend:r,attrs:{shape:o}})}var Hne={kernelName:Ko,backendName:"wasm",kernelFunc:Em};function lT(e){let{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var jne={kernelName:Ju,backendName:"wasm",kernelFunc:lT},uT;function qne(e){uT=e.wasm.cwrap(Zo,null,["number","number","number","number","number","number"])}function Kne(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,p,u]=r.shape;return uT(s,o,l,p,u,i),a}var Xne={kernelName:Zo,backendName:"wasm",kernelFunc:Kne,setupFunc:qne},Zne=Rt(ni),Jne=nn(ri),pT;function Yne(e){pT=e.wasm.cwrap(ai,null,["number","number","number","number","number","number","number"])}function Qne(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:p}=n,u=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,c=l!=null?t.dataIdMap.get(l.dataId).id:0,f=p!=null?t.dataIdMap.get(p.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return pT(u,h,d,c,f,a,g),m}var ere={kernelName:ai,backendName:"wasm",setupFunc:Yne,kernelFunc:Qne},hT;function tre(e){hT=e.wasm.cwrap(Is,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nre(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dataFormat:h,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=n,m=T.computeConv2DInfo(a.shape,s.shape,l,u,p,d),g=Gu[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=m.filterHeight,N=m.filterWidth,C=m.padInfo.top,E=m.padInfo.right,A=m.padInfo.bottom,F=m.padInfo.left,R=m.dilationHeight,S=m.dilationWidth,M=m.strideHeight,B=m.strideWidth,U=m.inChannels,G=m.padInfo.type==="SAME"?1:0,K=m.batchSize,H=m.inHeight,X=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),Z=r.dataIdMap.get(ee.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return hT(y,K,H,X,b,I,N,v,C,E,A,F,G,R,S,M,B,U,x,g,re,f||0,Z),ee}var rre={kernelName:Is,backendName:"wasm",setupFunc:tre,kernelFunc:nre},dT;function are(e){dT=e.wasm.cwrap(Ss,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sre(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dataFormat:h,dimRoundingMode:d,activation:c,leakyreluAlpha:f}=n,m=T.computeConv2DInfo(a.shape,s.shape,l,u,p,d,!0),g=Gu[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=m.filterHeight,N=m.filterWidth,C=m.padInfo.top,E=m.padInfo.right,A=m.padInfo.bottom,F=m.padInfo.left,R=m.dilationHeight,S=m.dilationWidth,M=m.strideHeight,B=m.strideWidth,U=m.inChannels,G=m.padInfo.type==="SAME"?1:0,K=m.batchSize,H=m.inHeight,X=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),Z=r.dataIdMap.get(ee.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return dT(y,K,H,X,b,I,N,v,C,E,A,F,G,R,S,M,B,U,x,g,re,f||0,Z),ee}var ire={kernelName:Ss,backendName:"wasm",setupFunc:are,kernelFunc:sre},cT;function ore(e){cT=e.wasm.cwrap(Yo,null,["number","number","number","number","number","number","array","number"])}function lre(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=dy.prepareAndValidate(r,a),p=t.makeOutput(s,r.dtype);if(i===0)return p;let u=a.shape,h=u[u.length-1],d=t.dataIdMap.get(r.dataId).id,c=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(p.dataId).id;return cT(d,vt[r.dtype],c,i,h,o,f,m),p}var ure={kernelName:Yo,backendName:"wasm",setupFunc:ore,kernelFunc:lre},fT;function pre(e){fT=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function hre(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0],p=t.readSync(s.dataId),u=a.shape[l];for(let C=0;C<p.length;++C){let E=p[C];w.assert(E<=u-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${u-1}]`)}let h=T.segment_util.collectGatherOpShapeInfo(a,s,l,o),d=En({inputs:{x:a},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:t}),c=w.sizeFromShape(s.shape),f=En({inputs:{x:s},attrs:{shape:[h.batchSize,c/h.batchSize]},backend:t}),m=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],g=t.makeOutput(m,a.dtype);if(w.sizeFromShape(a.shape)===0)return g;let y=d.shape.length-1,b=t.dataIdMap.get(d.dataId).id,x=t.dataIdMap.get(f.dataId).id,v=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(d.shape)).buffer),N=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer);return fT(b,vt[a.dtype],I,y,x,h.batchSize,N,v),t.disposeData(d.dataId),t.disposeData(f.dataId),g.shape=h.outputShape,g}var dre={kernelName:Jo,backendName:"wasm",setupFunc:pre,kernelFunc:hre},cre=!1,fre=nn(Qo,cre,"bool"),mre=!1,gre=nn(si,mre,"bool"),yre=Rt(oi,"bool"),mT;function bre(e){mT=e.wasm.cwrap(li,null,["number","number","number","number"])}function xre(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(w.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(s.dataId).id;mT(a,vt[t.dtype],n,i)}return s}var wre={kernelName:li,backendName:"wasm",setupFunc:bre,kernelFunc:xre},vre=!1,kre=nn(nl,vre,"bool"),Ire=!1,Sre=nn(rl,Ire,"bool"),Nre=Rt(ui),Tre=!1,Cre=nn(sl,Tre,"bool"),_re=Rt(il),Ere=!1,$re=nn(ol,Ere,"bool"),Are=!1,Rre=nn(a0,Are,"bool"),gT;function Fre(e){gT=e.wasm.cwrap(pi,null,["number","number","number","number"])}function Dre(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:h,inputWasTransposed:d}=ts(i,a,t);if(d){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;T.assertAxesAreInnerMostDims("max",u,c);let[f,m]=T.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;gT(o,vt[i.dtype],g,b)}if(d&&t.disposeData(p.dataId),s){let b=T.expandShapeToKeepDim(y.shape,h);y.shape=b}return y}var Mre={kernelName:pi,backendName:"wasm",setupFunc:Fre,kernelFunc:Dre},Ore=nn(hi),yT;function Lre(e){yT=e.wasm.cwrap(di,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function zre(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;w.assert(a.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=n,u=T.computePool2DInfo(a.shape,i,o,1,l,p),h=u.filterHeight,d=u.filterWidth,c=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.dilationHeight,b=u.dilationWidth,x=u.strideHeight,v=u.strideWidth,I=u.inChannels,N=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(u.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return yT(s,a.shape[0],a.shape[1],a.shape[2],h,d,c,f,m,g,y,b,x,v,I,N,E),C}var Pre={kernelName:di,backendName:"wasm",setupFunc:Lre,kernelFunc:zre},bT;function Bre(e){bT=e.wasm.cwrap(ci,null,["number, number, number"])}function Wre(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:c}=ts(i,a,t),f=h;if(c){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(p=u,l=v,f=T.getInnerMostAxes(f.length,p.shape.length))}T.assertAxesAreInnerMostDims("mean",f,p.shape.length);let[m,g]=T.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=p;p.dtype!=="float32"&&(b=tu({backend:t,inputs:{x:p},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(w.sizeFromShape(p.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;bT(l,y,v)}if(c&&t.disposeData(u.dataId),s){let v=T.expandShapeToKeepDim(x.shape,d);x.shape=v}return p.dtype!=="float32"&&t.disposeData(b.dataId),x}var Vre={kernelName:ci,backendName:"wasm",setupFunc:Bre,kernelFunc:Wre},xT;function Ure(e){xT=e.wasm.cwrap(fi,null,["number","number","number","number"])}function Gre(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:c}=ts(i,a,t);if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x)}let f=p.shape.length;T.assertAxesAreInnerMostDims("min",h,f);let[m,g]=T.computeOutAndReduceShapes(p.shape,h),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;xT(l,vt[i.dtype],y,x)}if(c&&t.disposeData(u.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var Hre={kernelName:fi,backendName:"wasm",setupFunc:Ure,kernelFunc:Gre},jre=nn(mi),$m;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})($m||($m={}));var wT;function qre(e){wT=e.wasm.cwrap(gi,null,["number","array","number","number","array","array","number","number"])}function Kre(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(h).buffer);return wT(i,p,t.shape.length,vt[t.dtype],d,c,$m[a],l),o}var Xre={kernelName:gi,backendName:"wasm",kernelFunc:Kre,setupFunc:qre},Zre=nn(yi),Jre=Rt(ul);function Sx(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var vT;function Yre(e){vT=e.wasm.cwrap(hl,"number",["number","number","number","number","number"])}function Qre(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,p=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(l.dataId).id,h=vT(p,u,s,a,i),{pSelectedIndices:d,selectedSize:c,pSelectedScores:f,pValidOutputs:m}=Sx(t,h);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([c],"int32",d)}var eae={kernelName:hl,backendName:"wasm",setupFunc:Yre,kernelFunc:Qre},kT;function tae(e){kT=e.wasm.cwrap(dl,"number",["number","number","number","number","number","bool"])}function nae(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:p}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(p.dataId).id,d=kT(u,h,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Sx(t,d);t.wasm._free(m);let y=t.makeOutput([f],"int32",c),b=t.makeOutput([],"int32",g);return[y,b]}var rae={kernelName:dl,backendName:"wasm",setupFunc:tae,kernelFunc:nae},IT;function aae(e){IT=e.wasm.cwrap(cl,"number",["number","number","number","number","number","number"])}function sae(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:p}=n,u=t.dataIdMap.get(l.dataId).id,h=t.dataIdMap.get(p.dataId).id,d=IT(u,h,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Sx(t,d);t.wasm._free(g);let y=t.makeOutput([f],"int32",c),b=t.makeOutput([f],"float32",m);return[y,b]}var iae={kernelName:cl,backendName:"wasm",setupFunc:aae,kernelFunc:sae},oae=!1,lae=nn(pl,oae,"bool"),ST;function uae(e){ST=e.wasm.cwrap(bi,null,["number","number","number","number","number"])}function pae(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,p=n.makeOutput([...a.shape,i],s),u=n.dataIdMap.get(p.dataId).id,h=n.dataIdMap.get(a.dataId).id;return ST(h,i,o,l,u),p}var hae={kernelName:bi,backendName:"wasm",setupFunc:uae,kernelFunc:pae};function dae(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var cae={kernelName:fl,backendName:"wasm",kernelFunc:dae};function fae(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return Em({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let h=Em({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(h),h}),p=eT({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeData(u.dataId)),p}var mae={kernelName:ml,backendName:"wasm",kernelFunc:fae},NT;function gae(e){NT=e.wasm.cwrap(xi,null,["number","array","number","number","array","array","number","number"])}function yae(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(w.sizeFromShape(t.shape)===0)return lT({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),h=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(h).buffer);return NT(i,p,t.shape.length,vt[t.dtype],d,c,a,l),o}var TT={kernelName:xi,backendName:"wasm",kernelFunc:yae,setupFunc:gae},bae=nn(wi),CT;function xae(e){CT=e.wasm.cwrap(vi,null,["number","number","number"])}function wae(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,p=l;l.dtype!=="float32"&&(p=tu({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(p.dataId).id);let u=n.makeOutput(r.shape,"float32"),h=n.dataIdMap.get(u.dataId).id;return CT(o,i,h),l.dtype!=="float32"&&n.disposeData(p.dataId),u}var vae={kernelName:vi,backendName:"wasm",setupFunc:xae,kernelFunc:wae},_T;function kae(e){_T=e.wasm.cwrap(ki,null,["number","number","number","number"])}function Iae(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:c}=ts(i,a,t),f=h;if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x,f=T.getInnerMostAxes(f.length,p.shape.length))}T.assertAxesAreInnerMostDims("prod",f,p.shape.length);let[m,g]=T.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;_T(l,y,vt[b.dtype],x)}if(c&&t.disposeData(u.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var Sae={kernelName:ki,backendName:"wasm",setupFunc:kae,kernelFunc:Iae},Nae=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=tx(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},Tae={kernelName:ep,backendName:"wasm",kernelFunc:Nae},Cae=nn(Qs),_ae=Rt(Ii),Eae=Rt(Si),$ae=Rt(Ci),ET;function Aae(e){ET=e.wasm.cwrap(Ti,null,["number","number","number","number","number","number","number","number","number","number"])}function Rae(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,[u,h,d,c]=a.shape,f=[u,l,p,c],m=t.dataIdMap.get(a.dataId),g;m.dtype!=="float32"&&(g=tu({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.makeOutput(f,"float32");if(w.sizeFromShape(a.shape)===0)return b;let x=t.dataIdMap.get(b.dataId).id;return ET(y,u,h,d,c,l,p,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),b}var Fae={kernelName:Ti,backendName:"wasm",setupFunc:Aae,kernelFunc:Rae},$T;function Dae(e){$T=e.wasm.cwrap(Ni,null,["number","number","number","number","number","number","number","number","number","number"])}function Mae(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,[u,h,d,c]=a.shape,f=[u,l,p,c],m=t.makeOutput(f,"float32");if(w.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(a.dataId),y;g.dtype!=="float32"&&(y=tu({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.dataIdMap.get(m.dataId).id;return $T(b,u,h,d,c,l,p,s?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),m}var Oae={kernelName:Ni,backendName:"wasm",setupFunc:Dae,kernelFunc:Mae},AT;function Lae(e){AT=e.wasm.cwrap(_i,null,["number","array","number","array","number","number"])}function zae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=w.parseAxisParam(s,a.shape);if(a.shape.length===0)return of({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(a.shape).buffer);AT(l,u,i.length,h,a.shape.length,p);let d=En({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d}var Pae={kernelName:_i,backendName:"wasm",kernelFunc:zae,setupFunc:Lae},RT;function Bae(e){RT=e.wasm.cwrap(Rl,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Wae(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(l.dataId).id,[h,d,c,f]=a.shape,[m,g]=T.getImageCenter(o,d,c),y=i===0,b=255,x=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(x).buffer);return RT(p,h,d,c,f,s,m,g,v,x.length,u),l}var Vae={kernelName:Rl,backendName:"wasm",kernelFunc:Wae,setupFunc:Bae},Uae=Rt(Ei),Gae=Rt($i),FT;function Hae(e){FT=e.wasm.cwrap(yl,null,["number","number","number","number","number","number","array","number","number"])}function jae(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:p,sliceSize:u,strides:h,outputSize:d}=Zg.calculateShapes(s,a,i),c=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(h).buffer),g=t.dataIdMap.get(o.dataId).id;return FT(c,f,vt[s.dtype],l,p,u,m,d,g),o}var qae={kernelName:yl,backendName:"wasm",setupFunc:Hae,kernelFunc:jae},DT;function Kae(e){DT=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Xae(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,p=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(p.dataId).id,h=r.shape.length,d=a.shape.length,c=h===0||h>1||d===1?1:w.sizeFromShape(a.shape.slice(1));return DT(i,o,l,c,u),p}var Zae={kernelName:bl,backendName:"wasm",kernelFunc:Xae,setupFunc:Kae},MT;function Jae(e){MT=e.wasm.cwrap(Ri,null,["number","number"])}function Yae(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return w.sizeFromShape(a.shape)===0||MT(r,s),a}var Qae={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Jae,kernelFunc:Yae},ese=Rt(Ai),OT;function tse(e){OT=e.wasm.cwrap(Mi,null,["number","number","number","number"])}function nse(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=w.sizeFromShape(n.shape)/o;return w.sizeFromShape(s.shape)===0||OT(a,i,o,l),s}var rse={kernelName:Mi,backendName:"wasm",setupFunc:tse,kernelFunc:nse};function ase(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let p=TT.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=T.getReshaped(p.shape,s,o,!1),h=T.getPermuted(u.length,s.length,!1),d=T.getReshapedPermuted(p.shape,s,o,!1),c=En({inputs:{x:p},backend:n,attrs:{shape:u}}),f=Wa({inputs:{x:c},backend:n,attrs:{perm:h}}),m=En({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(p.dataId),n.disposeData(c.dataId),n.disposeData(f.dataId),m}var sse={kernelName:Sl,backendName:"wasm",kernelFunc:ase},LT;function ise(e){LT=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function ose(e){let{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],p=t.readSync(s.dataId)[0],u=[o+p,l],h=t.dataIdMap.get(r.dataId).id,d=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(u,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(u.slice(0,1),a.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([p],"bool"),x=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([o],r.dtype),I=t.dataIdMap.get(v.dataId).id,N=t.makeOutput([4],"int32"),C=t.dataIdMap.get(N.dataId).id,E=LT(h,d,vt[a.dtype],o,p,l,c,m,y,x,I,C),A=t.readSync(N.dataId),F;switch(A[0]){case 1:{F=T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{F=T.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:F=T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:F=""}if(t.disposeData(N.dataId),F)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(F);let R=f,S=g;return E!==u[0]&&(R=Ps({inputs:{x:f},attrs:{begin:0,size:[E,l]},backend:t}),S=Ps({inputs:{x:g},attrs:{begin:0,size:E},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[R,S,b,v]}var lse={kernelName:tp,backendName:"wasm",setupFunc:ise,kernelFunc:ose},zT;function use(e){zT=e.wasm.cwrap(Tl,null,["number","number","number","number","number","number","number"])}function pse(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,p=r.shape[0],u=w.sizeFromShape(s.shape),h=t.makeOutput([p,u],r.dtype),d=t.dataIdMap.get(h.dataId).id,c=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(c.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;zT(i,o,l,p,d,f,g);let y=t.readSync(m.dataId),b;switch(y[0]){case 0:{b=T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=T.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=T.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=T.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(h.dataId),t.disposeData(c.dataId),new Error(b);return[h,c]}var hse={kernelName:Tl,backendName:"wasm",setupFunc:use,kernelFunc:pse},PT;function BT(e){PT=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function WT(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],p=o>0?l+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=a.shape.slice();u[0]=p;let h=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;PT(h,vt[a.dtype],a.shape[0],d,c,m,y,t,0);let b=n.readSync(g.dataId),x;switch(b[0]){case 0:{x=T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:x=T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function dse(e){return WT(e,!0)}var cse={kernelName:np,backendName:"wasm",setupFunc:BT,kernelFunc:dse};function fse(e){return WT(e,!1)}var mse={kernelName:rp,backendName:"wasm",setupFunc:BT,kernelFunc:fse};function gse(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=w.parseAxisParam(i,a.shape)[0],l=T.prepareSplitSize(a,s,o),p=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(h=>{let d=[...u];d[o]=h;let c=Ps({inputs:{x:a},attrs:{begin:p,size:d},backend:r});return p[o]+=h,c})}var yse={kernelName:Nl,backendName:"wasm",kernelFunc:gse},bse=Rt(Fi),xse=Rt(ap),wse=nn(Oi),VT;function vse(e){VT=e.wasm.cwrap(Ka,null,["number","number","number","number"])}function kse(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return VT(i,a,vt[s.dtype],l),o}var Ise={kernelName:Ka,backendName:"wasm",setupFunc:vse,kernelFunc:kse},UT;function Sse(e){UT=e.wasm.cwrap(Cl,null,["number","array","number","array","array","array","array","array","number","number"])}function Nse(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,h,d),I;if(m)I=En({inputs:{x:a},backend:t,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let N=Lt.computeOutShape(b,x,v),C=Ps({inputs:{x:a},backend:t,attrs:{begin:b,size:N}});I=En({inputs:{x:C},backend:t,attrs:{shape:f}}),t.disposeData(C.dataId)}else{let N=t.makeOutput(c,"float32"),C=t.dataIdMap.get(a.dataId).id,E=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(b).buffer),F=new Uint8Array(new Int32Array(x).buffer),R=new Uint8Array(new Int32Array(v).buffer),S=new Uint8Array(new Int32Array(c).buffer),M=new Uint8Array(new Int32Array(w.computeStrides(c)).buffer),B=t.dataIdMap.get(N.dataId).id;UT(C,E,a.shape.length,A,F,R,S,M,c.length,B),I=En({inputs:{x:N},backend:t,attrs:{shape:f}}),t.disposeData(N.dataId)}return I}var Tse={kernelName:Cl,backendName:"wasm",setupFunc:Sse,kernelFunc:Nse};function Cse(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:p,padWidth:u,preserveShortSequences:h}=r,d=t.readSync(a.dataId),c=t.readSync(s.dataId),[f,m]=rx(d,c,i,o,l,p,u,h),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var _se={kernelName:sp,backendName:"wasm",kernelFunc:Cse};function Ese(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[p,u,h]=ax(o,l[0],i),d=u.length,c=t.makeOutput([d,2],"int32");t.typedArrayFromHeap(c).set(p);let f=t.makeOutput([d],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=u;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(h),[c,f,g]}var $se={kernelName:ip,backendName:"wasm",kernelFunc:Ese};function Ase(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=sx(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var Rse={kernelName:op,backendName:"wasm",kernelFunc:Ase},Fse=nn(Li),GT;function Dse(e){GT=e.wasm.cwrap(Di,null,["number","number","number","number"])}function Mse(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:h,originalAxes:d,inputWasTransposed:c}=ts(i,a,t),f=h;if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x,f=T.getInnerMostAxes(f.length,p.shape.length))}T.assertAxesAreInnerMostDims("sum",f,p.shape.length);let[m,g]=T.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;GT(l,y,vt[b.dtype],x)}if(c&&t.disposeData(u.dataId),s){let x=T.expandShapeToKeepDim(b.shape,d);b.shape=x}return b}var Ose={kernelName:Di,backendName:"wasm",setupFunc:Dse,kernelFunc:Mse},Lse=Rt(zi),zse=Rt(Pi),HT;function Pse(e){HT=e.wasm.cwrap(qa,null,["number","array","number","array","number","number"])}function Bse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*i[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),p=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,a.dtype),h=n.dataIdMap.get(u.dataId).id;return HT(s,l,a.shape.length,p,o.length,vt[u.dtype],h),u}var Wse={kernelName:qa,backendName:"wasm",setupFunc:Pse,kernelFunc:Bse},jT;function Vse(e){jT=e.wasm.cwrap(_l,null,["number","array","number","number","number","bool","number","number"])}var Use=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let p=t.makeOutput(l,r.dtype),u=t.dataIdMap.get(p.dataId).id,h=t.makeOutput(l,"int32"),d=t.dataIdMap.get(h.dataId).id;return jT(i,o,r.shape.length,vt[r.dtype],a,s,u,d),[p,h]},Gse={kernelName:_l,backendName:"wasm",setupFunc:Vse,kernelFunc:Use},qT;function Hse(e){qT=e.wasm.cwrap(El,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function jse(e){let{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=r,[u,h,d,c]=a.shape,[f,m]=p??[h,d],g=[u,f,m,c],y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer),x=t.makeOutput(g,a.dtype),v=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(a.dataId).id,N=t.dataIdMap.get(s.dataId).id,C=i==="nearest"?1:2,E;switch(o){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return qT(I,N,s.shape[0]>1,u,f,m,c,d,h,y,a.shape.length-1,b,g.length-1,C,E,l,v),x}var qse={kernelName:El,backendName:"wasm",setupFunc:Hse,kernelFunc:jse};function Kse(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),p=0;for(let c=0;c<o;c++)c!==s&&(l[p++]=a.shape[c]);let u=new Array(i),h=new Array(o).fill(0),d=a.shape.slice();d[s]=1;for(let c=0;c<u.length;c++)h[s]=c,u[c]=Ps({inputs:{x:a},attrs:{begin:h,size:d},backend:n});return u.map(({dataId:c,dtype:f})=>({dataId:c,dtype:f,shape:l}))}var Xse={kernelName:$l,backendName:"wasm",kernelFunc:Kse};function Zse(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Jse={kernelName:Al,backendName:"wasm",kernelFunc:Zse},Yse=[Fte,Dte,Mte,zte,jte,Xte,Yte,tne,sne,hne,dne,cne,gne,yne,wne,Ine,Sne,Nne,_ne,Ane,Dne,Lne,Bne,Wne,Une,Gne,Hne,jne,Xne,Zne,Jne,ere,rre,ire,ure,dre,fre,gre,Pte,yre,wre,kre,Sre,Nre,Cre,_re,$re,Rre,Mre,Ore,Pre,Vre,Hre,jre,Xre,Zre,Jre,eae,rae,iae,lae,hae,cae,mae,TT,bae,vae,Sae,Tae,Cae,_ae,Eae,$ae,nne,Fae,Oae,Pae,Vae,Uae,Gae,qae,Zae,Qae,ese,une,rse,sse,lse,hse,cse,mse,yse,bse,xse,wse,Ise,Tse,_se,$se,Rse,Fse,Ose,Lse,zse,Wse,Gse,qse,Ute,Xse,Jse];for(let e of Yse)up(e);var Am=j();Am.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});Am.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Am.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var Ov=Ua(k_()),Qse=Ua(I_()),Lv=Ua(S_()),zv=Ov.default||Ov,eie=Lv.default||Lv,KT=class extends Hu{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(XT),Rm=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new bd(this,pr())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if(r==="string"){let p=t;this.dataIdMap.set(e,{id:s,stringBytes:p,shape:n,dtype:r,memoryOffset:null,refCount:a});return}let i=w.sizeFromShape(n),o=i*w.bytesPerElement(r),l=this.wasm._malloc(o);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||w.sizeFromShape(s);let o=w.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return rie(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(n==null)r=this.write(null,e,t);else{let a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function tie(e){return(t,n)=>(w.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(s=>{n(s.instance,s.module)})})}),{})}function Pv(e,t,n){if(dd!=null)return dd;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),Su!=null&&Su[r]!=null?Su[r]:n+r}async function nie(){let[e,t]=await Promise.all([j().getAsync("WASM_HAS_SIMD_SUPPORT"),j().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={};a.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let p=Qse.wasmWorkerContents.replace(/\n/g,"\\n"),u=new Blob([p],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?Pv(e,t,vu??l):l+o},Nx&&(a.instantiateWasm=tie(Pv(e,t,vu??"")));let s=!1;a.onAbort=()=>{s||Nu||(Nu=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&dd==null?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+zv.toString()],{type:"text/javascript"}),i=zv(a)):i=eie(a),i.then(o=>{s=!0,Nu=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function rie(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var aie=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],dd=null,vu=null,Su={},Nu=!1,Nx=!1;function sie(e,t=!1){if(T0("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Nu)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");dd=e,Nx=t}function iie(e,t=!1){if(Nu)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")vu=e;else{Su=e;let n=aie.filter(r=>Su[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Nx=t}var XT=-1,Rm=-1;function oie(e){XT=e}function lie(){if(Rm===-1)throw new Error("WASM backend not initialized.");return Rm}var uie="4.2.0",pie=2;nc("wasm",async()=>{let{wasm:e}=await nie();return new KT(e)},pie);var Bv="4.2.0",hie="4.2.0",die="4.2.0",cie="4.2.0",fie="4.2.0",mie={tfjs:Bv,"tfjs-core":Bv,"tfjs-converter":hie,"tfjs-backend-cpu":die,"tfjs-backend-webgl":cie,"tfjs-backend-wasm":fie},gie={};Lm(gie,{AnchorPosition:()=>iC,DrawBox:()=>lC,DrawBoxOptions:()=>oC,DrawFaceLandmarks:()=>NC,DrawFaceLandmarksOptions:()=>SC,DrawTextField:()=>lf,DrawTextFieldOptions:()=>Rx,drawContour:()=>ka,drawDetections:()=>$ie,drawFaceExpressions:()=>Gie,drawFaceLandmarks:()=>qie});function ka(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}var yie={};Lm(yie,{computeReshapedDimensions:()=>YT,getCenterPoint:()=>Cx,isDimensions:()=>Dm,isEven:()=>Fm,isFloat:()=>JT,isTensor:()=>nu,isTensor1D:()=>bie,isTensor2D:()=>ZT,isTensor3D:()=>jp,isTensor4D:()=>ia,isValidNumber:()=>vs,isValidProbablitiy:()=>xie,range:()=>Eo,round:()=>Tx});var ws=class{constructor(e,t){if(!vs(e)||!vs(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new ws(1/this.width,1/this.height)}};function nu(e,t){return e instanceof Pe&&e.shape.length===t}function bie(e){return nu(e,1)}function ZT(e){return nu(e,2)}function jp(e){return nu(e,3)}function ia(e){return nu(e,4)}function JT(e){return e%1!==0}function Fm(e){return e%2===0}function Tx(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Dm(e){return e&&e.width&&e.height}function YT({width:e,height:t},n){let r=n/Math.max(t,e);return new ws(Math.round(e*r),Math.round(t*r))}function Cx(e){return e.reduce((t,n)=>t.add(n),new Ke(0,0)).div(new Ke(e.length,e.length))}function Eo(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function vs(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function xie(e){return vs(e)&&e>=0&&e<=1}var Ke=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new Ke(this.x+e.x,this.y+e.y)}sub(e){return new Ke(this.x-e.x,this.y-e.y)}mul(e){return new Ke(this.x*e.x,this.y*e.y)}div(e){return new Ke(this.x/e.x,this.y/e.y)}abs(){return new Ke(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Ke(Math.floor(this.x),Math.floor(this.y))}},rn=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(vs)}static assertIsValidBox(e,t,n=!1){if(!rn.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every(vs),a=[n.x,n.y,n.width,n.height].every(vs);if(!a&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[s,i,o,l]=a?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];rn.assertIsValidBox({x:s,y:i,width:o,height:l},"Box.constructor",t),this._x=s,this._y=i,this._width=o,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Ke(this.left,this.top)}get topRight(){return new Ke(this.right,this.top)}get bottomLeft(){return new Ke(this.left,this.bottom)}get bottomRight(){return new Ke(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new rn({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new rn({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,a=Math.abs(n-r);return n<r&&(e-=a/2,n+=a),r<n&&(t-=a/2,r+=a),new rn({x:e,y:t,width:n,height:r})}rescale(e){let t=Dm(e)?e.width:e,n=Dm(e)?e.height:e;return new rn({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,a,s]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new rn({x:n,y:r,width:a,height:s})}clipAtImageBorders(e,t){let{x:n,y:r,right:a,bottom:s}=this,i=Math.max(n,0),o=Math.max(r,0),l=a-i,p=s-o,u=Math.min(l,e-i),h=Math.min(p,t-o);return new rn({x:i,y:o,width:u,height:h}).floor()}shift(e,t){let{width:n,height:r}=this,a=this.x+e,s=this.y+t;return new rn({x:a,y:s,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=1,s=1,i=n,o=r,l=this.left,p=this.top,u=this.right,h=this.bottom;return u>t&&(i=-u+t+n,u=t),h>e&&(o=-h+e+r,h=e),l<1&&(o=2-l,l=1),p<1&&(o=2-p,p=1),{dy:s,edy:o,dx:a,edx:i,y:p,ey:h,x:l,ex:u,w:n,h:r}}calibrate(e){return new rn({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},QT=class extends rn{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},_x=class{constructor(e,t,n,r,a){this._imageDims=new ws(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new rn(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new rn(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new _x(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},fr=class extends _x{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:a}=super.forSize(e,t);return new fr(n,r,a)}};function wie(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function vie(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new QT(r,a,s,i)}function kie(e,t,n,r=!0){let a=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;a.length>0;){let i=a.pop();s.push(i);let o=a,l=[];for(let p=0;p<o.length;p++){let u=o[p],h=e[i],d=e[u];l.push(wie(h,d,r))}a=a.filter((p,u)=>l[u]<=n)}return s}function qp(e,t){return W(()=>{let[n,r,a]=t,s=Wn([...e.shape.slice(0,3),1],n,"float32"),i=Wn([...e.shape.slice(0,3),1],r,"float32"),o=Wn([...e.shape.slice(0,3),1],a,"float32"),l=nt([s,i,o],3);return de(e,l)})}function Iie(e,t=!1){return W(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=h=>{let d=e.shape.slice();return d[i]=h,Wn(d,0,"float32")},l=o(s),p=a-l.shape[i],u=[t&&p?o(p):null,e,l].filter(h=>!!h).map(h=>se(h,"float32"));return nt(u,i)})}function Rf(e){return 1/(1+Math.exp(-e))}var eC=class extends rn{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},Sie=.5,Nie=.43,Tie=.45,cd=class{constructor(e,t,n=new Ke(0,0)){let{width:r,height:a}=t;this._imgDims=new ws(r,a),this._shift=n,this._positions=e.map(s=>s.mul(new Ke(r,a)).add(n))}get shift(){return new Ke(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Ke(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Ke(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof fr?e.box.floor():new rn(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=u=>r.sub(u).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/Tie),o=Cx(e),l=Math.floor(Math.max(0,o.x-Sie*i)),p=Math.floor(Math.max(0,o.y-Nie*i));return new eC(l,p,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+p))}alignMinBbox(e){let t=vie(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},tC=class extends cd{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Cx)}};function fd(e){return e.detection instanceof fr}function Cie(e,t){return{...e,detection:t}}function nC(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Ex(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function rC(e){let t="";if(!e&&Ex())try{e=e_("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(s,i)=>s?a(s):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function aC(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},a=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=rC();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:a,createVideoElement:s,fetch:i,...o}}function sC(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Bt;function _ie(){if(!Bt)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Bt}function Mm(e){Bt=e}function $x(){return sC()?Mm(nC()):Ex()?Mm(aC()):null}function Eie(e){if(Bt||$x(),!Bt)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Bt.Canvas,Image:n=Bt.Image}=e;Bt.Canvas=t,Bt.Image=n,Bt.createCanvasElement=e.createCanvasElement||(()=>new t),Bt.createImageElement=e.createImageElement||(()=>new n),Bt.ImageData=e.ImageData||Bt.ImageData,Bt.Video=e.Video||Bt.Video,Bt.fetch=e.fetch||Bt.fetch,Bt.readFile=e.readFile||Bt.readFile}var gn={getEnv:_ie,setEnv:Mm,initialize:$x,createBrowserEnv:nC,createFileSystem:rC,createNodejsEnv:aC,monkeyPatch:Eie,isBrowser:sC,isNodejs:Ex};$x();function Ax(e){return!gn.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Va(e){let{Canvas:t,CanvasRenderingContext2D:n}=gn.getEnv();if(e instanceof n)return e;let r=Ax(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d");if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}var iC=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(iC||{}),Rx=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},lf=class{constructor(e,t,n={}){this.text=typeof e=="string"?[e]:e instanceof lf?e.text:e,this.anchor=t,this.options=new Rx(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map(n=>e.measureText(n).width).reduce((n,r)=>n<r?r:n,0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r=n==="BOTTOM_RIGHT"||n==="TOP_RIGHT",a=n==="BOTTOM_LEFT"||n==="BOTTOM_RIGHT",s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:p,height:u}=t,h=Math.max(Math.min(o,p-s),0),d=Math.max(Math.min(l,u-i),0);return{x:h,y:d}}return{x:o,y:l}}draw(e){let t=Ax(e),n=Va(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),p=this.measureHeight();n.fillStyle=r;let u=this.getUpperLeft(n,t);n.fillRect(u.x,u.y,l,p),n.fillStyle=a,this.text.forEach((h,d)=>{let c=o+u.x,f=o+u.y+(d+1)*s;n.fillText(h,c,f)})}},oC=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new Rx({...s,...a})}},lC=class{constructor(e,t={}){this.box=new rn(e),this.options=new oC(t)}draw(e){let t=Va(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new lf([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function $ie(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof fr?n.score:fd(n)?n.detection.score:void 0,a=n instanceof fr?n.box:fd(n)?n.detection.box:new rn(n),s=r?`${Tx(r)}`:void 0;new lC(a,{label:s}).draw(e)})}function uC(e){let{Image:t,Video:n}=gn.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function Aie(e){return new Promise((t,n)=>{(e instanceof gn.getEnv().Canvas||uC(e))&&t(null);function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),n(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),t(s))}e.addEventListener("load",a),e.addEventListener("error",r)})}function ale(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{typeof r.result!="string"&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let a=gn.getEnv().createImageElement();a.onload=()=>t(a),a.onerror=n,a.src=r.result},r.onerror=n,r.readAsDataURL(e)})}function pC(e){let{Image:t,Video:n}=gn.getEnv();return e instanceof t?new ws(e.naturalWidth,e.naturalHeight):e instanceof n?new ws(e.videoWidth,e.videoHeight):new ws(e.width,e.height)}function md({width:e,height:t}){let{createCanvasElement:n}=gn.getEnv(),r=n();return r.width=e,r.height=t,r}function hC(e,t){let{ImageData:n}=gn.getEnv();if(!(e instanceof n)&&!uC(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||pC(e),s=md({width:r,height:a});return e instanceof n?Va(s).putImageData(e,0,0):Va(s).drawImage(e,0,0,r,a),s}async function Rie(e,t){let n=t||gn.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(ia(e)?1:0),i=W(()=>e.as3D(r,a,s).toInt());return await Cp.toPixels(i,n),i.dispose(),n}function Wv(e){let{Image:t,Canvas:n,Video:r}=gn.getEnv();return e instanceof t||e instanceof n||e instanceof r}function Fie(e,t,n=!1){let{Image:r,Canvas:a}=gn.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return md({width:1,height:1});let s=pC(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,p=md({width:t,height:t}),u=e instanceof a?e:hC(e),h=Math.abs(o-l)/2,d=n&&o<l?h:0,c=n&&l<o?h:0;return u.width>0&&u.height>0&&Va(p).drawImage(u,d,c,o,l),p}var gd=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(jp(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(ia(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let a=n instanceof gn.getEnv().Canvas?n:hC(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Eo(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return YT({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,W(()=>{let n=Eo(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof Pe){let s=ia(a)?a:Jt(a);return s=Iie(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=wr.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(a instanceof gn.getEnv().Canvas)return Cp.fromPixels(Fie(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return Ot(n.map(r=>se(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function yn(e){if(e instanceof gd)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map(Ax);return r.forEach((a,s)=>{if(!Wv(a)&&!jp(a)&&!ia(a))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(ia(a)){let i=a.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(a=>Wv(a)&&Aie(a))),new gd(r,Array.isArray(e))}async function dC(e,t){let{Canvas:n}=gn.getEnv(),r=e;if(!(e instanceof n)){let s=await yn(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);r=i instanceof n?i:await Rie(i)}let a=Va(r);return t.map(s=>s instanceof fr?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:i,width:o,height:l})=>{let p=md({width:o,height:l});return o>0&&l>0&&Va(p).putImageData(a.getImageData(s,i,o,l),0,0),p})}async function cC(e,t){if(!jp(e)&&!ia(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(ia(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return W(()=>{let[n,r,a]=e.shape.slice(ia(e)?1:0);return t.map(s=>s instanceof fr?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>Wl(e.as3D(n,r,a),[i,s,0],[l,o,a]))})}async function Die(e,t){let{fetch:n}=gn.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Mie(e){return(await Die(e)).json()}function fC(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter(o=>o),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function Oie(e,t){let{manifestUri:n,modelBaseUri:r}=fC(e,t),a=await Mie(n);return Qt.loadWeights(a,r)}var ns=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Ns)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Ns))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=dn(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await Oie(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=gn.getEnv(),{manifestUri:n,modelBaseUri:r}=fC(e,this.getDefaultModelName()),a=l=>Promise.all(l.map(p=>t(p).then(u=>u.buffer))),s=Qt.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,s)=>{if(!a.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:a.nextObj,objProp:s,nextObj:a.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Pe))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Qn(e,t,n){return W(()=>{let r=Bl(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=J(r,t.bias),r})}function Ff(e,t,n=!1){return W(()=>{let r=Ye(n?J(cn(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Qn(e,t.conv0,[2,2])),a=Qn(r,t.conv1,[1,1]),s=Ye(J(r,a)),i=Qn(s,t.conv2,[1,1]);return Ye(J(r,J(a,i)))})}function Ih(e,t,n=!1,r=!0){return W(()=>{let a=Ye(n?J(cn(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Qn(e,t.conv0,r?[2,2]:[1,1])),s=Qn(a,t.conv1,[1,1]),i=Ye(J(a,s)),o=Qn(i,t.conv2,[1,1]),l=Ye(J(a,J(s,o))),p=Qn(l,t.conv3,[1,1]);return Ye(J(a,J(s,J(o,p))))})}function Tu(e,t,n="same",r=!1){return W(()=>{let a=J(cn(e,t.filters,[1,1],n),t.bias);return r?Ye(a):a})}function rs(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function Fx(e,t){return(n,r,a,s)=>{let i=Ma(e(n*r*a*a),[a,a,n,r]),o=Je(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function mC(e,t){return(n,r,a)=>{let s=Br(e(n*r),[n,r]),i=Je(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var gC=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function Dx(e,t){return(n,r,a)=>{let s=Ma(e(9*n),[3,3,n,1]),i=Ma(e(n*r),[1,1,n,r]),o=Je(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new gC(s,i,o)}}function Mx(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new gC(n,r,a)}}function Zi(e,t){return(n,r,a)=>{let s=e[n];if(!nu(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function as(e){let t=e;function n(a){let s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function yC(e,t){let n=Fx(e,t),r=Dx(e,t);function a(i,o,l,p=!1){let u=p?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),h=r(o,o,`${l}/conv1`),d=r(o,o,`${l}/conv2`);return{conv0:u,conv1:h,conv2:d}}function s(i,o,l,p=!1){let{conv0:u,conv1:h,conv2:d}=a(i,o,l,p),c=r(o,o,`${l}/conv3`);return{conv0:u,conv1:h,conv2:d,conv3:c}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function Lie(e){let t=[],{extractWeights:n,getRemainingWeights:r}=as(e),{extractDenseBlock4Params:a}=yC(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function bC(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function xC(e,t){let n=Zi(e,t),r=bC(n),a=Mx(n);function s(o,l=!1){let p=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),h=a(`${o}/conv2`);return{conv0:p,conv1:u,conv2:h}}function i(o,l=!1){let p=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),h=a(`${o}/conv2`),d=a(`${o}/conv3`);return{conv0:p,conv1:u,conv2:h,conv3:d}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function zie(e){let t=[],{extractDenseBlock4Params:n}=xC(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return rs(e,t),{params:r,paramMappings:t}}var wC=class extends ns{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return W(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=qp(n,[122.782,117.001,104.298]).div(255),a=Ih(r,t.dense0,!0);return a=Ih(a,t.dense1),a=Ih(a,t.dense2),a=Ih(a,t.dense3),a=ha(a,[7,7],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await yn(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return zie(e)}extractParams(e){return Lie(e)}};function Om(e,t){return W(()=>J(Le(e,t.weights),t.bias))}function Pie(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=as(e),i=mC(a,r)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function Bie(e){let t=[],n=Zi(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:r("fc")};return rs(e,t),{params:a,paramMappings:t}}function vC(e){let t={},n={};return Object.keys(e).forEach(r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var kC=class extends ns{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return W(()=>{let n=e instanceof gd?this.faceFeatureExtractor.forwardInput(e):e;return Om(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Pie(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=vC(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Bie(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},Vv=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Ox=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);Vv.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return Vv.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},Wie=class extends kC{constructor(e=new wC){super("FaceExpressionNet",e)}forwardInput(e){return W(()=>Ja(this.runNet(e)))}async forward(e){return this.forwardInput(await yn(e))}async predictExpressions(e){let t=await yn(e),n=await this.forwardInput(t),r=await Promise.all(St(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let a=r.map(s=>new Ox(s));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function Vie(e){return e.expressions instanceof Ox}function Uie(e,t){return{...e,expressions:t}}function Gie(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let s=a instanceof Ox?a:Vie(a)?a.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=fd(a)?a.detection.box.bottomLeft:r||new Ke(0,0);new lf(i.map(l=>`${l.expression} (${Tx(l.probability)})`),o).draw(e)})}function IC(e){return fd(e)&&e.landmarks instanceof cd&&e.unshiftedLandmarks instanceof cd&&e.alignedRect instanceof fr}function Hie(e){let t=l=>l*180/Math.PI,n=(l,p)=>Math.sqrt((l._x-p._x)**2+(l._y-p._y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(l,p,u)=>{let h=Math.floor(l._x-p._x),d=Math.floor(p._x-u._x);return h-d},s=(l,p)=>{let u=Math.hypot(p._x-l._x,p._y-l._y),h=p._y-l._y,d=Math.asin(h/u),c=t(d),f=Math.floor(90-c),m=p._x-l._x<0?-1:1;return f*m},i=(l,p,u)=>{let h=n(l,u),d={_x:(l._x+u._x)/2,_y:(l._y+u._y)/2},c=n(p,d),f=Math.atan(c/h),m=Math.floor(t(f)),g=d._y-p._y<0?-1:1;return m*g};if(!e||!e._positions||e._positions.length!==68)return r;let o=e._positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function jie(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new fr(e.detection.score,a.rescale(s.reverse()),s),o=Hie(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var SC=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},NC=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new SC(t)}draw(e){let t=Va(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof tC&&(t.strokeStyle=s,t.lineWidth=a,ka(t,this.faceLandmarks.getJawOutline()),ka(t,this.faceLandmarks.getLeftEyeBrow()),ka(t,this.faceLandmarks.getRightEyeBrow()),ka(t,this.faceLandmarks.getNose()),ka(t,this.faceLandmarks.getLeftEye(),!0),ka(t,this.faceLandmarks.getRightEye(),!0),ka(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=p=>{t.beginPath(),t.arc(p.x,p.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function qie(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof cd?n:IC(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new NC(r).draw(e)})}function Kie(e,t){let n=Fx(e,t),r=Dx(e,t);function a(i,o,l){let p=r(i,o,`${l}/separable_conv0`),u=r(o,o,`${l}/separable_conv1`),h=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:p,separable_conv1:u,expansion_conv:h}}function s(i,o){let l=r(i,i,`${o}/separable_conv0`),p=r(i,i,`${o}/separable_conv1`),u=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:p,separable_conv2:u}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function Xie(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=as(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Kie(r,n),p=s(3,32,3,"entry_flow/conv_in"),u=o(32,64,"entry_flow/reduction_block_0"),h=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:p,reduction_block_0:u,reduction_block_1:h},c={};Eo(t,0,1).forEach(y=>{c[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:c,exit_flow:g}}}function Zie(e,t){let n=Zi(e,t),r=bC(n),a=Mx(n);function s(o){let l=a(`${o}/separable_conv0`),p=a(`${o}/separable_conv1`),u=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:p,expansion_conv:u}}function i(o){let l=a(`${o}/separable_conv0`),p=a(`${o}/separable_conv1`),u=a(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:p,separable_conv2:u}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function Jie(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=Zie(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),p=s("entry_flow/reduction_block_1"),u={conv_in:o,reduction_block_0:l,reduction_block_1:p},h={};Eo(t,0,1).forEach(m=>{h[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let d=s("exit_flow/reduction_block"),c=a("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:c};return rs(e,n),{params:{entry_flow:u,middle_flow:h,exit_flow:f},paramMappings:n}}function TC(e,t,n){return J(cn(e,t.filters,n,"same"),t.bias)}function Df(e,t,n=!0){let r=n?Ye(e):e;return r=Qn(r,t.separable_conv0,[1,1]),r=Qn(Ye(r),t.separable_conv1,[1,1]),r=Wt(r,[3,3],[2,2],"same"),r=J(r,TC(e,t.expansion_conv,[2,2])),r}function Yie(e,t){let n=Qn(Ye(e),t.separable_conv0,[1,1]);return n=Qn(Ye(n),t.separable_conv1,[1,1]),n=Qn(Ye(n),t.separable_conv2,[1,1]),n=J(n,e),n}var Qie=class extends ns{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return W(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=qp(n,[122.782,117.001,104.298]).div(255),a=Ye(TC(r,t.entry_flow.conv_in,[2,2]));return a=Df(a,t.entry_flow.reduction_block_0,!1),a=Df(a,t.entry_flow.reduction_block_1),Eo(this._numMainBlocks,0,1).forEach(s=>{a=Yie(a,t.middle_flow[`main_block_${s}`])}),a=Df(a,t.exit_flow.reduction_block),a=Ye(Qn(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await yn(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return Jie(e,this._numMainBlocks)}extractParams(e){return Xie(e,this._numMainBlocks)}};function eoe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=as(e),a=mC(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function toe(e){let t=[],n=Zi(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return rs(e,t),{params:a,paramMappings:t}}var noe=(e=>(e.FEMALE="female",e.MALE="male",e))(noe||{}),roe=class extends ns{constructor(e=new Qie(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return W(()=>{let n=e instanceof gd?this.faceFeatureExtractor.forwardInput(e):e,r=ha(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=Om(r,t.fc.age).as1D(),s=Om(r,t.fc.gender);return{age:a,gender:s}})}forwardInput(e){return W(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:Ja(n)}})}async forward(e){return this.forwardInput(await yn(e))}async predictAgeAndGender(e){let t=await yn(e),n=await this.forwardInput(t),r=St(n.age),a=St(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:a[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let p=o.dataSync()[0],u=l.dataSync()[0],h=u>.5,d=h?"male":"female",c=h?u:1-u;return o.dispose(),l.dispose(),{age:p,gender:d,genderProbability:c}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return eoe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=vC(e);return this.faceFeatureExtractor.loadFromWeightMap(t),toe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},CC=class extends kC{postProcess(e,t,n){let r=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),a=r.length;return W(()=>{let s=(p,u)=>Ot([Wn([68],p,"float32"),Wn([68],u,"float32")],1).as2D(1,136).as1D(),i=(p,u)=>{let{width:h,height:d}=r[p];return u(h,d)?Math.abs(h-d)/2:0},o=p=>i(p,(u,h)=>u<h),l=p=>i(p,(u,h)=>h<u);return e.mul(Wn([a,136],t,"float32")).sub(Ot(Array.from(Array(a),(p,u)=>s(o(u),l(u))))).div(Ot(Array.from(Array(a),(p,u)=>s(r[u].width,r[u].height))))})}forwardInput(e){return W(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await yn(e))}async detectLandmarks(e){let t=await yn(e),n=W(()=>St(this.forwardInput(t))),r=await Promise.all(n.map(async(a,s)=>{let i=Array.from(a.dataSync()),o=i.filter((p,u)=>Fm(u)),l=i.filter((p,u)=>!Fm(u));return new tC(Array(68).fill(0).map((p,u)=>new Ke(o[u],l[u])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(a=>a.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},aoe=class extends CC{constructor(e=new wC){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function soe(e){let t=[],{extractDenseBlock3Params:n}=xC(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return rs(e,t),{params:r,paramMappings:t}}function ioe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=as(e),{extractDenseBlock3Params:a}=yC(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var ooe=class extends ns{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return W(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=qp(n,[122.782,117.001,104.298]).div(255),a=Ff(r,t.dense0,!0);return a=Ff(a,t.dense1),a=Ff(a,t.dense2),a=ha(a,[14,14],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await yn(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return soe(e)}extractParams(e){return ioe(e)}},loe=class extends CC{constructor(e=new ooe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function uoe(e,t){return J(z(e,t.weights),t.biases)}function Lx(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=cn(e,s,n,a);return o=J(o,i),o=uoe(o,t.scale),r?Ye(o):o}function poe(e,t){return Lx(e,t,[1,1],!0)}function _C(e,t){return Lx(e,t,[1,1],!1)}function EC(e,t){return Lx(e,t,[2,2],!0,"valid")}function hoe(e,t){function n(o,l,p){let u=e(o),h=u.length/(l*p*p);if(JT(h))throw new Error(`depth has to be an integer: ${h}, weights.length: ${u.length}, numFilters: ${l}, filterSize: ${p}`);return W(()=>Fe(Ma(u,[l,h,p,p]),[2,3,1,0]))}function r(o,l,p,u){let h=n(o,l,p),d=Je(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/bias`}),{filters:h,bias:d}}function a(o,l){let p=Je(e(o)),u=Je(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:p,biases:u}}function s(o,l,p,u){let h=r(o,l,p,`${u}/conv`),d=a(l,`${u}/scale`);return{conv:h,scale:d}}function i(o,l,p,u,h=!1){let d=s((h?.5:1)*o,l,p,`${u}/conv1`),c=s(o,l,p,`${u}/conv2`);return{conv1:d,conv2:c}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function doe(e){let{extractWeights:t,getRemainingWeights:n}=as(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=hoe(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),p=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),h=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),c=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),v=s(589824,256,3,"conv256_down_out"),I=W(()=>Fe(Br(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:p,conv64_down:u,conv64_1:h,conv64_2:d,conv64_3:c,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:v,fc:I},paramMappings:r}}function coe(e,t){let n=Zi(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function a(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),p=r(i);return{conv:{filters:o,bias:l},scale:p}}function s(i){return{conv1:a(`${i}/conv1`),conv2:a(`${i}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function foe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=coe(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),p=r("conv64_1"),u=r("conv64_2"),h=r("conv64_3"),d=r("conv128_down"),c=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!ZT(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:p,conv64_2:u,conv64_3:h,conv128_down:d,conv128_1:c,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return rs(e,t),{params:v,paramMappings:t}}function Rr(e,t){let n=poe(e,t.conv1);return n=_C(n,t.conv2),n=J(n,e),n=Ye(n),n}function Sh(e,t){let n=EC(e,t.conv1);n=_C(n,t.conv2);let r=ha(e,2,2,"valid"),a=bt(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=bt(i);n=nt([n,o],1);let l=[...n.shape];l[2]=1;let p=bt(l);n=nt([n,p],2)}return r=s?nt([r,a],3):r,n=J(r,n),n=Ye(n),n}var moe=class extends ns{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return W(()=>{let n=se(e.toBatchTensor(150,!0),"float32"),r=qp(n,[122.782,117.001,104.298]).div(255),a=EC(r,t.conv32_down);a=Wt(a,3,2,"valid"),a=Rr(a,t.conv32_1),a=Rr(a,t.conv32_2),a=Rr(a,t.conv32_3),a=Sh(a,t.conv64_down),a=Rr(a,t.conv64_1),a=Rr(a,t.conv64_2),a=Rr(a,t.conv64_3),a=Sh(a,t.conv128_down),a=Rr(a,t.conv128_1),a=Rr(a,t.conv128_2),a=Sh(a,t.conv256_down),a=Rr(a,t.conv256_1),a=Rr(a,t.conv256_2),a=Sh(a,t.conv256_down_out);let s=a.mean([1,2]);return Le(s,t.fc)})}async forward(e){return this.forwardInput(await yn(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await yn(e),r=W(()=>St(this.forwardInput(n))),a=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return foe(e)}extractParams(e){return doe(e)}};function goe(e,t){return{...e,descriptor:t}}function yoe(e,t){return{...e,age:t}}function boe(e,t,n){return{...e,gender:t,genderProbability:n}}function xoe(e,t){function n(l,p){let u=Ma(e(9*l),[3,3,l,1]),h=Je(e(l)),d=Je(e(l)),c=Je(e(l)),f=Je(e(l));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/batch_norm_scale`},{paramPath:`${p}/batch_norm_offset`},{paramPath:`${p}/batch_norm_mean`},{paramPath:`${p}/batch_norm_variance`}),{filters:u,batch_norm_scale:h,batch_norm_offset:d,batch_norm_mean:c,batch_norm_variance:f}}function r(l,p,u,h,d){let c=Ma(e(l*p*u*u),[u,u,l,p]),f=Je(e(p));return t.push({paramPath:`${h}/filters`},{paramPath:`${h}/${d?"batch_norm_offset":"bias"}`}),{filters:c,bias:f}}function a(l,p,u,h){let{filters:d,bias:c}=r(l,p,u,h,!0);return{filters:d,batch_norm_offset:c}}function s(l,p,u){let h=n(l,`${u}/depthwise_conv`),d=a(l,p,1,`${u}/pointwise_conv`);return{depthwise_conv:h,pointwise_conv:d}}function i(){let l=a(3,32,3,"mobilenetv1/conv_0"),p=s(32,64,"mobilenetv1/conv_1"),u=s(64,128,"mobilenetv1/conv_2"),h=s(128,128,"mobilenetv1/conv_3"),d=s(128,256,"mobilenetv1/conv_4"),c=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),m=s(512,512,"mobilenetv1/conv_7"),g=s(512,512,"mobilenetv1/conv_8"),y=s(512,512,"mobilenetv1/conv_9"),b=s(512,512,"mobilenetv1/conv_10"),x=s(512,512,"mobilenetv1/conv_11"),v=s(512,1024,"mobilenetv1/conv_12"),I=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:p,conv_2:u,conv_3:h,conv_4:d,conv_5:c,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:b,conv_11:x,conv_12:v,conv_13:I}}function o(){let l=a(1024,256,1,"prediction_layer/conv_0"),p=a(256,512,3,"prediction_layer/conv_1"),u=a(512,128,1,"prediction_layer/conv_2"),h=a(128,256,3,"prediction_layer/conv_3"),d=a(256,128,1,"prediction_layer/conv_4"),c=a(128,256,3,"prediction_layer/conv_5"),f=a(256,64,1,"prediction_layer/conv_6"),m=a(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),I=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),N=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),C=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),A=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),F=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),R=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:p,conv_2:u,conv_3:h,conv_4:d,conv_5:c,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:I},box_predictor_3:{box_encoding_predictor:N,class_predictor:C},box_predictor_4:{box_encoding_predictor:E,class_predictor:A},box_predictor_5:{box_encoding_predictor:F,class_predictor:R}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function woe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=as(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=xoe(n,t),i=a(),o=s(),l={extra_dim:Tc(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function voe(e,t){let n=Zi(e,t);function r(p,u,h){let d=n(`${p}/Conv2d_${u}_pointwise/weights`,4,`${h}/filters`),c=n(`${p}/Conv2d_${u}_pointwise/convolution_bn_offset`,1,`${h}/batch_norm_offset`);return{filters:d,batch_norm_offset:c}}function a(p){let u=`mobilenetv1/conv_${p}`,h=`MobilenetV1/Conv2d_${p}_depthwise`,d=`${u}/depthwise_conv`,c=`${u}/pointwise_conv`,f=n(`${h}/depthwise_weights`,4,`${d}/filters`),m=n(`${h}/BatchNorm/gamma`,1,`${d}/batch_norm_scale`),g=n(`${h}/BatchNorm/beta`,1,`${d}/batch_norm_offset`),y=n(`${h}/BatchNorm/moving_mean`,1,`${d}/batch_norm_mean`),b=n(`${h}/BatchNorm/moving_variance`,1,`${d}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",p,c)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(p,u){let h=n(`${p}/weights`,4,`${u}/filters`),d=n(`${p}/biases`,1,`${u}/bias`);return{filters:h,bias:d}}function o(p){let u=i(`Prediction/BoxPredictor_${p}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${p}/box_encoding_predictor`),h=i(`Prediction/BoxPredictor_${p}/ClassPredictor`,`prediction_layer/box_predictor_${p}/class_predictor`);return{box_encoding_predictor:u,class_predictor:h}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function koe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=voe(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!jp(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return rs(e,t),{params:s,paramMappings:t}}function Dr(e,t,n){return W(()=>{let r=cn(e,t.filters,n,"same");return r=J(r,t.batch_norm_offset),an(r,0,6)})}var Ioe=.0010000000474974513;function Soe(e,t,n){return W(()=>{let r=Wi(e,t.filters,n,"same");return r=Bi(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Ioe),an(r,0,6)})}function Noe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function Toe(e,t){return W(()=>{let n,r=Dr(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,s)=>{let i=s+1,o=Noe(i);r=Soe(r,a.depthwise_conv,o),r=Dr(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function Coe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),p=Math.min(r[n][1],r[n][3]),u=Math.max(r[n][0],r[n][2]),h=Math.max(r[n][1],r[n][3]),d=(i-a)*(o-s),c=(u-l)*(h-p);if(d<=0||c<=0)return 0;let f=Math.max(a,l),m=Math.max(s,p),g=Math.min(i,u),y=Math.min(o,h),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(d+c-b)}function _oe(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map((u,h)=>({score:u,boxIndex:h})).filter(u=>u.score>a).sort((u,h)=>h.score-u.score),l=u=>u<=r?1:0,p=[];return o.forEach(u=>{if(p.length>=i)return;let h=u.score;for(let d=p.length-1;d>=0;--d){let c=Coe(e,u.boxIndex,p[d]);if(c!==0&&(u.score*=l(c),u.score<=a))break}h===u.score&&p.push(u.boxIndex)}),p}function Eoe(e){let t=St(Fe(e,[1,0])),n=[de(t[2],t[0]),de(t[3],t[1])],r=[J(t[0],me(n[0],2)),J(t[1],me(n[1],2))];return{sizes:n,centers:r}}function $oe(e,t){let{sizes:n,centers:r}=Eoe(e),a=St(Fe(t,[1,0])),s=me(z(fn(me(a[2],5)),n[0]),2),i=J(z(me(a[0],10),n[0]),r[0]),o=me(z(fn(me(a[3],5)),n[1]),2),l=J(z(me(a[1],10),n[1]),r[1]);return Fe(Ot([de(i,s),de(l,o),J(i,s),J(l,o)]),[1,0])}function Aoe(e,t,n){return W(()=>{let r=e.shape[0],a=$oe(P(Pn(n.extra_dim,[r,1,1]),[-1,4]),P(e,[-1,4]));a=P(a,[r,a.shape[0]/r,4]);let s=dr(Ue(t,[0,0,1],[-1,-1,-1])),i=Ue(s,[0,0,0],[-1,-1,1]);i=P(i,[r,i.shape[1]]);let o=St(a),l=St(i);return{boxes:o,scores:l}})}function no(e,t){return W(()=>{let n=e.shape[0],r=P(Tu(e,t.box_encoding_predictor),[n,-1,1,4]),a=P(Tu(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function Roe(e,t,n){return W(()=>{let r=Dr(e,n.conv_0,[1,1]),a=Dr(r,n.conv_1,[2,2]),s=Dr(a,n.conv_2,[1,1]),i=Dr(s,n.conv_3,[2,2]),o=Dr(i,n.conv_4,[1,1]),l=Dr(o,n.conv_5,[2,2]),p=Dr(l,n.conv_6,[1,1]),u=Dr(p,n.conv_7,[2,2]),h=no(t,n.box_predictor_0),d=no(e,n.box_predictor_1),c=no(a,n.box_predictor_2),f=no(i,n.box_predictor_3),m=no(l,n.box_predictor_4),g=no(u,n.box_predictor_5),y=nt([h.boxPredictionEncoding,d.boxPredictionEncoding,c.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=nt([h.classPrediction,d.classPrediction,c.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var uf=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Foe=class extends ns{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return W(()=>{let n=se(e.toBatchTensor(512,!1),"float32"),r=de(me(n,127.5),1),a=Toe(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=Roe(a.out,a.conv11,t.prediction_layer);return Aoe(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await yn(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new uf(t),a=await yn(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let p=Array.from(l.dataSync()),u=_oe(o,p,n,.5,r),h=a.getReshapedInputDimensions(0),d=a.inputSize,c=d/h.width,f=d/h.height,m=o.arraySync(),g=u.map(y=>{let[b,x]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(N=>N*f),[v,I]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(N=>N*c);return new fr(p[y],new eC(v,b,I-v,x-b),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return koe(e)}extractParams(e){return woe(e)}},Doe=.4,Moe=[new Ke(.738768,.874946),new Ke(2.42204,2.65704),new Ke(4.30971,7.04493),new Ke(10.246,4.59428),new Ke(12.6868,11.8741)],Ooe=[new Ke(1.603231,2.094468),new Ke(6.041143,7.080126),new Ke(2.882459,3.518061),new Ke(4.266906,5.178857),new Ke(9.041765,10.66308)],Loe=[117.001,114.697,97.404],zoe="tiny_yolov2_model",Poe="tiny_yolov2_separable_conv_model",Nh=e=>typeof e=="number";function Boe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Nh(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>Nh(t.x)&&Nh(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(Nh)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function zx(e){return W(()=>{let t=z(e,ve(.10000000149011612));return J(Ye(de(e,t)),t)})}function xa(e,t){return W(()=>{let n=Er(e,[[0,0],[1,1],[1,1],[0,0]]);return n=cn(n,t.conv.filters,[1,1],"valid"),n=de(n,t.bn.sub),n=z(n,t.bn.truediv),n=J(n,t.conv.bias),zx(n)})}function wa(e,t){return W(()=>{let n=Er(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Bl(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=J(n,t.bias),zx(n)})}function Woe(e,t){let n=Fx(e,t);function r(i,o){let l=Je(e(i)),p=Je(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:p}}function a(i,o,l){let p=n(i,o,3,`${l}/conv`),u=r(o,`${l}/bn`);return{conv:p,bn:u}}let s=Dx(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function Voe(e,t,n,r){let{extractWeights:a,getRemainingWeights:s}=as(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:p}=Woe(a,i),u;if(t.withSeparableConvs){let[h,d,c,f,m,g,y,b,x]=r,v=t.isFirstLayerConv2d?o(h,d,3,"conv0"):p(h,d,"conv0"),I=p(d,c,"conv1"),N=p(c,f,"conv2"),C=p(f,m,"conv3"),E=p(m,g,"conv4"),A=p(g,y,"conv5"),F=b?p(y,b,"conv6"):void 0,R=x?p(b,x,"conv7"):void 0,S=o(x||b||y,5*n,1,"conv8");u={conv0:v,conv1:I,conv2:N,conv3:C,conv4:E,conv5:A,conv6:F,conv7:R,conv8:S}}else{let[h,d,c,f,m,g,y,b,x]=r,v=l(h,d,"conv0"),I=l(d,c,"conv1"),N=l(c,f,"conv2"),C=l(f,m,"conv3"),E=l(m,g,"conv4"),A=l(g,y,"conv5"),F=l(y,b,"conv6"),R=l(b,x,"conv7"),S=o(x,5*n,1,"conv8");u={conv0:v,conv1:I,conv2:N,conv3:C,conv4:E,conv5:A,conv6:F,conv7:R,conv8:S}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:u,paramMappings:i}}function Uoe(e,t){let n=Zi(e,t);function r(o){let l=n(`${o}/sub`,1),p=n(`${o}/truediv`,1);return{sub:l,truediv:p}}function a(o){let l=n(`${o}/filters`,4),p=n(`${o}/bias`,1);return{filters:l,bias:p}}function s(o){let l=a(`${o}/conv`),p=r(`${o}/bn`);return{conv:l,bn:p}}let i=Mx(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function Goe(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}=Uoe(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else i={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return rs(e,n),{params:i,paramMappings:n}}var Px=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},$C=class extends ns{constructor(e){super("TinyYolov2"),Boe(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=xa(e,t.conv0);return n=Wt(n,[2,2],[2,2],"same"),n=xa(n,t.conv1),n=Wt(n,[2,2],[2,2],"same"),n=xa(n,t.conv2),n=Wt(n,[2,2],[2,2],"same"),n=xa(n,t.conv3),n=Wt(n,[2,2],[2,2],"same"),n=xa(n,t.conv4),n=Wt(n,[2,2],[2,2],"same"),n=xa(n,t.conv5),n=Wt(n,[2,2],[1,1],"same"),n=xa(n,t.conv6),n=xa(n,t.conv7),Tu(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?zx(Tu(e,t.conv0,"valid",!1)):wa(e,t.conv0);return n=Wt(n,[2,2],[2,2],"same"),n=wa(n,t.conv1),n=Wt(n,[2,2],[2,2],"same"),n=wa(n,t.conv2),n=Wt(n,[2,2],[2,2],"same"),n=wa(n,t.conv3),n=Wt(n,[2,2],[2,2],"same"),n=wa(n,t.conv4),n=Wt(n,[2,2],[2,2],"same"),n=wa(n,t.conv5),n=Wt(n,[2,2],[1,1],"same"),n=t.conv6?wa(n,t.conv6):n,n=t.conv7?wa(n,t.conv7):n,Tu(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return W(()=>{let r=se(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?qp(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)})}async forward(e,t){return this.forwardInput(await yn(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new Px(t),a=await yn(e),s=await this.forwardInput(a,n),i=W(()=>St(s)[0].expandDims()),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let p=l.map(c=>c.box),u=l.map(c=>c.score),h=l.map(c=>c.classScore),d=l.map(c=>this.config.classes[c.label]);return kie(p.map(c=>c.rescale(n)),u,this.config.iouThreshold,!0).map(c=>new _x(u[c],h[c],d[c],p[c],o))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return Goe(e,this.config)}extractParams(e){let t=this.config.filterSizes||$C.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(n!==7&&n!==8&&n!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return Voe(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],p=this.config.anchors.length,[u,h,d]=W(()=>{let g=e.reshape([l,l,p,this.boxEncodingSize]),y=g.slice([0,0,0,0],[l,l,p,4]),b=g.slice([0,0,0,4],[l,l,p,1]),x=this.withClassScores?Ja(g.slice([0,0,0,5],[l,l,p,this.config.classes.length]),3):ve(0);return[y,b,x]}),c=[],f=await h.array(),m=await u.array();for(let g=0;g<l;g++)for(let y=0;y<l;y++)for(let b=0;b<p;b++){let x=Rf(f[g][y][b][0]);if(!n||x>n){let v=(y+Rf(m[g][y][b][0]))/l*i,I=(g+Rf(m[g][y][b][1]))/l*o,N=Math.exp(m[g][y][b][2])*this.config.anchors[b].x/l*i,C=Math.exp(m[g][y][b][3])*this.config.anchors[b].y/l*o,E=v-N/2,A=I-C/2,F={row:g,col:y,anchor:b},{classScore:R,label:S}=this.withClassScores?await this.extractPredictedClass(d,F):{classScore:1,label:0};c.push({box:new QT(E,A,E+N,A+C),score:x,classScore:x*R,label:S,...F})}}return u.dispose(),h.dispose(),d.dispose(),c}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map((i,o)=>s[n][r][a][o]).map((i,o)=>({classScore:i,label:o})).reduce((i,o)=>i.classScore>o.classScore?i:o)}},Bx=$C;Bx.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Hoe=class extends Bx{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:Doe,classes:["face"],...e?{anchors:Ooe,meanRgb:Loe}:{anchors:Moe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new fr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?Poe:zoe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},joe=class extends Px{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Kp=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Wx(e,t,n,r,a=({alignedRect:s})=>s){let s=e.map(l=>IC(l)?a(l):l.detection),i=r||(t instanceof Pe?await cC(t,s):await dC(t,s)),o=await n(i);return i.forEach(l=>l instanceof Pe&&l.dispose()),o}var qoe=.4,Koe=[new Ke(1.603231,2.094468),new Ke(6.041143,7.080126),new Ke(2.882459,3.518061),new Ke(4.266906,5.178857),new Ke(9.041765,10.66308)],Xoe=[117.001,114.697,97.404],Zoe=class extends Bx{constructor(){let e={withSeparableConvs:!0,iouThreshold:qoe,classes:["face"],anchors:Koe,meanRgb:Xoe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new fr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},oa={ssdMobilenetv1:new Foe,tinyFaceDetector:new Zoe,tinyYolov2:new Hoe,faceLandmark68Net:new aoe,faceLandmark68TinyNet:new loe,faceRecognitionNet:new moe,faceExpressionNet:new Wie,ageGenderNet:new roe},sle=e=>oa.ssdMobilenetv1.load(e),Joe=class extends Kp{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Vx=class extends Joe{async run(){let e=await this.parentTask,t=await Wx(e,this.input,async n=>Promise.all(n.map(r=>oa.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>Uie(n,t[r]))}withAgeAndGender(){return new Gx(this,this.input)}},Ux=class extends Vx{withAgeAndGender(){return new Hx(this,this.input)}withFaceDescriptors(){return new jx(this,this.input)}},Yoe=class extends Kp{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Gx=class extends Yoe{async run(){let e=await this.parentTask,t=await Wx(e,this.input,async n=>Promise.all(n.map(r=>oa.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:a,gender:s,genderProbability:i}=t[r];return yoe(boe(n,s,i),a)})}withFaceExpressions(){return new Vx(this,this.input)}},Hx=class extends Gx{withFaceExpressions(){return new Ux(this,this.input)}withFaceDescriptors(){return new jx(this,this.input)}},Qoe=class extends Kp{constructor(e,t){super(),this.parentTask=e,this.input=t}},jx=class extends Qoe{async run(){let e=await this.parentTask;return(await Wx(e,this.input,t=>Promise.all(t.map(n=>oa.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>goe(e[n],t))}withFaceExpressions(){return new Ux(this,this.input)}withAgeAndGender(){return new Hx(this,this.input)}},ele=class extends Kp{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?oa.faceLandmark68TinyNet:oa.faceLandmark68Net}},tle=class extends ele{async run(){let e=await this.parentTask,t=e.map(a=>a.detection),n=this.input instanceof Pe?await cC(this.input,t):await dC(this.input,t),r=await Promise.all(n.map(a=>this.landmarkNet.detectLandmarks(a)));return n.forEach(a=>a instanceof Pe&&a.dispose()),e.filter((a,s)=>r[s]).map((a,s)=>jie(a,r[s]))}withFaceExpressions(){return new Ux(this,this.input)}withAgeAndGender(){return new Hx(this,this.input)}withFaceDescriptors(){return new jx(this,this.input)}},nle=class extends Kp{constructor(e,t=new uf){super(),this.input=e,this.options=t}},rle=class extends nle{async run(){let{input:e,options:t}=this,n;if(t instanceof joe)n=oa.tinyFaceDetector.locateFaces(e,t);else if(t instanceof uf)n=oa.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof Px)n=oa.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>Cie({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new tle(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Vx(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Gx(this.runAndExtendWithFaceDetections(),this.input)}};function ile(e,t=new uf){return new rle(e,t)}export{ale as $,uf as O,ile as S,oa as n,sle as s};
